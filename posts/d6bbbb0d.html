<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Design-Pattern | Robin's Blog</title><meta name="author" content="Ruobing Wang"><meta name="copyright" content="Ruobing Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录各种 Design Pattern">
<meta property="og:type" content="article">
<meta property="og:title" content="Design-Pattern">
<meta property="og:url" content="http://ruobingw.com/posts/d6bbbb0d.html">
<meta property="og:site_name" content="Robin&#39;s Blog">
<meta property="og:description" content="记录各种 Design Pattern">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ruobingw.com/posts/d6bbbb0d.htmlcover.png">
<meta property="article:published_time" content="2023-10-24T18:39:54.000Z">
<meta property="article:modified_time" content="2024-05-15T04:17:52.560Z">
<meta property="article:author" content="Ruobing Wang">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="Design Pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ruobingw.com/posts/d6bbbb0d.htmlcover.png"><link rel="shortcut icon" href="/images/logo.png"><link rel="canonical" href="http://ruobingw.com/posts/d6bbbb0d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-54HWWM1WE5"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-54HWWM1WE5');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Ruobing Wang","link":"Link: ","source":"Source: Robin's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Design-Pattern',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-15 00:17:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/config/css/categoryBar.css" type="text/css"><link rel="stylesheet" href="/config/css/nav.css" type="text/css"><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Robin's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> Articles</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/posts/d6bbbb0d.htmlcover.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Robin's Blog"><span class="site-name">Robin's Blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> Articles</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"> <a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Design-Pattern</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-24T18:39:54.000Z" title="Created 2023-10-24 14:39:54">2023-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-15T04:17:52.560Z" title="Updated 2024-05-15 00:17:52">2024-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E7%A8%8B%E7%B1%BB/">工程类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Design-Pattern"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-tree"></i><blockquote>
<p>见 <a href="/posts/1893c9bc.html" title="前置知识">前置知识</a> 来复习 </p>
</blockquote>
</div>
</blockquote>
<blockquote>
<p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://refactoring.guru/design-patterns">深入设计模式</a><br>亚历山大 · 什韦茨</p>
<p>进行的个人总结，感谢支持</p>
</blockquote>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul>
<li>Creational Pattern<ul>
<li>创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性<ul>
<li>Factory Method - 工厂方法<ul>
<li>父类中提供一个创建对象的接口以允许<strong>子类</strong>决定<strong>实例化对象的类型</strong></li>
</ul>
</li>
<li>Abstract Factory - 抽象工厂<ul>
<li>允许创建一系列相关的对象而 「不用」指定其具体类</li>
</ul>
</li>
<li>Builder - 生成器<ul>
<li>分步骤创建复杂对象，允许使用相同的创建代码生成不同类型和形式的对象</li>
</ul>
</li>
<li>Prototype - 原型<ul>
<li>让人能复制已有对象，而又无须使代码依赖他们所属的类</li>
</ul>
</li>
<li>Singleton - 单例<ul>
<li>让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Structural Pattern<ul>
<li>结构型模式介绍如何将对象和类组装成较大的结构，并保持结构的灵活和高效<ul>
<li>Adapter - 适配器<ul>
<li>让接口不兼容的对象能够相互工作</li>
</ul>
</li>
<li>Bridge - 桥接<ul>
<li>可将一个大类或一系列紧密相关的类拆分为「抽象」和「实现」两个独立的层次结构，从而能在开发时分别使用</li>
</ul>
</li>
<li>Composite - 组合<ul>
<li>使用它将对象组合成树状结构，并且像独立对象一样使用它们</li>
</ul>
</li>
<li>Decorator - 装饰<ul>
<li>通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为</li>
</ul>
</li>
<li>Facade - 外观<ul>
<li>为程序库，框架或其他复杂类提供一个简单的接口</li>
</ul>
</li>
<li>Flyweight - 享元<ul>
<li>摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象</li>
</ul>
</li>
<li>Proxy - 代理<ul>
<li>让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Behavioral Pattern<ul>
<li>行为模式负责对象间的高效沟通和职责委派</li>
</ul>
</li>
</ul>
<h1 id="Creational-Pattern"><a href="#Creational-Pattern" class="headerlink" title="Creational Pattern"></a>Creational Pattern</h1><h2 id="工厂方法-Factory-Method"><a href="#工厂方法-Factory-Method" class="headerlink" title="工厂方法 - Factory Method"></a>工厂方法 - Factory Method</h2><p><img src="/posts/d6bbbb0d/Factory_Method_1.png" alt="Factory_Method_1"></p>
<blockquote>
<p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p>
</blockquote>
<h3 id="现实问题"><a href="#现实问题" class="headerlink" title="现实问题"></a>现实问题</h3><p>一开始写的代码只支持卡车运输，大部分代码都在卡车类下。一段时间以后，需要支持其他的运输方式，比如海运，那么由于现在的代码几乎都在卡车下，想要实现新的方式就会比较困难。因此不得不大幅度，频繁修改代码，并根据不同的运输对象类在应用中进行不同的处理</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法建议使用特殊的<strong>工厂方法代替对于对象构造函数的直接调用</strong></p>
<p><img src="/posts/d6bbbb0d/Factory_Method_2.png" alt="Factory_Method_2"></p>
<p>在 子类的createTransport中调用 new 从而返回产品</p>
<p>这样的好处是我们现在可以在子类中重写工厂方法，从而改变其创建产品的类型。</p>
<p>但是，仅当这些产品具有共同的基类或者接口时，子类才可以返回不同类型的产品。同时，基类中的工厂方法还应将返回类型声明为这一公共接口：</p>
<p><img src="/posts/d6bbbb0d/Factory_Method_3.png" alt="Factory_Method_3"></p>
<p>总结：<code>卡车Truck</code> 和 <code>轮船Ship</code> 类都必须实现 <code>运输Trans­port</code> 接口， 该接口声明了一个名为 <code>deliver交付</code> 的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  <code>陆路运输Road­Logis­tics</code>类中的工厂方法返回卡车对象， 而 <code>海路运输Sea­Logis­tics</code>类则返回轮船对象。</p>
<p>这样就可以使得调用工厂部分的代码，即客户端代码 不需要知道不同子类和返回实际对象之间的区别。客户端将所有产品都认为是 抽象的 <code>运输</code> 客户端知道所有运输对象都提供 交付 的方法，但是不需要知道具体是怎么实现的。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/Factory_Method_4.png" alt="Factory_Method_4"></p>
<p><code>产品 （Prod­uct）</code> 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 </p>
<p><code>具体产品 （Con­crete Prod­ucts</code>） 是产品接口的不同实现。 </p>
<p><code>创建者 （Cre­ator）</code> 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。<br>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。<br>注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 </p>
<p><code>具体创建者  （Con­crete Cre­ators</code>） 将会重写基础工厂方法， 使其返回不同类型的产品。<br>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><img src="/posts/d6bbbb0d/Factory_Method_5.png" alt="Factory_Method_5"></p>
<p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Win­dows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Win­dows 样式渲染按钮。 </p>
<p>如需该模式正常工作， 基础对话框类必须使用<strong>抽象</strong>按钮 （例如基类或接口）， <strong>以便将其扩展为具体按钮</strong>。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p>
<p>每向对话框中添加一个新的工厂方法， 你就离<strong>抽象工厂模式</strong>更近一步。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>产品接口 + 产品类：</p>
<p>需要 一个 interface / 基类 product 抽象化从而可以扩展为具体的product</p>
<p>需要 concrete products 来实现具体的功能</p>
<p>工厂接口 + 工厂类：</p>
<p>需要一个Creator 从而让客户端能够调用</p>
<p>需要 concrete creator来返回具体的实例类型</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span></span><br><span class="line"><span class="comment">//&nbsp;该方法的实现。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Dialog</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;创建者还可提供一些工厂方法的默认实现。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">abstract</span>&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;法并使其返回不同类型的产品来间接修改业务逻辑。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;调用工厂方法创建一个产品对象。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Button</span>&nbsp;<span class="variable">okButton</span>&nbsp;<span class="operator">=</span>&nbsp;createButton()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;现在使用产品。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;okButton.onClick(closeDialog)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体创建者将重写工厂方法以改变其所返回的产品类型。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WindowsDialog</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dialog</span> “is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WebDialog</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dialog</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;产品接口中将声明所有具体产品都必须实现的操作。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体产品需提供产品接口的各种实现。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WindowsButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">(a,&nbsp;b)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染按钮。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;绑定本地操作系统点击事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">HTMLButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">(a,&nbsp;b)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回一个按钮的&nbsp;HTML&nbsp;表述。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;绑定网络浏览器的点击事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field dialog:&nbsp;Dialog</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;程序根据当前配置或环境设定选择创建者的类型。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">initialize</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">config</span>&nbsp;<span class="operator">=</span>&nbsp;readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Windows"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">dialog</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WindowsDialog</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Web"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">dialog</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WebDialog</span>()</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Exception</span>(<span class="string">"错误！未知的操作系统。"</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;类传递给客户端。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.initialize()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;dialog.render()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>无法预知对象确切类别以及依赖关系</p>
<ol>
<li>工厂方法将创建产品的代码和实际的使用逻辑分离，从而能在不影响其他代码的情况下扩展产品创建部分的代码</li>
<li>例如，如果需要向应用中添加一种新产品，我们现在只需要开发新的创建者子类，然后重写其工厂方法即可</li>
</ol>
</li>
<li><p>需要用户扩展应用库或框架的内部组件</p>
<ol>
<li>将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。 </li>
<li>假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 <code>圆形按钮Round­But­ton子类</code>来继承标准的 <code>按钮But­ton</code>类。 但是， 你需要告诉<code> UI框架UIFrame­work类</code>使用新的子类按钮代替默认按钮。<br>为了实现这个功能， 你可以根据基础框架类开发子类 <code>圆形按钮UI UIWith­Round­But­tons</code> ， 并且重写其 <code>create­Button</code>创建按钮方法。 基类中的该方法返回 <code>按钮对象</code>， 而你开发的子类返回 <code>圆形按钮对象</code>。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。</li>
</ol>
</li>
<li><p>复用对象，而不是每一次都创建新对象</p>
<ol>
<li><p>比如数据库连接</p>
</li>
<li><p>复用现有对象的方法： </p>
<p>首先， 你需要创建存储空间来存放所有已经创建的对象。<br>当他人请求一个对象时， 程序将在对象池中搜索可用对象。<br>…然后将其返回给客户端代码。<br>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）</p>
</li>
<li><p>我们需要 一个既能够创建新对象， 又可以重用现有对象的普通方法 – 工厂方法：</p>
<ol>
<li>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。 </li>
<li>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。 </li>
<li>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。<br>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。 </li>
<li>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。 </li>
<li>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。<br>例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ；  运输及其子类 飞机, 卡车和 火车 。  航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。 </li>
<li>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品接口以及具体的产品类：</span></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：AirMail</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirMail</span> <span class="keyword">implements</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Using AirMail"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：LandMail</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandMail</span> <span class="keyword">implements</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Using LandMail"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductFactory</span> {</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> pool.get(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (product == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 根据类型创建新产品</span></span><br><span class="line">            <span class="keyword">switch</span> (type) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"AirMail"</span>:</span><br><span class="line">                    product = <span class="keyword">new</span> <span class="title class_">AirMail</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"LandMail"</span>:</span><br><span class="line">                    product = <span class="keyword">new</span> <span class="title class_">LandMail</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="literal">null</span>) {</span><br><span class="line">                pool.put(type, product); <span class="comment">// 将新创建的产品添加到池中</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放产品实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseProduct</span><span class="params">(String type, Product product)</span> {</span><br><span class="line">        pool.put(type, product);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProductFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取AirMail产品实例</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">airMail</span> <span class="operator">=</span> factory.getProduct(<span class="string">"AirMail"</span>);</span><br><span class="line">        airMail.useProduct();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取LandMail产品实例</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">landMail</span> <span class="operator">=</span> factory.getProduct(<span class="string">"LandMail"</span>);</span><br><span class="line">        landMail.useProduct();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><code>ProductFactory</code> 类管理着一个对象池，当请求一个特定类型的产品时，它首先尝试从池中获取。如果池中没有可用的产品实例，则创建一个新的实例并将其添加到池中。这样，当同一类型的产品再次被请求时，可以重用之前创建的实例，而不是每次都创建新的实例。</p>
<p>额外的：工厂方法 后 演变为 抽象工厂，原型，生成器 方法</p>
<h2 id="抽象工厂方法-Abstract-Factory"><a href="#抽象工厂方法-Abstract-Factory" class="headerlink" title="抽象工厂方法 - Abstract Factory"></a>抽象工厂方法 - Abstract Factory</h2><p>其是一种创建型设计模式，它能 <strong>创建一系列相关的对象</strong> 而无需指定具体类</p>
<p><img src="/posts/d6bbbb0d/abstract_factory_1.png" alt="abstract_factory_1"></p>
<h3 id="现实问题-1"><a href="#现实问题-1" class="headerlink" title="现实问题"></a>现实问题</h3><p>假设正在开发一款家具商店模拟器</p>
<p>代码中有一些类：</p>
<ol>
<li>来表示相关产品：椅子，沙发，咖啡桌</li>
<li>系列产品的不同变体。比如 有 现代风格的椅子，或者XX风格的椅子</li>
</ol>
<p><img src="/posts/d6bbbb0d/abstract_factory_2.png" alt="abstract_factory_2"></p>
<p>也就是说对于每一种商品。我们有多种变体。</p>
<p>因此我们需要对于每一种艺术风格，我们都需要设计一种家具对象。并且我们当然<strong>不希望</strong>在添加新产品/风格的时候修改已有的代码。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>抽象工厂模式建议为 <strong>系列中的每一件产品</strong> 明确声明接口。然后确保<strong>所有变体</strong>都<strong>继承/实现</strong>这些接口</li>
</ol>
<p>e.g: 所有风格的椅子都实现椅子接口。</p>
<p><img src="/posts/d6bbbb0d/abstract_factory_3.png" alt="abstract_factory_3"></p>
<ol start="2">
<li>然后我们需要一个抽象工厂其包含系列中所有产品构造方法的接口。<code>createChair</code> <code>createSofa</code> <code>createXXX</code>,这些接口都必须返回抽象产品类型也就是 <code>createChair:Chair</code> <code>createSofa:Sofa``createCoffeeTable:CoffeTable</code></li>
</ol>
<p><img src="/posts/d6bbbb0d/abstract_factory_4.png" alt="abstract_factory_4"></p>
<ol start="3">
<li>对于每一个变体，使用<strong>「抽象工厂接口」来创建不同的「工厂类」</strong> 每一个工厂类都只能返回特定类别的产品，比如VictorianFurnitureFactory 返回 Victorian，Modern 返回 Modern</li>
</ol>
<p>这样，客户端就可以通过相应的抽象接口调用工厂和产品类而无需修改客户端代码</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/abstract_factory_5.png" alt="abstract_factory_5"></p>
<ol>
<li><em>ProductA, ProductB:</em> （Abstract Product 抽象产品） 构成系列产品的一组不同但相关的产品声明接口</li>
<li>Concrete ProductX: (Concrete Product 具体产品) 抽象产品的多种不同类型实现。所有变体（风格，比如维多利亚/现代）都必须实现相应的抽象产品（椅子/沙发）</li>
<li>Abstract Factory 抽象工厂: 接口声明一组创建 <strong>抽象产品</strong>的方法</li>
<li>ConcreteFactoryX 具体工厂：实现抽象工厂的构建方法，每一个具体工厂都生产且仅创建对应产品变体</li>
<li>客户端对于具体产品的初始化，其构建方法签名必须返回相应的 <strong>抽象</strong> 产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。客户端只需要通过抽象接口嗲用工厂和产品对象，就能与任何具体工厂/产品变体交互。</li>
</ol>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><p><img src="/posts/d6bbbb0d/abstract_factory_6.png" alt="abstract_factory_6"></p>
<p>这个例子通过使用 <strong>抽象工厂</strong> 模式从而使得客户端代码与具体UI类耦合从而创建跨平台的UI元素，同时确保所创建的元素与制定的操作系统匹配。</p>
<p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Win­dows 系统下运行的应用程序中显示 macOS 的控件。 </p>
<p>抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。 </p>
<p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。 </p>
<p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。 </p>
<p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>伪代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">//&nbsp;且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span></span><br><span class="line"><span class="comment">//&nbsp;品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span></span><br><span class="line"><span class="comment">//&nbsp;使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span></span><br><span class="line"><span class="comment">//&nbsp;行实例化。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinFactory</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinButton</span>()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacFactory</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacButton</span>()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体产品由相应的具体工厂创建。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;macOS&nbsp;样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span></span><br><span class="line"><span class="comment">//&nbsp;品之间才能够正确地进行交互。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinCheckbox</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染复选框。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacCheckbox</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;macOS&nbsp;样式渲染复选框。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码仅通过抽象类型（GUIFactory、Button&nbsp;和&nbsp;Checkbox）使用工厂</span></span><br><span class="line"><span class="comment">//&nbsp;和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field factory:&nbsp;GUIFactory</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field button:&nbsp;Button</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Application</span><span class="params">(factory:&nbsp;GUIFactory)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.factory&nbsp;=&nbsp;factory</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createUI</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.button&nbsp;=&nbsp;factory.createButton()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span></span><br><span class="line"><span class="comment">//&nbsp;始化阶段）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">ApplicationConfigurator</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">config</span>&nbsp;<span class="operator">=</span>&nbsp;readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Windows"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">factory</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinFactory</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Mac"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">factory</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacFactory</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Exception</span>(<span class="string">"错误！未知的操作系统。"</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Application</span>&nbsp;<span class="variable">app</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Application</span>(factory)</span><br></pre></td></tr></tbody></table></figure>

<p>实际的java code例子：</p>
<p>在这个例子中，我们创建一个关于电子产品的简单场景。</p>
<p>假设有两类产品：手机和平板电脑，分别有不同的品牌（例如：苹果和三星）。我们将实现抽象工厂和具体工厂来创建这些产品。</p>
<p>在这个例子中，<code>ElectronicsFactory</code> 是一个抽象工厂接口，定义了创建智能手机和平板电脑的方法。<code>AppleFactory</code> 和 <code>SamsungFactory</code> 是具体的工厂实现，分别创建苹果和三星品牌的产品。客户端代码依赖于抽象工厂和产品接口，而不是具体的实现类，这使得增加新的产品品牌（例如添加一个华为工厂）时，无需修改客户端代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleSmartphone</span> <span class="keyword">implements</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Apple Smartphone"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungSmartphone</span> <span class="keyword">implements</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Samsung Smartphone"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleTablet</span> <span class="keyword">implements</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Apple Tablet"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungTablet</span> <span class="keyword">implements</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Samsung Tablet"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span>;</span><br><span class="line">    Tablet <span class="title function_">createTablet</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleSmartphone</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tablet <span class="title function_">createTablet</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleTablet</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungFactory</span> <span class="keyword">implements</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SamsungSmartphone</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tablet <span class="title function_">createTablet</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SamsungTablet</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ElectronicsFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">appleSmartphone</span> <span class="operator">=</span> appleFactory.createSmartphone();</span><br><span class="line">        <span class="type">Tablet</span> <span class="variable">appleTablet</span> <span class="operator">=</span> appleFactory.createTablet();</span><br><span class="line"></span><br><span class="line">        appleSmartphone.display();</span><br><span class="line">        appleTablet.display();</span><br><span class="line"></span><br><span class="line">        <span class="type">ElectronicsFactory</span> <span class="variable">samsungFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SamsungFactory</span>();</span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">samsungSmartphone</span> <span class="operator">=</span> samsungFactory.createSmartphone();</span><br><span class="line">        <span class="type">Tablet</span> <span class="variable">samsungTablet</span> <span class="operator">=</span> samsungFactory.createTablet();</span><br><span class="line"></span><br><span class="line">        samsungSmartphone.display();</span><br><span class="line">        samsungTablet.display();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>代码需要与多个不同系列的相关产品交互，但是我们无法预先获取相关信息，不希望代码对于产品具体类进行构建<ol>
<li>抽象工厂的接口可以用于创建么个系列产品的对象，只要代码通过该接口创建对象。</li>
</ol>
</li>
<li>有一个基于一组抽象方法的类，且其主要功能因此变得不明确<ol>
<li>好的代码需要：每个类仅负责一件事，如果一个类与多个类型产品交互，那么我们可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象公差那个类</li>
</ol>
</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><strong>以不同的产品类型与产品变体为维度绘制矩阵</strong>：<ul>
<li>在示例中，我们有两种产品类型：<code>Smartphone</code> 和 <code>Tablet</code>（抽象产品接口），这构成了矩阵的一维。</li>
<li>另一维是产品变体，即不同品牌：<code>Apple</code> 和 <code>Samsung</code>。每个品牌都有其对应的智能手机和平板电脑产品。</li>
</ul>
</li>
<li><strong>为所有产品声明抽象产品接口，并且让所有具体产品类实现这些接口</strong>：<ul>
<li>抽象产品接口为 <code>Smartphone</code> 和 <code>Tablet</code>。具体产品类如 <code>AppleSmartphone</code>, <code>SamsungSmartphone</code>, <code>AppleTablet</code>, <code>SamsungTablet</code> 实现了这些接口。</li>
</ul>
</li>
<li><strong>声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法</strong>：<ul>
<li>抽象工厂接口是 <code>ElectronicsFactory</code>，它定义了创建智能手机和平板电脑的方法（<code>createSmartphone()</code> 和 <code>createTablet()</code>）。</li>
</ul>
</li>
<li><strong>为每种产品变体实现一个具体工厂类</strong>：<ul>
<li>具体工厂类为 <code>AppleFactory</code> 和 <code>SamsungFactory</code>，每个工厂类都实现了 <code>ElectronicsFactory</code> 接口，并能创建特定品牌的智能手机和平板电脑。</li>
</ul>
</li>
<li><strong>在应用程序中开发初始化代码，根据应用程序配置或当前环境对特定具体工厂类进行初始化，并将该工厂对象传递给所有需要创建产品的类</strong>：<ul>
<li>客户端代码 (<code>Client</code> 类) 演示了如何根据需要选择并初始化具体工厂（例如 <code>AppleFactory</code> 或 <code>SamsungFactory</code>），并使用这些工厂来创建产品。</li>
</ul>
</li>
<li><strong>找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用</strong>：<ul>
<li>在客户端代码中，不直接使用产品的构造函数来创建产品实例。相反，它调用工厂对象的 <code>createSmartphone()</code> 和 <code>createTablet()</code> 方法来获取产品实例。</li>
</ul>
</li>
</ol>
<p>抽象工厂和桥接（bridge） 可以搭配使用，如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
<h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 - Builder"></a>生成器 - Builder</h2><p>生成器模式允许我们能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象</p>
<h3 id="现实问题-2"><a href="#现实问题-2" class="headerlink" title="现实问题"></a>现实问题</h3><p>有个对象比较复杂，在构造的时候需要对诸多成员变量和嵌套对象进行复杂的初始化工作。这些用于初始化的代码可能深藏于一个包含众多参数且让人基本看不懂的构造函数中；也可能会散落在客户端代码的多个位置</p>
<p>假如我们需要创建一个 house，house可能有 garage，可能有swimmingpool，garden etc；如果为每种可能的对象都创建一个子类，那么可能会导致程序变得过于复杂。</p>
<p>一种可行的方法为：我们有一个House的基类，然后创建一系列涵盖所有参数组合的子类。但是这会使得我们在新增了任何参数比如门框大小，雕塑等等都会使得这个房屋的层次结构变得非常复杂。</p>
<p><img src="/posts/d6bbbb0d/builder_1.png" alt="builder_1"></p>
<p>另一种方法则是实用一个超级构造函数：</p>
<p><img src="/posts/d6bbbb0d/builder_2.png" alt="builder_2"></p>
<p>但是这样的话就会使得构造函数非常的臃肿，并且我们有很多参数是不会使用的。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>生成器模式则建议将对象构造代码从产品类中抽出，并且方位一个<code>生成器</code> 的类中：</p>
<p><img src="/posts/d6bbbb0d/builder_3.png" alt="builder_3"></p>
<p>这个模式会让构造对象划分为一组步骤：<code>buildWalls()</code> <code>buildDoors()</code>。在创建对象的时候，都需要通过生成器对象来执行一系列步骤。不同的是，我们只需要选择需要的步骤即可。</p>
<p>当我们需要创建不同形式的产品时，其中的一些构造步骤需要不同的实现，比如木屋需要木制门，铁屋需要铁门等等。</p>
<p>如果是这种情况，那我们可以创建多个不同的Builder，用不同的方式实现一组相同的创建步骤，然后在创建过程中使用这些生成器来实现不同的对象</p>
<p><img src="/posts/d6bbbb0d/builder_4.png" alt="builder_4"></p>
<h4 id="主管"><a href="#主管" class="headerlink" title="主管"></a>主管</h4><p>额外的，我们可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器提供步骤的具体实现</p>
<p><img src="/posts/d6bbbb0d/builder_5.png" alt="builder_5"></p>
<p>主管类不是必须的，他比较适用于在流水线工程中以便能够重复使用。在一般情况下，客户端代码直接以特定顺序调用创建步骤即可。</p>
<p>对于客户端代码来说，主管类隐藏了产品构造细节。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/builder_6.png" alt="builder_6"></p>
<ol>
<li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。 </li>
<li>具体生成器 （Con­crete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。 </li>
<li>产品 （Prod­ucts） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。 </li>
<li>主管 （Direc­tor） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。 </li>
<li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li>
</ol>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><p>使用builder pattern来生成Car以及CarManual</p>
<p><img src="/posts/d6bbbb0d/builder_7.png" alt="builder_7"></p>
<p>汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有在 汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。 </p>
<p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p>
<p>每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手册。 当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。 </p>
<p>最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。因此， 我们只能通过负责制造过程的生成器来获取结果对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个</span></span><br><span class="line"><span class="comment">//&nbsp;产品尽管没有同样的接口，但却相互关联。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Car</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;一辆汽车可能配备有&nbsp;GPS&nbsp;设备、行车电脑和几个座位。不同型号的汽车（</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;运动型轿车、SUV&nbsp;和敞篷车）可能会安装或启用不同的功能。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Manual</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;生成器接口声明了创建产品对象不同部件的方法。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会</span></span><br><span class="line"><span class="comment">//&nbsp;有多个以不同方式实现的生成器变体。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CarBuilder</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field car:Car</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">CarBuilder</span><span class="params">()</span>&nbsp;is</span><br><span class="line">  	<span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;reset（重置）方法可清除正在生成的对象。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.car&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;所有生成步骤都会与同一个产品实例进行交互。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;设置汽车座位的数量。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装指定的引擎。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装行车电脑。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装全球定位系统。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;准备。因此生成器实例通常会在&nbsp;`getProduct（获取产品）`方法主体末尾</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;调用重置方法后再去处理之前的结果。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getProduct</span><span class="params">()</span>:Car&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">product</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="built_in">this</span>.car</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.reset()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;product</span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;生成器与其他创建型“模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CarManualBuilder</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field manual:Manual</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">CarManualBuilder</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.manual&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于汽车座椅功能的文档。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于引擎的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于行车电脑的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于&nbsp;GPS&nbsp;的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getProduct</span><span class="params">()</span>:Manual&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回使用手册并重置生成器。</span></span><br><span class="line"><span class="comment">//&nbsp;主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时</span></span><br><span class="line"><span class="comment">//&nbsp;会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并</span></span><br><span class="line"><span class="comment">//&nbsp;不是必需的。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Director</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field builder:Builder</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;过这种方式改变最新组装完毕的产品的最终类型。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setBuilder</span><span class="params">(builder:Builder)</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.builder&nbsp;=&nbsp;builder</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;主管可使用同样的生成步骤创建多个产品变体。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">constructSportsCar</span><span class="params">(builder:&nbsp;Builder)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.reset()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setSeats(<span class="number">2</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setEngine(<span class="keyword">new</span>&nbsp;<span class="title class_">SportEngine</span>())</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">constructSUV</span><span class="params">(builder:&nbsp;“Builder)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果</span></span><br><span class="line"><span class="comment">//&nbsp;将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">makeCar</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">director</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">CarBuilder</span>&nbsp;<span class="variable">builder</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CarBuilder</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;director.constructSportsCar(builder)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Car</span>&nbsp;<span class="variable">car</span>&nbsp;<span class="operator">=</span>&nbsp;builder.getProduct()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">CarManualBuilder</span>&nbsp;<span class="variable">builder</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CarManualBuilder</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;产品的存在，也不会对其产生依赖。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Manual</span>&nbsp;<span class="variable">manual</span>&nbsp;<span class="operator">=</span>&nbsp;builder.getProduct()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>避免重叠构造函数的出现</p>
<ul>
<li>一个构造函数中有十几个可选参数，或者复写这个函数来包含一些较少参数的简化版方法：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Pizza</span>&nbsp;{</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size)&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size,&nbsp;<span class="type">boolean</span>&nbsp;cheese)&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size,&nbsp;<span class="type">boolean</span>&nbsp;cheese,&nbsp;<span class="type">boolean</span>&nbsp;pepperoni)&nbsp;{&nbsp;...&nbsp;}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>生成器模式让你可以分<strong>步骤生成对象</strong>， 而且允许你<strong>仅使用必须的步骤</strong>。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</li>
</ul>
</li>
<li><p>使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p>
<ul>
<li>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。 </li>
<li>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序</li>
</ul>
</li>
<li><p>使用生成器构造组合树或其他复杂对象。</p>
<ul>
<li>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</li>
</ul>
</li>
</ul>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>定义通用步骤，确保可以制造所有形式的产品</li>
<li>在基本生成器接口中生命这些步骤</li>
<li>为每个形式的产品创建具体生成器类并实现具体的步骤，还要实现获取构造结果对象的方法。不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</li>
<li><strong>考虑</strong>创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式.</li>
<li>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</li>
<li>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</li>
</ol>
<h2 id="原型-Clone-Prototype"><a href="#原型-Clone-Prototype" class="headerlink" title="原型 - Clone, Prototype"></a>原型 - Clone, Prototype</h2><p>原型模式使得能够复制已有对象而又无需使代码依赖他们所属的类</p>
<h3 id="现实问题-3"><a href="#现实问题-3" class="headerlink" title="现实问题"></a>现实问题</h3><p>我们有一个对象并且希望生成一个完全相同的复制品。一个可行的办法是创建个属于相同类的对象然后循环复制所有的原始对象的成员变量。</p>
<p>但是这个的问题在于，我们会有一些<strong>私有成员变量</strong>而这些在对象本身以外是不可见的</p>
<p>还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过原型模式我们可以将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个<strong>通用接口</strong>这个接口使得我们能够克隆对象同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个<strong>克隆</strong>方法,</p>
<p>所有的类对 克隆 这个方法的实现都非常类似。这个方法会：创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。这样我们就可以复制私有成员变量。</p>
<p>支持克隆的对象被称为<strong>原型</strong></p>
<p>当对象有十几个成员变量和几百种类型时，我们可以创建一系列不同的类型的对象并用不同的方式对其进行配置。如果所需对象与预先配置的对象相同。直接克隆原型即可。</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><img src="/posts/d6bbbb0d/prototype_1.png" alt="prototype_1"></p>
<ol>
<li>原型 （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。 </li>
<li>具体原型 （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。 </li>
<li>客户端 （Client） 可以复制实现了原型接口的任何对象。</li>
</ol>
<h4 id="原型注册表实现"><a href="#原型注册表实现" class="headerlink" title="原型注册表实现"></a>原型注册表实现</h4><p><img src="/posts/d6bbbb0d/prototype_2.png" alt="prototype_2"></p>
<p>原型注册表 （Pro­to­type Reg­istry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</p>
<h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h3><p>原型模式可以生成完全相同的几何对象副本，无需代码与对象所属类耦合</p>
<p><img src="/posts/d6bbbb0d/prototype_3.png" alt="prototype_3"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;基础原型。</span></span><br><span class="line"><span class="keyword">abstract</span>&nbsp;<span class="keyword">class</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field X:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field Y:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field color:&nbsp;string</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;常规构造函数。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Shape</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Shape</span><span class="params">(source:&nbsp;Shape)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">this</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.X&nbsp;=&nbsp;source.X</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.Y&nbsp;=&nbsp;source.Y</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.color&nbsp;=&nbsp;source.color</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;clone（克隆）操作会返回一个形状子类。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">abstract</span>&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span><br><span class="line"><span class="comment">//&nbsp;行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span><br><span class="line"><span class="comment">//&nbsp;成的克隆对象。这可以保持克隆结果的一致。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Rectangle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field width:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field height:&nbsp;<span class="type">int</span></span><br><span class="line">  constructor&nbsp;<span class="title function_">Rectangle</span><span class="params">(source:&nbsp;Rectangle)</span>&nbsp;is</span><br><span class="line">    <span class="comment">//&nbsp;需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="line">    <span class="built_in">super</span>(source)</span><br><span class="line">    <span class="built_in">this</span>.width&nbsp;=&nbsp;source.width</span><br><span class="line">    <span class="built_in">this</span>.height&nbsp;=&nbsp;source.height</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Circle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field radius:&nbsp;<span class="type">int</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Circle</span><span class="params">(source:&nbsp;Circle)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.radius&nbsp;=&nbsp;source.radius</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码中的某个位置。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field shapes:&nbsp;array&nbsp;of&nbsp;Shape</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Application</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Circle</span>&nbsp;<span class="variable">circle</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.X&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.Y&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.radius&nbsp;=&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(circle)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Circle</span>&nbsp;<span class="variable">anotherCircle</span>&nbsp;<span class="operator">=</span>&nbsp;circle.clone()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(anotherCircle)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;变量&nbsp;`anotherCircle（另一个圆）`与&nbsp;`circle（圆）`对象的内</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;容完全一样。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Rectangle</span>&nbsp;<span class="variable">rectangle</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Rectangle</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;rectangle.width&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;rectangle.height&nbsp;=&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(rectangle)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">businessLogic</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;其完全相同的复制品。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Array</span>&nbsp;<span class="variable">shapesCopy</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Array</span>&nbsp;of&nbsp;Shapes.</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;但在多态机制的帮助下，当我们在某个形状上调用&nbsp;`clone（克隆）`</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(s&nbsp;in&nbsp;shapes)&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapesCopy.add(s.clone())</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;`shapesCopy（形状副本）`数组中包含&nbsp;`shape（形状）`数组所有</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;子元素的复制品.</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>需要复制一些对象，同时希望代码独立于这些对象所属的具体类<ul>
<li>这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。<br>原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。实现方法</li>
</ul>
</li>
<li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量<ul>
<li>在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。</li>
<li>客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</li>
</ul>
</li>
</ul>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>创建 <code>Prototype</code>接口，并在其中加入<code>clone</code>方法。</li>
<li>原型类必须另行定义一个以<strong>该类对象为参数的构造函数</strong>。<strong>构造函数必须复制参数对象中的所有成员变量值到新建实体中</strong>。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。<br>如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。</li>
<li>克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。</li>
<li>可以创建一个中心化原型注册表， 用于存储常用原型。<br>可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。<br>最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</li>
</ol>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h2><p>单例是一种能够保证一个类只有一个实例并且提供一个方位该实例的全局节点</p>
<h3 id="现实问题-4"><a href="#现实问题-4" class="headerlink" title="现实问题"></a>现实问题</h3><p>由于单例模式<strong>同时</strong>解决了两个问题，所以他其实「违反了」「单一指责原则」</p>
<ol>
<li><p>保证一个类只有一个实例。为什么？一个可能的原因是想要控制某些共享资源的访问权限：</p>
<ol>
<li><p>如果创建了一个对象，如果过一会决定再创建一个新对象，那么其实获得的是之前已经创建的对象，而不是一个新对象。</p>
</li>
<li><p><img src="/posts/d6bbbb0d/singleton_1.png" alt="singleton_1"></p>
</li>
<li><p>假设有一个应用，需要频繁地访问数据库。如果每次访问数据库时都创建一个新的数据库连接，将会非常耗时且低效，因为建立数据库连接是一个资源密集型和时间密集型的操作。此外，同时打开过多的连接可能会超过数据库的连接限制，导致新的连接失败。</p>
<p>使用单例模式，你可以创建一个<code>DatabaseConnection</code>类，它负责与数据库建立连接。这个类将被设计为单例，确保应用中的任何组件都使用相同的数据库连接实例，从而有效管理对数据库的访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseConnection instance;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DatabaseConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 初始化数据库连接</span></span><br><span class="line">        <span class="built_in">this</span>.connection = <span class="comment">// 创建数据库连接</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DatabaseConnection <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (DatabaseConnection.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DatabaseConnection</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.connection;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>为该实例提供一个全局访问的节点</p>
<ol>
<li><p>单例模式允许程序的任何地方访问特定的对象但是它可以「保护该实例<strong>不</strong>被其他代码覆盖」</p>
</li>
<li><p>考虑一个应用需要读取一些全局配置信息，如配置文件中的设置。使用单例模式，可以创建一个<code>Configuration</code>类，它加载并存储配置信息，应用中的任何部分都可以访问这些信息，而不需要重复加载。并且无法修改内部的内容，因此是安全的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration instance;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Configuration</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Configuration <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Configuration.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.properties.getProperty(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有的单例的实现都包含下面两个相同的步骤：</p>
<ul>
<li><p>设置默认的构造函数为「私有」，防止其他对象使用单例类的<code>new</code>运算符</p>
</li>
<li><p>新建一个静态构建方法作为构造函数。该函数会调用私有的构造函数来创建对象并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这个缓存对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 静态成员变量，存储单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部通过new直接实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {} <span class="comment">// &lt;- 注意他是private的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公开的静态方法，用于获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果实例不存在，则创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 返回实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据代码不难看出，只要调用了这个类里面的getInstance，它总是返回已经创建的相同的对象</p>
</li>
</ul>
<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>比如政府，一个国家只有一个官方政府。不论组成政府的每个人的身份是什么，这个XX政府这个称谓总是鉴别那些掌权者的全局访问节点</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/singleton_2.png" alt="singleton_2"></p>
<p>getInstance 来返回其所属类的一个相同实例。单例的构造函数必须对客户端代码隐藏。客户端只通过getInstance的方法来获取对象</p>
<h3 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span></span><br><span class="line"><span class="comment">//&nbsp;都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Database</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">static</span>&nbsp;field instance:&nbsp;Database</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构造方法。</span></span><br><span class="line">  <span class="keyword">private</span>&nbsp;constructor&nbsp;<span class="title function_">Database</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;method&nbsp;<span class="title function_">getInstance</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">if</span>&nbsp;<span class="params">(Database.instance&nbsp;==&nbsp;<span class="literal">null</span>)</span>&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">acquireThreadLock</span><span class="params">()</span>&nbsp;and&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(Database.instance&nbsp;==&nbsp;<span class="literal">null</span>)&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Database.instance&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Database</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;Database.instance</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;method&nbsp;<span class="title function_">query</span><span class="params">(sql)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里添加限流或缓冲逻辑。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Database</span>&nbsp;<span class="variable">foo</span>&nbsp;<span class="operator">=</span>&nbsp;Database.getInstance()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foo.query(<span class="string">"SELECT&nbsp;..."</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Database</span>&nbsp;<span class="variable">bar</span>&nbsp;<span class="operator">=</span>&nbsp;Database.getInstance()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;bar.query(<span class="string">"SELECT&nbsp;..."</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;变量&nbsp;`bar`&nbsp;和&nbsp;`foo`&nbsp;中将包含同一个对象。</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 <ul>
<li>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</li>
</ul>
</li>
<li>如果你需要更加严格地控制全局变量， 可以使用单例模式。<ul>
<li>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</li>
</ul>
</li>
<li>我们可以随时调整限制并设定生成单例实例的数量， 只需修改 getInstance 方法， 即 getInstance 中的代码即可实现。</li>
</ul>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>在类中添加一个私有静态成员变量用于保存单例实例。 </li>
<li>声明一个公有静态构建方法用于获取单例实例。 </li>
<li>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。 </li>
<li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。 </li>
<li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>外观 (Facade) 类通常可以转换为单例类， 因为在大部分情况下一个外观对象就足够了。 </li>
<li>如果你能将对象的所有共享状态简化为一个享元（cache，缓存）对象， 那么享元就和单例类似了。 但这两个模式有两个根本性的不同。 <ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。 </li>
<li>抽象工厂、 生成器和原型都可以用单例来实现。</li>
</ul>
</li>
</ul>
<h2 id="创建型设计模式总结"><a href="#创建型设计模式总结" class="headerlink" title="创建型设计模式总结"></a>创建型设计模式总结</h2><p>创建型模式主要处理对象创建机制，帮助创建对象时保持系统的灵活性和可维护性。</p>
<ul>
<li><p><strong>单例模式</strong>：当需要确保全局只有一个实例存在，并且提供一个访问它的全局访问点时使用。</p>
<p>例子：数据库连接池的唯一性</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnectionPool</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DatabaseConnectionPool</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DatabaseConnectionPool</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 私有构造器，防止外部直接创建实例</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DatabaseConnectionPool <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回数据库连接</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>工厂方法</strong>和<strong>抽象工厂</strong>：当创建对象时需要考虑系统的灵活性和可扩展性，而不是直接实例化类时使用。工厂方法用于创建一个产品，抽象工厂提供一个接口来创建一系列相关或相互依赖的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    <span class="keyword">abstract</span> Button <span class="title function_">createButton</span><span class="params">()</span>; <span class="comment">// 工厂方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renderButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> createButton();</span><br><span class="line">        button.render();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows按钮工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS按钮工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮和文本框的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows和MacOS的按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows和MacOS的文本框实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows text field"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS text field"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSTextField</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>工厂方法模式</strong>着重于创建单一产品（在这个例子中是按钮）。每个具体的工厂类负责创建单一产品的一个具体实现。</li>
<li><strong>抽象工厂模式</strong>提供一个创建一系列相关或相互依赖产品的接口（在这个例子中是按钮和文本框）。每个具体的工厂类负责创建一系列产品的一组具体实现。</li>
</ul>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><ul>
<li><strong>设计目的</strong>：让子类决定实例化哪一个类。工厂方法模式让类的实例化推迟到子类中进行。</li>
<li><strong>应用场景</strong>：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由其子类来指定它创建的对象时；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你想将哪一个帮助子类是代理者这一信息局部化时。</li>
<li><strong>关键实现</strong>：通过继承来改变实例化的类。子类实现抽象工厂方法以创建具体产品。</li>
</ul>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><ul>
<li><strong>设计目的</strong>：提供一个接口，用于创建相关或相互依赖对象的家族，而不需要明确指定具体类。</li>
<li><strong>应用场景</strong>：当需要创建的对象是一系列相关或相互依赖的对象时；当一个系统要独立于它的产品的创建、组合和表示时；当强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，只想显示它们的接口而不是实现时。</li>
<li><strong>关键实现</strong>：通过对象组合来创建抽象产品的家族。一个工厂实例创建一系列相互依赖的产品。</li>
</ul>
<h5 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h5><ul>
<li><strong>产品范围</strong>：工厂方法模式通常用于一个产品等级结构，而抽象工厂模式用于多个产品等级结构。</li>
<li><strong>控制范围</strong>：工厂方法通过继承来改变实例化哪个类，控制的是生产单一产品的逻辑；抽象工厂通过对象组合来创建一系列产品，控制的是生产多个相互依赖的一系列产品的逻辑。</li>
<li><strong>实现方式</strong>：工厂方法模式依赖于继承，具体产品由子类创建；抽象工厂模式依赖于接口的实现，具体产品的创建委托给了具体工厂的实例。</li>
</ul>
</li>
<li><p><strong>建造者模式</strong>：当需要创建一个包含多个组成部分的复杂对象时，尤其是当对象的创建过程需要多个步骤，且构造过程需要被细化时使用。</p>
<p>构建复杂的HTML文档或SQL查询</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDocument</span> {</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; paragraphs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> {</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParagraph</span><span class="params">(String paragraph)</span> {</span><br><span class="line">        paragraphs.add(paragraph);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 将标题和段落组合成HTML文档</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDocumentBuilder</span> {</span><br><span class="line">    <span class="keyword">private</span> HtmlDocument document;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HtmlDocumentBuilder</span><span class="params">()</span> {</span><br><span class="line">        document = <span class="keyword">new</span> <span class="title class_">HtmlDocument</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocumentBuilder <span class="title function_">withTitle</span><span class="params">(String title)</span> {</span><br><span class="line">        document.setTitle(title);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocumentBuilder <span class="title function_">addParagraph</span><span class="params">(String paragraph)</span> {</span><br><span class="line">        document.addParagraph(paragraph);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocument <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>原型模式</strong>：当创建一个对象的成本较高，且与其类型相似的对象可能会经常使用时，可以通过复制一个已存在对象来减少创建对象的开销。</p>
<ul>
<li><strong>原型模式</strong>的目的是通过<strong>复制现有的实例来创建新的实例</strong>，避免了新实例创建的成本和复杂性。原型模式允许对象在不指定具体类的情况下创建副本。这在需要创建对象的状态与现有对象相似时非常有用。</li>
<li><strong>单例模式</strong>的目的是确保一个类只有一个实例，并提供一个全局访问点。单例模式主要用于全局状态或共享资源的情况，如配置管理器或数据库连接池。在单例模式中，实例是唯一的，且全局可访问。</li>
</ul>
<p>考虑一个后端开发中的场景，如在一个Web应用中管理配置信息的示例。假设你有一个配置对象，它在应用启动时从外部服务加载配置数据，这个过程可能包括网络请求获取数据库连接字符串、API密钥、日志设置等。这个配置对象在应用的不同部分被频繁访问，但是其初始化非常昂贵，因为它涉及到网络请求和数据解析。</p>
<h5 id="不使用原型模式的情况"><a href="#不使用原型模式的情况" class="headerlink" title="不使用原型模式的情况"></a>不使用原型模式的情况</h5><p>每次你需要配置信息时，都去创建一个新的配置对象并从外部服务加载数据。这不仅增加了网络负载，还可能因为外部服务的响应延迟而显著增加了应用的启动时间。</p>
<h5 id="使用原型模式的情况"><a href="#使用原型模式的情况" class="headerlink" title="使用原型模式的情况"></a>使用原型模式的情况</h5><p>在应用启动时创建一次配置对象，并通过原型模式在需要时克隆它。由于配置数据通常在应用运行期间不会改变，所以这个方法可以避免重复的初始化成本。</p>
<p>在这个例子中，使用原型模式可以显著减少从外部服务加载配置信息的次数，因为：</p>
<ul>
<li><p><strong>初始化成本</strong>：原始配置对象的加载包括网络请求和数据解析，这是一次性的，并在首次创建对象时完成。</p>
</li>
<li><p><strong>克隆成本</strong>：通过克隆原始对象来创建新的配置对象实例，避免了重复的网络请求和数据解析。克隆操作主要是内存中的数据复制，其成本远低于外部服务的调用。</p>
</li>
<li><p><strong>运行效率</strong>：应用启动和运行过程中对配置数据的访问变得更快，因为避免了重复的耗时操作。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line">      <span class="keyword">private</span> Map&lt;String, String&gt; settings;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Configuration</span><span class="params">()</span> {</span><br><span class="line">          <span class="built_in">this</span>.settings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          <span class="comment">// 假设这里包含从外部服务加载配置的耗时操作</span></span><br><span class="line">          loadConfigurationFromExternalService();</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadConfigurationFromExternalService</span><span class="params">()</span> {</span><br><span class="line">          <span class="comment">// 模拟网络请求和设置加载</span></span><br><span class="line">          settings.put(<span class="string">"dbConnectionString"</span>, <span class="string">"someConnectionString"</span>);</span><br><span class="line">          settings.put(<span class="string">"apiKey"</span>, <span class="string">"someAPIKey"</span>);</span><br><span class="line">          <span class="comment">// 更多配置...</span></span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> {</span><br><span class="line">          <span class="keyword">return</span> settings.get(key);</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Configuration <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">              <span class="comment">// 浅克隆足够了，因为我们不修改settings内部的数据</span></span><br><span class="line">              <span class="keyword">return</span> (Configuration) <span class="built_in">super</span>.clone();</span><br><span class="line">          } <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="comment">// 不应该发生</span></span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> {</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">          <span class="type">Configuration</span> <span class="variable">originalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">          <span class="type">Configuration</span> <span class="variable">clonedConfig</span> <span class="operator">=</span> originalConfig.clone();</span><br><span class="line">  </span><br><span class="line">          System.out.println(clonedConfig.getSetting(<span class="string">"dbConnectionString"</span>));</span><br><span class="line">          System.out.println(clonedConfig.getSetting(<span class="string">"apiKey"</span>));</span><br><span class="line">          <span class="comment">// 输出与originalConfig加载的相同的配置项，但没有重新从外部服务加载</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"># Structural Pattern</span><br><span class="line"></span><br><span class="line">## 适配器 - Adapter Pattern</span><br><span class="line"></span><br><span class="line">&gt; 适配器是一种结构性设计模式，它能使接口不兼容的对象相互合作</span><br><span class="line"></span><br><span class="line">使一个老的方案通过`adapter`来实现新的方案</span><br><span class="line"></span><br><span class="line">![adapter_guru_1](/posts/d6bbbb0d/adapter_guru_1.png)</span><br><span class="line"></span><br><span class="line">### 现实问题</span><br><span class="line"></span><br><span class="line">当想要整合老旧方案到一个新的方案时，在不修改老方案的内容的情况下，使用adapter：</span><br><span class="line"></span><br><span class="line">A special object that converts the <span class="keyword">interface</span> <span class="title class_">of</span> one object so that another object can understand it.</span><br><span class="line"></span><br><span class="line">假如正在开发一款股票市场监测程序，它会从不同来源下载XML格式的股票数据，然后像用户呈现图表。我们现在需要整合一个第三方的分析函数库。但是这个库只兼容JSON格式的数据。</span><br><span class="line"></span><br><span class="line">一个可能的解决方案有：修改程序库使其支持XML。但是这样就需要修改依赖这个程序库的现有代码。或者我们压根可能对这个程序库没有access。</span><br><span class="line"></span><br><span class="line">![adapater_1](/posts/d6bbbb0d/adapater_1.png)</span><br><span class="line"></span><br><span class="line">### 解决方案</span><br><span class="line"></span><br><span class="line">此时就需要一个适配器，它是一个特殊的对象，主要目的是转换对象借口，使其能够与其他对象进行交互。</span><br><span class="line"></span><br><span class="line">适配器模式通过封装对象从而将一个复杂的转换过程隐藏起来。被封装的对象甚至不知道有适配器这个东西。</span><br><span class="line"></span><br><span class="line">适配器不仅可以转化不同格式的数据，还有助于采用不同接口的对象之间合作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器实现与其中一个现有对象兼容的接口。 </span><br><span class="line"><span class="number">2.</span> 现有对象可以使用该接口安全地调用适配器方法。 </span><br><span class="line"><span class="number">3.</span> 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</span><br><span class="line"></span><br><span class="line">甚至双向适配器也是可以的这样就可以双向转换调用</span><br><span class="line"></span><br><span class="line">![adapter_2](/posts/d6bbbb0d/adapter_2.png)</span><br><span class="line"></span><br><span class="line">对于先前的股票市场问题，为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</span><br><span class="line"></span><br><span class="line">### 结构</span><br><span class="line"></span><br><span class="line">#### 对象适配器：</span><br><span class="line"></span><br><span class="line">适配器实现其冲一个对象的借口，并对另一个对象进行封装。</span><br><span class="line"></span><br><span class="line">![adapter_3](/posts/d6bbbb0d/adapter_3.png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 客户端 （Client） 是包含当前程序业务逻辑的类。 </span><br><span class="line"><span class="number">2.</span> 客户端接口 （Client Inter­face） 描述了其他类与客户端代码合作时必须遵循的协议。 </span><br><span class="line"><span class="number">3.</span> 服务 （Ser­vice） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。 </span><br><span class="line"><span class="number">4.</span> 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时**封装了服务对象**。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。 </span><br><span class="line"><span class="number">5.</span> 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</span><br><span class="line"></span><br><span class="line">#### 类适配器</span><br><span class="line"></span><br><span class="line">主要运用了继承机制，适配器同时继承了两个对象的接口（所以需要支持多重继承的语言 比如，C++）</span><br><span class="line"></span><br><span class="line">![adapter_4](/posts/d6bbbb0d/adapter_4.png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。 </span><br><span class="line"></span><br><span class="line">### 代码样例</span><br><span class="line"></span><br><span class="line">![adapter_5](/posts/d6bbbb0d/adapter_5.png)</span><br><span class="line"></span><br><span class="line">适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//&nbsp;假设你有两个接口相互兼容的类：圆孔（Round­Hole）和圆钉（Round­Peg）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">RoundHole</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">RoundHole</span><span class="params">(radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回孔的半径。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">fits</span><span class="params">(peg:&nbsp;RoundPeg)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="built_in">this</span>.getRadius()&nbsp;&gt;=&nbsp;peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">RoundPeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">RoundPeg</span><span class="params">(radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回钉子的半径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;但还有一个不兼容的类：方钉（Square­Peg）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">SquarePeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">SquarePeg</span><span class="params">(width)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getWidth</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回方钉的宽度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;适配器类让你能够将方钉放入圆孔中。它会对&nbsp;RoundPeg&nbsp;类进行扩展，以接收适</span></span><br><span class="line"><span class="comment">//&nbsp;配器对象作为圆钉。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">SquarePegAdapter</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">RoundPeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;在实际情况中，适配器中会包含一个&nbsp;SquarePeg&nbsp;类的实例。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field peg:&nbsp;SquarePeg</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">SquarePegAdapter</span><span class="params">(peg:&nbsp;SquarePeg)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.peg&nbsp;=&nbsp;peg</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;适配器会假扮为一个圆钉，</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;peg.getWidth()&nbsp;*&nbsp;Math.sqrt(<span class="number">2</span>)&nbsp;/&nbsp;<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码中的某个位置。</span></span><br><span class="line">hole&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">rpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">hole.fits(rpeg)&nbsp;<span class="comment">//&nbsp;true</span></span><br><span class="line"></span><br><span class="line">small_sqpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">large_sqpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">hole.fits(small_sqpeg)&nbsp;<span class="comment">//&nbsp;此处无法编译（类型不一致）。</span></span><br><span class="line">    </span><br><span class="line">small_sqpeg_adapter&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">hole.fits(small_sqpeg_adapter)&nbsp;<span class="comment">//&nbsp;true</span></span><br><span class="line">hole.fits(large_sqpeg_adapter)&nbsp;<span class="comment">//&nbsp;false</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。 </p>
<p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。 </p>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保至少有两个类的接口不兼容： <ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。 </li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li>声明客户端接口， 描述客户端如何与服务交互。 </li>
<li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。 </li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。 </li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。 </li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><p><strong>桥接通常会于开发前期进行设计</strong>， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <strong>适配器通常在已有程序中使用</strong>， 让相互不兼容的类能很好地合作。</p>
<p>适配器可以对已有对象的接口进行修改， <strong>装饰</strong>则能在<strong>不改变对象接口的前提下强化对象功能</strong>。 此外， <strong>装饰还支持递归组合</strong>， 适配器则无法实现。</p>
<p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。 </p>
<p>外观为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。 </p>
<p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
<h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接 - Bridge"></a>桥接 - Bridge</h2><blockquote>
<p>桥接是一种结构型设计模式，可将一个「大类」或「一系列紧密相关的类」「拆分」为「抽象」和「实现」两个独立的层次结构，从而能在开发时分别使用。</p>
</blockquote>
<h3 id="现实问题-5"><a href="#现实问题-5" class="headerlink" title="现实问题"></a>现实问题</h3><p>假如你有一个几何 「形状Shape类」， 从它能扩展出两个子类：  「圆形Cir­cle」 和 「方形Square」。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为「红色Red」和「蓝色Blue」的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如「蓝色圆形Blue­Cir­cle」和「红色方形Red­Square」</p>
<p><img src="/posts/d6bbbb0d/bridge_1.png" alt="bridge_1"></p>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。</p>
<h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个问题主要是由于「形状」以及「颜色」其实是两个维度的问题。但是放在一个形状类中来进行扩展。而这是继承时容易导致的问题。</p>
<p><strong>桥接模式通过将「继承」改为「组合」的方式来解决问题</strong></p>
<p>即抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象从而使得一个类中不必有所有的状态和行为。</p>
<p><img src="/posts/d6bbbb0d/bridge_2.png" alt="bridge_2"></p>
<p>图示中，我们把颜色相关的代码抽取到红色和蓝色的两个子类的颜色中。然后形状类中添加一个只想某一颜色对象的引用成员变量。那么现在形状类可以将所有与颜色有关的行为交给颜色对象，这种引用就是「形状」和「颜色」之间的桥梁。</p>
<h4 id="抽象-和-实现"><a href="#抽象-和-实现" class="headerlink" title="抽象 和 实现"></a>抽象 和 实现</h4><p>抽象部分 - 一般指接口，是一些实体的高阶控制层。该层本身不完成任何「具体」的工作，它需要将工作委派给「实现部分」层</p>
<blockquote>
<p>这里的和语言里面的interface 或者 abstract class 没有关系</p>
</blockquote>
<p>实际程序中抽象部分是图像用户界面（GUI），而实现部分则是底层操作系统代码（API），GUI层调用API层来对用户的各种操作做出回应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用： </p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置） </li>
<li>支持多个不同的 API （例如， 能够在 Win­dows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种 API。</p>
<p><img src="/posts/d6bbbb0d/bridge_3.png" alt="bridge_3"></p>
<p>你可以将特定接口-平台的组合代码抽取到独立的类中， 以在混乱中建立一些秩序。 但是， 你很快会发现这种类的数量很多。 类层次将以指数形式增长， 因为每次添加一个新的 GUI 或支持一种新的 API 都需要创建更多的类。<br>让我们试着用桥接模式来解决这个问题。 该模式建议将类拆分为两个类层次结构： </p>
<p>抽象部分： 程序的 GUI 层。<br>实现部分： 操作系统的 API。 </p>
<p><img src="/posts/d6bbbb0d/bridge_4.png" alt="bridge_4"></p>
<p>抽象对象控制程序的外观， 并将真实工作委派给连入的实现对象。 不同的实现只要遵循相同的接口就可以互换， 使同一GUI 可在 Win­dows 和 Linux 下运行。 </p>
<p>最后的结果是： 你无需改动与 API 相关的类就可以修改 GUI 类。 此外如果想支持一个新的操作系统， 只需在实现部分层次中创建一个子类即可。</p>
<p>例如，在一个软件系统中，如果你有一个功能是需要在不同的操作系统（如Windows和Linux）上运行，并且每个操作系统都有自己的GUI接口。如果你直接在应用程序的主体中写入所有的GUI代码，那么这会导致代码与平台强绑定，难以维护。</p>
<p>为了解决这个问题，你可以将与操作系统相关的GUI部分抽象出来，创建独立的类或者接口来管理这些与平台相关的代码。这样，你的主应用程序就不需要直接处理不同操作系统的GUI细节，而是通过这些抽象的接口来与它们通信。当需要支持新的操作系统时，你只需要添加或修改这些独立的类即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个GUI接口，描述所有操作系统都会实现的GUI操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Windows实现GUI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Linux实现GUI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主应用程序，不直接依赖于任何特定的操作系统GUI实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> {</span><br><span class="line">    <span class="keyword">private</span> GUI gui;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Application</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">this</span>.gui = gui;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        gui.drawButton();</span><br><span class="line">        gui.drawWindow();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，选择适当的GUI实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">GUI</span> <span class="variable">windowsGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsGUI</span>();</span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(windowsGUI);</span><br><span class="line">        app.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要更换到Linux GUI，只需要更换GUI实现</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">linuxGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinuxGUI</span>();</span><br><span class="line">        app = <span class="keyword">new</span> <span class="title class_">Application</span>(linuxGUI);</span><br><span class="line">        app.draw();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/bridge_5.png" alt="bridge_5"></p>
<ol>
<li>抽象部分 （Abstrac­tion） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。 </li>
<li>实现部分 （Imple­men­ta­tion） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。<br>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。 </li>
<li>具体实现 （Con­crete Imple­men­ta­tions） 中包括特定于平台的代码。 </li>
<li>精确抽象 （Refined Abstrac­tion） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。 </li>
<li>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li>
</ol>
<p>从您提供的图片中，我们可以看到桥接模式的结构，它包含以下部分：</p>
<ol>
<li><strong>抽象化 (Abstraction)</strong>: 定义高层的接口，它依赖于实现化角色提供的接口进行工作。这是一个核心的角色，它包含对实现化角色的引用。</li>
<li><strong>实现化 (Implementation)</strong>: 是接口或抽象类，定义了实现化角色必须实现的接口，但不负责具体的实现。</li>
<li><strong>具体实现化 (Concrete Implementations)</strong>: 实现化角色的具体实现，根据实现化接口来提供具体的操作方法。</li>
<li><strong>改进抽象化 (Refined Abstraction)</strong>: 是抽象化的子类，扩展或完善了父类定义的方法和属性。</li>
<li><strong>客户端 (Client)</strong>: 使用抽象化角色定义的接口操作。</li>
</ol>
<p>我们可以将 <code>Application</code> 类看作是<strong>抽象化</strong>角色，<code>GUI</code> 接口是<strong>实现化</strong>角色，而 <code>WindowsGUI</code> 和 <code>LinuxGUI</code> 类是<strong>具体实现化</strong>角色。要更明确地映射到桥接模式，具体来说，我们可以创建一个 <code>RefinedGUI</code> 类，它继承自 <code>GUI</code> 接口并添加一些特定的功能。同时，我们可以创建一个客户端类来直接与 <code>Application</code> 类交互。以下是调整后的代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationGUI</span> {</span><br><span class="line">    <span class="keyword">protected</span> GUI gui;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ApplicationGUI</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">this</span>.gui = gui;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedApplicationGUI</span> <span class="keyword">extends</span> <span class="title class_">ApplicationGUI</span> {</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedApplicationGUI</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">super</span>(gui);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 使用GUI接口提供的方法</span></span><br><span class="line">        gui.drawButton();</span><br><span class="line">        gui.drawWindow();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加一些改进的操作方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawMenu</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用 "</span> + gui.getClass().getSimpleName() + <span class="string">" 绘制菜单"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现化角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 客户端决定使用的具体实现化角色</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">windowsGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsGUI</span>();</span><br><span class="line">        <span class="type">ApplicationGUI</span> <span class="variable">appGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefinedApplicationGUI</span>(windowsGUI);</span><br><span class="line">        appGUI.draw();</span><br><span class="line">        appGUI.drawMenu();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以轻松切换到Linux GUI</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">linuxGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinuxGUI</span>();</span><br><span class="line">        appGUI = <span class="keyword">new</span> <span class="title class_">RefinedApplicationGUI</span>(linuxGUI);</span><br><span class="line">        appGUI.draw();</span><br><span class="line">        appGUI.drawMenu();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个调整后的示例中，<code>RefinedApplicationGUI</code> 是一个改进的抽象化角色，它扩展了 <code>ApplicationGUI</code> 抽象化角色的功能。<code>Client</code> 类则充当了客户端角色，它决定使用哪个具体实现化角色，并通过改进的抽象化角色来使用这些功能。这样的结构更清晰地展现了桥接模式的所有组成部分。</p>
<h3 id="代码样例-1"><a href="#代码样例-1" class="headerlink" title="代码样例"></a>代码样例</h3><p><img src="/posts/d6bbbb0d/bridge_6.png" alt="bridge_6"></p>
<p>「设备Device类」作为实现部分， 而「遥控器Remote类」则作为抽象部分。</p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。<br>我们可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。<br>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//&nbsp;“抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span><br><span class="line">//&nbsp;现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span><br><span class="line">class&nbsp;RemoteControl&nbsp;is</span><br><span class="line">&nbsp;&nbsp;protected&nbsp;field device:&nbsp;Device</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;RemoteControl(device:&nbsp;Device)&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;this.device&nbsp;=&nbsp;device</span><br><span class="line">&nbsp;&nbsp;method&nbsp;togglePower()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(device.isEnabled())&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device.disable()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;else</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device.enable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;volumeDown()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(device.getVolume()&nbsp;-&nbsp;10)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;volumeUp()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(device.getVolume()&nbsp;+&nbsp;10)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;channelDown()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setChannel(device.getChannel()&nbsp;-&nbsp;1)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;channelUp()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setChannel(device.getChannel()&nbsp;+&nbsp;1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;你可以独立于设备类的方式从抽象层中扩展类。</span><br><span class="line">class&nbsp;AdvancedRemoteControl&nbsp;extends&nbsp;RemoteControl&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;mute()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;“实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span><br><span class="line">//&nbsp;匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span><br><span class="line">//&nbsp;抽象接口则会基于这些操作定义较高层次的操作。</span><br><span class="line">interface&nbsp;Device&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;isEnabled()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;enable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;disable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;getVolume()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;setVolume(percent)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;getChannel()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;setChannel(channel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;所有设备都遵循相同的接口。</span><br><span class="line">class&nbsp;Tv&nbsp;implements&nbsp;Device&nbsp;is</span><br><span class="line">&nbsp;&nbsp;//&nbsp;...</span><br><span class="line"></span><br><span class="line">class&nbsp;Radio&nbsp;implements&nbsp;Device&nbsp;is</span><br><span class="line">	// ...</span><br><span class="line">//&nbsp;客户端代码中的某个位置。</span><br><span class="line">tv&nbsp;=&nbsp;new&nbsp;Tv()</span><br><span class="line">remote&nbsp;=&nbsp;new&nbsp;RemoteControl(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio&nbsp;=&nbsp;new&nbsp;Radio()</span><br><span class="line">remote&nbsp;=&nbsp;new&nbsp;AdvancedRemoteControl(radio)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<ul>
<li>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</li>
<li>桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</li>
</ul>
</li>
<li><p>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p>
<ul>
<li>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</li>
</ul>
</li>
<li><p>如果你需要在运行时切换不同实现方法， 可使用桥接模式。 </p>
<ul>
<li>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</li>
</ul>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。 </li>
<li>了解客户端的业务需求， 并在抽象基类中定义它们。 </li>
<li>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。 </li>
<li>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。 </li>
<li>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。 </li>
<li>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。 </li>
<li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</li>
</ol>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。 </li>
<li>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。 </li>
<li>将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
</ul>
<p>假设我们有一个应用程序，它可以在不同的数据库上运行。我们的抽象部分是数据库的使用，而具体实现是对各种数据库的操作。</p>
<p>首先，我们定义一个数据库操作的桥接接口（<code>Database</code>）和它的一些实现（<code>MySQLDatabase</code>, <code>PostgreSQLDatabase</code>）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥接接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDatabase</span> <span class="keyword">implements</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"连接到MySQL数据库"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span> {</span><br><span class="line">        System.out.println(<span class="string">"在MySQL执行: "</span> + query);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现PostgreSQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLDatabase</span> <span class="keyword">implements</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"连接到PostgreSQL数据库"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span> {</span><br><span class="line">        System.out.println(<span class="string">"在PostgreSQL执行: "</span> + query);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们使用抽象工厂模式来封装数据库的创建过程，以便为客户端代码隐藏复杂性：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    <span class="keyword">abstract</span> Database <span class="title function_">createDatabase</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDatabaseFactory</span> <span class="keyword">extends</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    Database <span class="title function_">createDatabase</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLDatabase</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂PostgreSQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLDatabaseFactory</span> <span class="keyword">extends</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    Database <span class="title function_">createDatabase</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PostgreSQLDatabase</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(DatabaseFactory factory)</span> {</span><br><span class="line">        database = factory.createDatabase();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        database.connect();</span><br><span class="line">        database.execute(<span class="string">"SELECT * FROM table"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在客户端代码中，我们不直接与具体的数据库实现打交道，而是通过抽象工厂提供的接口来创建和使用数据库。</p>
<ul>
<li>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</li>
</ul>
<p>假设我们正在构建一个报告生成系统，其中报告的内容（抽象部分）可以独立于报告的格式（具体实现部分）。</p>
<p>首先，我们定义一个报告的桥接接口（<code>Report</code>）和它的一些实现（<code>PDFReport</code>, <code>HTMLReport</code>）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥接接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现PDF</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDFReport</span> <span class="keyword">implements</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"生成PDF报告"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现HTML</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLReport</span> <span class="keyword">implements</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"生成HTML报告"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们使用生成器模式来封装报告的构建过程：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报告生成器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    <span class="keyword">protected</span> Report report;</span><br><span class="line"></span><br><span class="line">    ReportBuilder <span class="title function_">buildPartA</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 构建报告的一部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ReportBuilder <span class="title function_">buildPartB</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 构建报告的另一部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Report <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器PDF</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDFReportBuilder</span> <span class="keyword">extends</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    PDFReportBuilder() {</span><br><span class="line">        report = <span class="keyword">new</span> <span class="title class_">PDFReport</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Report <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> report;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器HTML</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLReportBuilder</span> <span class="keyword">extends</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    HTMLReportBuilder() {</span><br><span class="line">        report = <span class="keyword">new</span> <span class="title class_">HTMLReport</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Report <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> report;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主管类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReportDirector</span> {</span><br><span class="line">    <span class="keyword">private</span> ReportBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReportDirector</span><span class="params">(ReportBuilder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Report <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> builder.buildPartA().buildPartB().build();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReportBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PDFReportBuilder</span>();</span><br><span class="line">        <span class="type">ReportDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReportDirector</span>(builder);</span><br><span class="line">        <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        report.generate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>ReportBuilder</code> 是桥接模式的一个组成部分，它将报告的创建过程从具体的报告格式中抽象出来。<code>ReportDirector</code> 作为主管类，负责根据客户端的需求使用不同的生成器构建报告。这种方式允许我们独立于报告的具体实现来构建报告的内容。</p>
<h2 id="组合-对象树-Object-Tree-Composite"><a href="#组合-对象树-Object-Tree-Composite" class="headerlink" title="组合 - 对象树, Object Tree, Composite"></a>组合 - 对象树, Object Tree, Composite</h2><blockquote>
<p>将对象组合成树状结构，并且像独立使用对立对象一样使用</p>
</blockquote>
<h3 id="现实问题-6"><a href="#现实问题-6" class="headerlink" title="现实问题"></a>现实问题</h3><p>如果应用的核心模型可以用树状结构表示，在应用中使用组合模式才有价值</p>
<p>主要是一些层级结构：产品和盒子，比如一个盒子可以包含多个产品或者几个较小的盒子。小盒子里又有一些其他的产品或者更小的盒子</p>
<p>我们现在开发一个订购系统。订单中可以包含无包装的简单产品，也可以包含装满产品的盒子。那么此时应该如何计算总价格就成了问题，一个简单的方法就是一直递归到最底层然后计算总价。</p>
<h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来 「产品」 和「盒子」进行交互，并且在该接口中declare一个计算总价的方法</p>
<p>具体的，设计方法时候，对于产品，我们直接返回价格。对于盒子方法就会看盒子中间的所有内容，询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="/posts/d6bbbb0d/composite_1.png" alt="composite_1"></p>
<p>通过使用这种方式，我们不需要知道树里面对象的具体类。只需要使用通用接口来进行相同的处理，化繁为简。</p>
<p>一个其他的例子包含：</p>
<p>大部分国家的军队都采用层次管理，军师旅团营连排</p>
<h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/d6bbbb0d/composite_2.png" alt="composite_2"></p>
<ol>
<li><p>组件 （Com­po­nent） 接口描述了树中简单项目和复杂项目所共有的操作。 </p>
</li>
<li><p>叶节点 （Leaf） 是树的基本结构， 它不包含子项目。<br>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。 </p>
</li>
<li><p>容器 （Con­tain­er）——又名 “组合 （Com­pos­ite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。 </p>
<p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。 </p>
</li>
<li><p>客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p>
</li>
</ol>
<p>这里的 <code>add</code> <code>remove</code> <code>getChildren</code>就是comosite作用于自身field的方法，即比如加入/去掉元素到<code>Component[]</code>或者 返回 整个<code>Component[]</code></p>
<h3 id="代码样例-2"><a href="#代码样例-2" class="headerlink" title="代码样例"></a>代码样例</h3><p><img src="/posts/d6bbbb0d/composite_3.png" alt="composite_3"></p>
<p>组合图形 == 容器（组合）它由多个包含容器在内的字图形构成。它们有相同的方比如「move」「draw」但是组合图形本身不完成具体工作。而是一直将请求递归传递给子项目，汇总结果</p>
<p>通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;组件接口会声明组合中简单和复杂对象的通用操作。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象</span></span><br><span class="line"><span class="comment">//&nbsp;通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Dot</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field x,&nbsp;y</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Dot</span><span class="params">(x,&nbsp;y)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.x&nbsp;+=&nbsp;x,&nbsp;<span class="built_in">this</span>.y&nbsp;+=&nbsp;y</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在坐标位置(X,Y)处绘制一个点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;所有组件类都可以扩展其他组件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Circle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dot</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field radius</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Circle</span><span class="params">(x,&nbsp;y,&nbsp;radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在坐标位置(X,Y)处绘制一个半径为&nbsp;R&nbsp;的圆。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项</span></span><br><span class="line"><span class="comment">//&nbsp;目，然后“汇总”结果。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CompoundGraphic</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field children:&nbsp;array&nbsp;of&nbsp;Graphic</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">add</span><span class="params">(child:&nbsp;Graphic)</span>&nbsp;is</span><br><span class="line">    <span class="comment">//&nbsp;在子项目数组中添加一个子项目。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">remove</span><span class="params">(child:&nbsp;Graphic)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;从子项目数组中移除一个子项目。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">foreach</span>&nbsp;<span class="params">(child&nbsp;in&nbsp;children)</span>&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.move(x,&nbsp;y)</span><br><span class="line">  <span class="comment">//&nbsp;组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;最后组合将会完成整个对象树的遍历工作。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;1.&nbsp;对于每个子部件：</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;绘制该部件。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;更新边框坐标。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;2.&nbsp;根据边框坐标绘制一个虚线长方形。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同</span></span><br><span class="line"><span class="comment">//&nbsp;时支持简单叶节点组件和复杂组件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">ImageEditor</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field all:&nbsp;CompoundGraphic</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">load</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">all</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CompoundGraphic</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;all.add(<span class="keyword">new</span>&nbsp;“<span class="keyword">new</span>&nbsp;<span class="title class_">Dot</span>(<span class="number">1</span>,&nbsp;<span class="number">2</span>))</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;all.add(<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>(<span class="number">5</span>,&nbsp;<span class="number">3</span>,&nbsp;<span class="number">10</span>))</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;将所需组件组合为复杂的组合组件。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">groupSelected</span><span class="params">(components:&nbsp;array&nbsp;of&nbsp;Graphic)</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">group</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CompoundGraphic</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(component&nbsp;in&nbsp;components)&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.add(component)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all.remove(component)</span><br><span class="line">    all.add(group)</span><br><span class="line">    <span class="comment">//&nbsp;所有组件都将被绘制。</span></span><br><span class="line">    all.draw()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>树状对象结构，考虑使用组合模式<ul>
<li>组合模式有两种共享公共接口的基本元素类型：简单叶子结点和复杂组合容器。容器可以包含其他叶子结点或容器。从而组成树状嵌套递归对象结构</li>
</ul>
</li>
<li>客户端代码想要用相同方式处理简单和复杂元素，考虑使用组合模式<ul>
<li>所有元素公用同一个接口。在这个借口的帮助下客户端不需要在意所用的对象的具体类</li>
</ul>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。 </li>
<li>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。 </li>
<li>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。 </li>
<li>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为<strong>组合接口类型</strong>。<br>实现组件接口方法时， 记住容器应该将<strong>大部分工作交给其子元素来完成。</strong> </li>
<li>最后， 在容器中定义添加和删除子元素的方法。<br>记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>充分利用多态和递归</li>
<li>开闭原则，无需更改已有代码，在应用中添加新元素，使其成为对象树的一部分</li>
<li>缺点：对于功能差异比较的，找公共接口会很复杂</li>
</ul>
<h3 id="和其他模式的关系"><a href="#和其他模式的关系" class="headerlink" title="和其他模式的关系"></a>和其他模式的关系</h3><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。 </p>
<h4 id="Builder-Composite"><a href="#Builder-Composite" class="headerlink" title="Builder + Composite"></a>Builder + Composite</h4><p>你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。 </p>
<p>为了更好地体现“在创建复杂组合树时使用生成器，因为这可使其构造步骤以递归的方式运行”的思想，我们可以构建一个更为复杂的例子，比如一个公司组织结构的树形表示，其中包含多个层级的部门和员工。我们将使用组合模式来表示组织结构的层次，同时使用生成器模式来递归地构建这个结构。这个例子中，我们将特别注意在代码中添加注释，以解释关键步骤和设计选择。</p>
<p>组合模式部分</p>
<p>首先，我们定义组合模式相关的类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组织结构的组件接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点：表示一个员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String position)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(position + <span class="string">": "</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点：表示一个部门，可以包含其他部门或员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">implements</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrganizationComponent&gt; members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成员，可以是部门或员工</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMember</span><span class="params">(OrganizationComponent member)</span> {</span><br><span class="line">        members.add(member);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Department: "</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent member : members) {</span><br><span class="line">            member.printStructure();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生成器模式部分</p>
<p>接下来，我们定义生成器模式相关的类，以支持递归地构建组织结构：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组织结构的生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrganizationBuilder</span> {</span><br><span class="line">    <span class="keyword">private</span> Department root;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Department&gt; departmentStack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationBuilder</span><span class="params">(String rootName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Department</span>(rootName);</span><br><span class="line">        departmentStack.push(root); <span class="comment">// 将根部门压栈作为当前操作的部门</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个部门，新部门自动成为当前操作的部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">addDepartment</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="type">Department</span> <span class="variable">newDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(name);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">current</span> <span class="operator">=</span> departmentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) {</span><br><span class="line">            current.addMember(newDepartment);</span><br><span class="line">            departmentStack.push(newDepartment); <span class="comment">// 将新部门压栈</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个员工到当前操作的部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">addEmployee</span><span class="params">(String name, String position)</span> {</span><br><span class="line">        <span class="type">Department</span> <span class="variable">current</span> <span class="operator">=</span> departmentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) {</span><br><span class="line">            current.addMember(<span class="keyword">new</span> <span class="title class_">Employee</span>(name, position));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前部门的构建，返回上一级部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">endDepartment</span><span class="params">()</span> {</span><br><span class="line">        departmentStack.pop(); <span class="comment">// 结束当前部门的构建，弹出栈顶部门</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最终的组织结构，返回根部门</span></span><br><span class="line">    <span class="keyword">public</span> Department <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例使用</p>
<p>最后，我们使用这些类来构建一个示例公司的组织结构：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeBuilderDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 使用生成器递归构建组织结构</span></span><br><span class="line">        <span class="type">OrganizationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrganizationBuilder</span>(<span class="string">"Head Office"</span>)</span><br><span class="line">                .addDepartment(<span class="string">"R&amp;D"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Alice"</span>, <span class="string">"Engineer"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Bob"</span>, <span class="string">"Engineer"</span>)</span><br><span class="line">                    .endDepartment()</span><br><span class="line">                .addDepartment(<span class="string">"HR"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Charlie"</span>, <span class="string">"Recruiter"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Dana"</span>, <span class="string">"Coordinator"</span>)</span><br><span class="line">                    .endDepartment();</span><br><span class="line"></span><br><span class="line">        <span class="type">Department</span> <span class="variable">company</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        company.printStructure(); <span class="comment">// 打印整个组织结构</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，我们首先创建了一个<code>OrganizationBuilder</code>实例，指定了公司的根部门名为”Head Office”。然后，我们递归地添加了两个部门”R&amp;D”和”HR”，以及它们各自的员工。<code>addDepartment</code>方法让我们可以添加一个新的部门，并自动将其设置为当前操作的部门，这支持了递归地构建部门结构。通过调用<code>endDepartment</code>方法，我们结束当前部门的构建，并回到上一级部门。最后，我们通过调用<code>build</code>方法完成整个组织结构的构建，并打印出来。</p>
<p>这个例子展示了如何结合使用组合模式和生成器模式来递归地构建和管理一个复杂的树形结构，同时保持代码的清晰和可维护性。</p>
<p>责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。 </p>
<p>你可以使用迭代器来遍历组合树。 </p>
<p>你可以使用访问者对整个组合树执行操作。 </p>
<p>你可以使用享元实现组合树的共享叶节点以节省内存。 </p>
<p>组合和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。<br>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。<br>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。 </p>
<p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
<h2 id="装饰-装饰者，装饰器，Decorator-Wrapper"><a href="#装饰-装饰者，装饰器，Decorator-Wrapper" class="headerlink" title="装饰 - 装饰者，装饰器，Decorator, Wrapper"></a>装饰 - 装饰者，装饰器，Decorator, Wrapper</h2><blockquote>
<p>装饰模式允许我们通过将对象放入包含行为的特殊服装对象中来为原对象绑定新行为</p>
</blockquote>
<p><img src="/posts/d6bbbb0d/decorator-2x.png" alt="decorator-2x"></p>
<h3 id="现实问题-7"><a href="#现实问题-7" class="headerlink" title="现实问题"></a>现实问题</h3><p>假设正在开发一个提供通知功能的库，其他程序使用它向用户发送关于重要事件的通知</p>
<p>库最初版本基于「通知器 Notifier」类，此时只有很少几个成员变量，一个构造函数以及一个「send」方法。这个方法可以接受来自客户端的消息作为参数。并将信息发送一个订阅邮箱。邮箱列表通过构造函数传递给通知器。创建和配置通知器仅被调用一次，然后发送给对应的邮箱当重要事情发生时</p>
<p>为了构建一个提供通知功能的库的最初版本，我们首先定义一个简单的<code>Notifier</code>类。这个类将包含一个用于存储订阅邮箱列表的成员变量，一个构造函数来初始化这个列表，以及一个<code>send</code>方法用于将消息发送给所有订阅的邮箱。这里是一个简单的Java实现示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notifier</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; emailList; <span class="comment">// 存储订阅邮箱列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，通过它传递邮箱列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Notifier</span><span class="params">(List&lt;String&gt; emailList)</span> {</span><br><span class="line">        <span class="built_in">this</span>.emailList = emailList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到所有订阅的邮箱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">for</span> (String email : emailList) {</span><br><span class="line">            <span class="comment">// 模拟发送消息过程</span></span><br><span class="line">            System.out.println(<span class="string">"Sending message to "</span> + email + <span class="string">": "</span> + message);</span><br><span class="line">            <span class="comment">// 实际应用中，这里会有发送邮件的逻辑</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>Notifier</code>类定义了基础的通知功能。构造函数<code>Notifier(List&lt;String&gt; emailList)</code>接受一个包含邮箱地址的列表，这些邮箱是消息的目标接收者。<code>send(String message)</code>方法遍历这个列表，并为每个邮箱打印一条消息，代表发送过程。在实际应用中，这里会包含实际发送邮件的代码逻辑。</p>
<p>使用这个类的示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 初始化订阅邮箱列表</span></span><br><span class="line">        List&lt;String&gt; emails = Arrays.asList(<span class="string">"user1@example.com"</span>, <span class="string">"user2@example.com"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建通知器实例</span></span><br><span class="line">        <span class="type">Notifier</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notifier</span>(emails);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送通知消息</span></span><br><span class="line">        notifier.send(<span class="string">"Hello, this is an important notification message!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个示例中，我们首先创建了一个包含两个邮箱地址的列表。然后，我们使用这个列表创建了一个<code>Notifier</code>实例。通过调用<code>send</code>方法，我们向所有订阅的邮箱发送了一个消息。</p>
<p>这个简单的实现展示了通知库最初版本的核心功能。在这个阶段，我们没有考虑使用装饰器模式来扩展功能，而是专注于实现基本的通知发送功能。之后，可以通过装饰器模式添加额外的功能，如日志记录、消息加密、错误处理等，而不影响现有的<code>Notifier</code>类。</p>
<p>然后未来我们发现我们不单单需要邮箱通知，我们还希望有手机短信通知，微信通知，QQ通知等等</p>
<p><img src="/posts/d6bbbb0d/decorator_1.png" alt="decorator_1"></p>
<p>这里的挑战是，客户端需要传入类型，通过类型来调用对应的发送方法。</p>
<p>而且如果我们需要组合一起的时候，比如腾讯用户，那么我们需要wechat 和 QQ，比如信息用户，SMS + Wechat 等等，此时就会发生子类梯度爆炸</p>
<p><img src="/posts/d6bbbb0d/decorator_2.png" alt="decorator_2"></p>
<h3 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果对每一个需要扩展的功能都是使用继承然后扩展一个子类那么很容易就会出现由于继承导致的子类数量爆炸的问题</p>
<p>我们可以使用组合：</p>
<p>两者的工作方式几乎一模一样： 一个对象包含指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为， 它们自己能够完成这些工作。</p>
<p>组合是许多设计模式背后的关键原则</p>
<p><img src="/posts/d6bbbb0d/decorator_3.png" alt="decorator_3"></p>
<p>对于装饰模式，又称其为封装器模式。封装器是一个能与其他目标对象链接的对象。封装器包含与目标对象相同的一系列方法，他会<strong>把所有接收到的请求委派给目标对象</strong>。但是封装器也可以再把请求交给目标对象前后进行处理。</p>
<p>封装器需要实现和其封装对象相同的接口，我们可以将一个对象放入多个封装器中，并在对象中添加封装器的组合行为</p>
<p>在之前的例子中，我们可以将邮件通知这个default行为放在基类<code>Notifier</code>中然后把其他通知方法放在装饰器中</p>
<p><img src="/posts/d6bbbb0d/decorator_4.png" alt="decorator_4"></p>
<p>对于上述问题的客户端代码来说把</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="post-meta__tags" href="/tags/Design-Pattern/">Design Pattern</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/10a61f34.html" title="Trie树"><img class="cover" src="/posts/10a61f34.htmlTrie_Cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Trie树</div></div></a></div><div class="next-post pull-right"><a href="/posts/f5914f50.html" title="八股文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">八股文</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ruobing Wang</div><div class="author-info__description">Work Hard, Play Harder</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ruobing1997"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ruobing1997" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/robin97/" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://www.instagram.com/ruobingwang123/" target="_blank" title="Instagram"><i class="fab fa-instagram"></i></a><a class="social-icon" href="mailto:ruobing2@andrew.cmu.edu" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">设计模式分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Creational-Pattern"><span class="toc-number">2.</span> <span class="toc-text">Creational Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-Factory-Method"><span class="toc-number">2.1.</span> <span class="toc-text">工厂方法 - Factory Method</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.6.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-Abstract-Factory"><span class="toc-number">2.2.</span> <span class="toc-text">抽象工厂方法 - Abstract Factory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.2.6.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.7.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Builder"><span class="toc-number">2.3.</span> <span class="toc-text">生成器 - Builder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%AE%A1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">主管</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">2.3.4.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.3.5.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.6.</span> <span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-Clone-Prototype"><span class="toc-number">2.4.</span> <span class="toc-text">原型 - Clone, Prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">原型注册表实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">2.4.4.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.4.5.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.4.6.</span> <span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton"><span class="toc-number">2.5.</span> <span class="toc-text">单例模式 - Singleton</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%B1%BB%E6%AF%94"><span class="toc-number">2.5.3.</span> <span class="toc-text">真实世界类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-4"><span class="toc-number">2.5.4.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B"><span class="toc-number">2.5.5.</span> <span class="toc-text">代码样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">2.5.6.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">2.5.7.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.8.</span> <span class="toc-text">与其他模式的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">创建型设计模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.0.0.1.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.0.0.2.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.0.0.3.</span> <span class="toc-text">核心区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.6.0.0.4.</span> <span class="toc-text">不使用原型模式的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.6.0.0.5.</span> <span class="toc-text">使用原型模式的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-2"><span class="toc-number">2.6.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">与其他模式的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5-Bridge"><span class="toc-number">2.7.</span> <span class="toc-text">桥接 - Bridge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-5"><span class="toc-number">2.7.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5"><span class="toc-number">2.7.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-%E5%92%8C-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">抽象 和 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-5"><span class="toc-number">2.7.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">2.7.4.</span> <span class="toc-text">代码样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.5.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-3"><span class="toc-number">2.7.6.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-2"><span class="toc-number">2.7.7.</span> <span class="toc-text">与其他模式的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E5%AF%B9%E8%B1%A1%E6%A0%91-Object-Tree-Composite"><span class="toc-number">2.8.</span> <span class="toc-text">组合 - 对象树, Object Tree, Composite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-6"><span class="toc-number">2.8.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-6"><span class="toc-number">2.8.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-6"><span class="toc-number">2.8.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">2.8.4.</span> <span class="toc-text">代码样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.8.5.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-4"><span class="toc-number">2.8.6.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.8.7.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.8.8.</span> <span class="toc-text">和其他模式的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Builder-Composite"><span class="toc-number">2.8.8.1.</span> <span class="toc-text">Builder + Composite</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0-%E8%A3%85%E9%A5%B0%E8%80%85%EF%BC%8C%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%8CDecorator-Wrapper"><span class="toc-number">2.9.</span> <span class="toc-text">装饰 - 装饰者，装饰器，Decorator, Wrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E9%97%AE%E9%A2%98-7"><span class="toc-number">2.9.1.</span> <span class="toc-text">现实问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-7"><span class="toc-number">2.9.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/8d46c231.html" title="队列和栈"><img src="/posts/8d46c231.html%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88_Cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="队列和栈"/></a><div class="content"><a class="title" href="/posts/8d46c231.html" title="队列和栈">队列和栈</a><time datetime="2024-05-15T04:17:52.593Z" title="Updated 2024-05-15 00:17:52">2024-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a0ebfa60.html" title="面试经验集合"><img src="/posts/a0ebfa60.htmlinterview_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经验集合"/></a><div class="content"><a class="title" href="/posts/a0ebfa60.html" title="面试经验集合">面试经验集合</a><time datetime="2024-05-15T04:17:52.593Z" title="Updated 2024-05-15 00:17:52">2024-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ruobing Wang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script async src="/config/js/categoryBar.js"></script><script src="/js/nav.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>