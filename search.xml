<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>闫氏DP分析法</title>
      <link href="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>思考方式</h1><p>拿到问题 可以分成 <code>状态表示</code> + <code>状态计算</code></p><p>计算复杂度： 状态数量（多少个状态） X 状态转移方程计算量</p><p><strong>状态表示：</strong></p><p>状态表示 f(i,j) -&gt; 集合 和 属性</p><p>集合指的是 f(i,j) 定义条件下的一种类型集合</p><p>属性一般有三种 Max, Min, 方案数</p><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/dp_0.png" alt="dp_0"></p><p>举个例子对于 01 背包问题来说</p><p>「f(i,j) 就指 对于前 i 个物品（条件一），满足容量小于等于j的（条件二）取法集合」<code>集合</code> 「集合中价值最大」(<code>属性：Max</code>)</p><p><strong>状态计算</strong>:</p><p>状态怎么被计算出也就是集合是如何划分的，比如当前集合如何划分为若干个更小的子集，子集可以被前面更小的算出来，子集划分一般遵循<strong>不重不漏</strong>，但是比如如果求最大值最小值，那么就可以重复，但是求方案书就不能够重复</p><p>对于01背包问题来说，集合可以被划分为包含i，或者不包含i</p><h1>背包问题</h1><p>背包问题都是说在</p><p>N 个物品，每个物品体积Vi, 价值 Wi</p><p>容积为 V 的背包</p><p>目标是让选择的物品总价值<strong>最大</strong>求<strong>最大值</strong></p><p>**01 背包：**每个物品「<strong>至多</strong>」选择一次</p><p>**完全背包：<strong>每个物品</strong>「无数」**次选择</p><p>**多重背包：**每个物品有 <strong>「Xi」</strong> 个</p><p><strong>分组背包：<strong>有</strong>N</strong>组，每个组有若干个物品，每组只能选<strong>1</strong>个</p><h2 id="01背包">01背包</h2><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/01_0.png" alt="01_0"></p><h3 id="一维优化：">一维优化：</h3><p>能一维优化的原因在于我们当前结果只和i - 1有关，所以在刚要更新的时候当前数组中的值就已经是上一次的值所以无需二维</p><p>但是主要讨论下为什么需要倒序，j为什么从m倒退到v[i]</p><blockquote><p><a href="https://blog.csdn.net/qq_52416556/article/details/124486448?spm=1001.2014.3001.5501">CSDN blog</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= v[i]; j--) {</span><br><span class="line">        f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设有3件物品，背包的总体积为10<br>物品       体积      价值<br>i = 1         4           5<br>i = 2         5           6<br>i = 3         6           7<br>如果 <code>f[0][j]</code> 总共0件物品，所以最大价值为 0， 即 <code>f[0][j] == 0 </code>也是成立的<br>如果 j 层循环是递增的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) { </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v[i]; j &lt;= m; j++) {</span><br><span class="line">        f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当还未进入循环时(初始状态):<br>f[0] = 0;  f[1] = 0;  f[2] = 0;  f[3] = 0;  f[4] = 0;<br>f[5] = 0;  f[6] = 0;  f[7] = 0;  f[8] = 0;  f[9] = 0; f[10] = 0;<br>当进入循环 i == 1 时：<br>f[4] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5;<br>f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5;<br>f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5;<br>f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5;</p><p>重点来了！！！<br>f[8] = max(f[8], f[4] + 5); 即max(0, 5 + 5) = 10; 即f[8] = 10;<br>这里就已经出错了</p><p>因为此时处于 i == 1 这一层，<strong>即物品只有一件，不存在单件物品满足价值为10</strong><br>所以已经出错了。这也是为什么<strong>完全背包可以正序，因为它的物品个数是无限</strong></p><p>这里是因为在f[8]时候会再一次选用f[4]的结果而f[4]已经用过了不能再用了，（01背包定义）</p><p>所以需要从m开始到v[i]以防之前的数被计算过从而导致后面的结果被污染</p><h2 id="完全背包">完全背包</h2><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/wanquan_0.png" alt="wanquan_0"></p><p>状态优化：<br><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/wanquan_1.png" alt="wanquan_1"></p><h2 id="多重背包">多重背包</h2><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/duochong_0.png" alt="duochong_0"></p><h4 id="二进制优化">二进制优化</h4><p>（确实不是很懂，主要是为什么分组之后变成选和不选的合理性在哪里？需要做题手推一下）</p><h2 id="分组背包">分组背包</h2><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/fenzu_0.png" alt="fenzu_0"></p><h1>线性dp</h1><p>线性dp一般指递推的顺序是线性的，比如从左到右。但是定义不重要</p><h2 id="Acwing-889-数字三角形"><a href="https://www.acwing.com/problem/content/900/">Acwing - 889 - 数字三角形</a></h2><blockquote><p>注：图中状态计算有误应该是左上和右上</p></blockquote><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/shuzisanjiao0.png" alt="shuzisanjiao0"></p><h2 id="最长上升子序列"><a href="https://www.acwing.com/problem/content/897/">最长上升子序列</a></h2><p>这里的状态计算中指的是当前数的上一个数，比如当前数如果是idx = i 那么上一个是可以是 0(当前数是第一个数，前面一个数不存在), a0, a1, a2, … ai - 1</p><p>需要满足 ai - 1 &lt; ai</p><p>所以转移方程就是</p><p>ai = Max(f[j] + 1), aj &lt; ai, j = 0 … i - 1</p><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/shangshengzixulie_0.png" alt="shangshengzixulie_0"></p><h2 id="最长公共子序列">最长公共子序列</h2><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/gonggongzixulie_0.png" alt="gonggongzixulie_0"></p><h2 id="编辑距离">编辑距离</h2><h1>区间DP</h1><p>指的是在定义状态时定义了一个区间即状态表示指的是一个区间</p><h2 id="石子合并">石子合并</h2><p>这里状态是指分割点，因为最后一次一定是<code>将两堆合并成一堆</code>所以<code>f[i, j]</code>就可以由，左边1，2，3，…，k-2，k-1个 右边 k- 1, k-2, k-3，…， 2，1个两堆组成</p><p><img src="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/shizihebing_0.png" alt="shizihebing_0"></p><p>假设最后一步合并剩下：</p><p>左边 [i, k] 右边 [k + 1, j] 两堆</p><p>那么这时候的最小代价 Min 属性就是</p><p>组成左边一堆石子i, k的合并方式的最小代价 - Min(f[i, k])</p><p>组成右边边一堆石子i, k的合并方式的最小代价 - Min(f[k + 1, j])</p><p>组成当前堆 [i, j] 堆石子的代价 - 区间[i, j]的代价 （可以使用前缀和公式得出前缀和s[j] - s[i - 1]从而快速获取其代价）</p><p>综上：f[i, j] = Min(f[i, k] + f[k + 1, j] + s[j] - s[i - 1]) where k = i ~ j - 1因为这里我们需要保留右边有至少一堆</p><blockquote><p>注：区间dp问题需要注意状态的顺序，看代码之后的总结：</p></blockquote><p>所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= n; len++) {         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) { <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j; k++) {        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math</title>
      <link href="/posts/Math/"/>
      <url>/posts/Math/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">2834. 找出美丽数组的最小和</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumPossibleSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> target / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m) {</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)(((<span class="type">long</span>)<span class="number">1</span> + n) * n / <span class="number">2</span> % MOD);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">long</span> <span class="variable">firstPart</span> <span class="operator">=</span> (((<span class="type">long</span>)(<span class="number">1</span> + m) * m) / <span class="number">2</span> % MOD);</span><br><span class="line">            <span class="type">long</span> <span class="variable">secondPart</span> <span class="operator">=</span> (((((<span class="type">long</span>) target + target + (n - m) - <span class="number">1</span>) * (n - m)) / <span class="number">2</span>) % MOD);</span><br><span class="line">            <span class="comment">// System.out.println(firstPart + " " + secondPart);</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)((<span class="type">long</span>)(firstPart + secondPart) % MOD);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Quote:  <a href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">lc-2834</a></p></blockquote><p>复习一下等差数列的求和公式：一个等差数列的和，等于其首项与末项的和，乘以项数除以2。所以从 1 一直加到 n 的和就是 <code>(n + 1) * n / 2</code>。</p><p>题目的基本思想是，如果 target = 7, n = 3，那么最优解就是取从 1 到 <code>7 // 2 = 3</code>：<code>[1, 2, 3]</code>，这样的和最小，所以就是取从 1 到 n 的 n 个数，和为 <code>(n + 1) * n / 2</code>。</p><p>但也有复杂情况，那就是如果 <code>n &gt; target // 2</code>，例如 target = 7, n = 6，那么这时 <code>[1, 2, 3]</code> 后面如果继续添加元素 <code>4</code>，就会出现 <code>3 + 4 = 7</code>，违反了元素和不能等于 target 的要求，所以下一个元素只能从 <code>target = 7</code> 开始取，才能确保元素和不为 target。也就是需要在 target 起取 <code>n - target//2</code> 个数，最后的数组为 <code>[1 .. target//2] + [target .. target//2 + n]</code>，直接计算和即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Blind-Sheet</title>
      <link href="/posts/Blind-Sheet/"/>
      <url>/posts/Blind-Sheet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>❓ -&gt; 虽然做出了但有更妙的解法</p></blockquote><h1>Array</h1><p><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a> [❌]</p><p>这道题主要是两个考点</p><ol><li><p>分类讨论：</p><p>设newInterval 为 [L,R]</p><p>Intervals[i] 为 [cL, cR]</p><p>完全不重叠的情况：</p><p>cR &lt; L 即 intervals[i] 在 [L,R]<code>左方</code></p><p>R &lt; cL 即 intervals[i] 在 [L,R]<code>右方</code></p><p>那么其他的情况即为可能出现重叠的情况</p></li><li><p>什么时候加入答案</p><p>如果每次更新都加入答案就会重复加入，因此我们只需要在碰到不重叠的时候加入一次即可。</p><p>由于按照左端点排序，因此第一个不重叠的位置就是R &lt; cL</p></li><li><p>最后对于空数组的处理我们可以用一个flag，如果更新过的答案之前加入过，那么就可以跳过。如果没有加入过说明是第一次加入，那么就加入答案数组，避免数组为空</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLeft</span> <span class="operator">=</span> newInterval[<span class="number">0</span>], newRight = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">insearted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; cur &lt; length; cur++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curLeft</span> <span class="operator">=</span> intervals[cur][<span class="number">0</span>], curRight = intervals[cur][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (curLeft &gt; newRight) {</span><br><span class="line">                <span class="keyword">if</span> (!insearted) {</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {newLeft, newRight});</span><br><span class="line">                    insearted = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{curLeft, curRight});</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (curRight &lt; newLeft) {</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{curLeft, curRight});</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                newLeft = Math.min(curLeft, newLeft);</span><br><span class="line">                newRight = Math.max(curRight, newRight);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!insearted) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {newLeft, newRight});</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size(); i++) {</span><br><span class="line">            ret[i] = res.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a> [✅]</p><p>相向双指针应用题</p><p>本题主要考察两个：</p><ol><li>循环不变量</li><li>两数之和的相向双指针</li></ol><p>（其实挺简单的就是不要迷）</p><p>固定左边，那么中间的和右边的指针就是两数之和问题，然后为了解决重复的数组问题，那么需要在检查到和之前数相同时直接跳过就好了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// Arrays.stream(nums).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (;i &lt; n - <span class="number">2</span>; ) {</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) {</span><br><span class="line">                <span class="comment">// System.out.println(nums[i] + " " + nums[j] + " " + nums[k]);</span></span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) {</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) {</span><br><span class="line">                    j++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (k != n - <span class="number">1</span> &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) {</span><br><span class="line">                        k--;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) {</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                        list.add(nums[i]);</span><br><span class="line">                        list.add(nums[j]);</span><br><span class="line">                        list.add(nums[k]);</span><br><span class="line">                        ret.add(list);</span><br><span class="line">                    }</span><br><span class="line">                    k--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a> [✅]</p><p>前缀和思想： 额外空间 O(N) 做法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] prefixMulti = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] suffixMulti = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                prefixMulti[i] = <span class="number">1</span>;</span><br><span class="line">                suffixMulti[n - i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            prefixMulti[i] = nums[i - <span class="number">1</span>] * prefixMulti[i - <span class="number">1</span>];</span><br><span class="line">            suffixMulti[n - i - <span class="number">1</span>] = nums[n - i] * suffixMulti[n - i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(prefixMulti).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="comment">// Arrays.stream(suffixMulti).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            res[i] = prefixMulti[i] * suffixMulti[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了省去额外的空间，我们可以采取使用res数组作为中间的用于计算前缀积</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">suffixCur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            res[i] *= suffixCur;</span><br><span class="line">            suffixCur *= nums[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a> [✅]</p><p>回溯题，这是一个<code>选或不选</code>的问题：</p><p><img src="/posts/Blind-Sheet/39_fig1.png" alt="39_fig1"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; selected = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] candidates;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="comment">// 暴搜</span></span><br><span class="line">        <span class="built_in">this</span>.candidates = candidates;</span><br><span class="line">        n = candidates.length;</span><br><span class="line">        dfs(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> curIdx, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n || target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(selected));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curIdx; i &lt; n; i++) {</span><br><span class="line">            selected.addLast(candidates[i]);</span><br><span class="line">            dfs(i, target - candidates[i]);</span><br><span class="line">            selected.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a> [✅]</p><p>和插入区间异曲同工，需要注意边界的处理</p><p>自己的方法：</p><p>对左端点排序，「延迟」（即到下一个不可以合并的区间时候）加入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> {</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pStart</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], pEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[][]{{pStart, pEnd}};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span>[] interval = intervals[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>], end = interval[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// System.out.println(pStart + " " + pEnd + "; " + start + " " + end);</span></span><br><span class="line">            <span class="keyword">if</span> (pEnd &gt;= start) {</span><br><span class="line">                pStart = Math.min(pStart, start);</span><br><span class="line">                pEnd = Math.max(pEnd, end);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ls.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{pStart, pEnd});</span><br><span class="line">                pStart = start;</span><br><span class="line">                pEnd = end;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ls.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{pStart, pEnd});</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[ls.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ls.size(); i++) {</span><br><span class="line">            ret[i] = ls.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法2:</p><p>用一个list <code>merged</code> 来表示已经处理好的部分，如果碰到不重叠的区间或者merged为空时，直接加入merged即可，其他时候可以查看merged的右端点并且不断更新其右端点</p><p>这个方法更好地利用了排序的性质</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> {</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> merged.size();</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span> || merged.get(size - <span class="number">1</span>)[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>]) {</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]});</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                merged.get(size - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(size - <span class="number">1</span>)[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; merged.size(); i++) {</span><br><span class="line">            ret[i] = merged.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a>[❓]</p><p>这是一个考察循环不变量以及荷兰国旗的经典问题</p><ol><li>循环不变：</li></ol><p><a href="https://www.bilibili.com/video/BV1Jg411M7Lp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=54f34024c3784d45de85a3f70808ab70">Bilibili - 循环不变量</a></p><p><img src="/posts/Blind-Sheet/loop_invariant.png" alt="loop_invariant"></p><p><img src="/posts/Blind-Sheet/loop_invariant1.png" alt="loop_invariant1"></p><p><img src="/posts/Blind-Sheet/loop_invariant2.png" alt="loop_invariant2"></p><ol start="2"><li>荷兰国旗</li></ol><p>荷兰国旗的本质是要我们将数分成三段。</p><p>因此除了使用一个变量 <code>cur</code> 代指处理到哪一个 <code>nums[cur]</code> 以外，至少还需要两个变量来代指三段的边界：</p><ul><li>变量 <code>l</code> 为下一个填入 0 的位置（因此范围 [0,l−1] 均为 0，初始化 <code>l=0</code>，代表空集）</li><li>变量 <code>r</code> 为下一个填入 2 的位置（因此范围 [r+1,n−1] 均为 2，初始化 r=n−1，代表空集)</li><li>由于 [0,cur−1] 均为处理过的数值（即 0 和 2 必然都被分到了两端），同时 l−1 又是 0 的右边界，因此 [l,cur−1] 为 1 的区间，而 [cur,r] 为未处理的数值。</li></ul><p>分情况讨论：</p><ol><li>nums[cur]=0：此时将其与位置 l 进行互换（ l 为下一个待填入 0 的位置，同时 [l,cur−1] 为 1 的区间），本质是将nums[cur] 的 0 和 nums[l] 的 1 进行互换，因此互换后将 l 和 cur 进行右移；</li><li>nums[cur]=1：由于[l,cur−1] 本身就是 1 的区间，直接将 cur 进行右移即可；</li><li>nums[cur]=2：此时将其与位置 r 进行互换（r 为下一个待填入 2 的位置，但 [cur,r] 为未处理区间），也就是我们互换后，只能明确换到位置 nums[r] 的位置为 2，可以对 r 进行左移，但不确定新 nums[cur] 为何值，因此保持 cur 不变再入循环判断。</li><li>最后当 cur&gt;r（含义为未处理区间为空集），整个分三段过程结束。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [0, l - 1] 0</span></span><br><span class="line">        <span class="comment">// [0, cur - 1] 已经处理完</span></span><br><span class="line">        <span class="comment">// [l, cur - 1] 1</span></span><br><span class="line">        <span class="comment">// [cur, r] 待处理</span></span><br><span class="line">        <span class="comment">// [r + 1, n - 1] 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>; cur &lt;= r;) {</span><br><span class="line">            System.out.println(l + <span class="string">" "</span> + cur + <span class="string">" "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] == <span class="number">0</span>) {</span><br><span class="line">                swap(nums, l, cur);</span><br><span class="line">                l++;</span><br><span class="line">                cur++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] == <span class="number">1</span>) {</span><br><span class="line">                cur++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                swap(nums, cur, r);</span><br><span class="line">                r--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>双指针应用题：</p><ul><li>主要证明一点，我们应该固定长板，<strong>每一次都移动短板</strong>，因为只有移动短板才有可能会有更大的面积，而这是因为每一次收紧左右端点时候其都会变小。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curArea</span> <span class="operator">=</span> calculateArea(l, r, height[l], height[r]);</span><br><span class="line">            result = Math.max(curArea, result);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateArea</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> hi, <span class="type">int</span> hj)</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.min(hi, hj) * (j - i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>Stack</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a>[✅]</p><p>栈就是括号问题的代名词</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">        Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (sChar[i] == <span class="string">'('</span> || sChar[i] == <span class="string">'{'</span> || sChar[i] == <span class="string">'['</span>) {</span><br><span class="line">                dq.addLast(sChar[i]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (dq.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">curLast</span> <span class="operator">=</span> dq.peekLast();</span><br><span class="line">                <span class="keyword">if</span> (sChar[i] == <span class="string">')'</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (curLast != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> dq.pollLast();</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sChar[i] == <span class="string">']'</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (curLast != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> dq.pollLast();</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sChar[i] == <span class="string">'}'</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (curLast != <span class="string">'{'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> dq.pollLast();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dq.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><p>三种解法：</p><p>第一类：纵向和</p><p>这种方法是在 i 上进行计算，即算当前的高，一列一列的加</p><p>前后缀分解 ：</p><p>前后缀分解比较好理解，有两个备忘录一个记录</p><p>height[0, i] 的最大值 lMax</p><p>height[i, n - 1] 的最大值 rMax</p><p>那么当前 i 的雨水就是 <code>min(lMax, rMax) - height[i]</code></p><p>优化后的相向双指针：</p><p>但是可以省略这两个备忘录即使用相向双指针</p><p>但是这里不同的是</p><p>height[0, left] 的最大值 lMax</p><p>height[right, n - 1] 的最大值 rMax</p><p>不再是当前i而是left 和 right， 那么为什么可以保证这样是对的呢，这是因为当前i能接的雨水只看两遍的短的一边然后减去高度，也就是说重要的是 <code>height[i]</code> 能够装的水只和**Math.min(lMax, rMax)**相关（差）</p><p>第二类：横向和</p><p>这种方法类似于横向填充水泥。一行一行的加</p><p>单调栈</p><p>单调栈已经尝试多次</p><p>总结一下：</p><p>在需要更新栈中内容时，我们pop掉所有不符合要求的直至新加入的元素符合要求从而满足栈内元素单调。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] height;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="keyword">return</span> twoPointers();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">twoPointers</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lMax</span> <span class="operator">=</span> <span class="number">0</span>, rMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            lMax = Math.max(lMax, height[left]);</span><br><span class="line">            rMax = Math.max(rMax, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (lMax &lt; rMax) {</span><br><span class="line">                tot += lMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tot += rMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">monoStack</span><span class="params">()</span> {</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; height[stk.peek()] &lt;= height[i]) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">bottomColIdx</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (stk.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stk.peek();</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> Math.min(height[left], height[i]) - height[bottomColIdx];</span><br><span class="line">                tot += width * minHeight;</span><br><span class="line">            }</span><br><span class="line">            stk.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">detachPrefixSuffix</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        prefix[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            prefix[i] = Math.max(prefix[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        suffix[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            suffix[i] = Math.max(suffix[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            tot += calculateTrappedWater(prefix, suffix, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateTrappedWater</span><span class="params">(<span class="type">int</span>[] prefix, <span class="type">int</span>[] suffix, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.min(prefix[i], suffix[i]) - <span class="built_in">this</span>.height[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>Binary Tree</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">        <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode cur, TreeNode p, TreeNode q)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur == p || cur == q) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(cur.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> dfs(cur.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> cur; <span class="comment">// 在左右树上分别找到p和q，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right; <span class="comment">// 左边没找到，说明全在右边，首先找到的p或q就是LCA</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left; <span class="comment">// 右边没找到，说明全在左边，首先找到的p或q就是LCA</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>简单的BFS</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(root);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) {</span><br><span class="line">                    dq.addLast(cur.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) {</span><br><span class="line">                    dq.addLast(cur.right);</span><br><span class="line">                }</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">            res.add(level);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p><p>BFS很简单每一层最右边的加入</p><p>DFS就是先右子树，后左子树。然后有一个track来看这一层最右边的被加进来过没有。如果有之后就都不加了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> depthTrack)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (depthTrack == res.size()) {</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dfs(root.right, depthTrack + <span class="number">1</span>);</span><br><span class="line">        dfs(root.left, depthTrack + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p><p>这两题均属于构造类题目，具体可以看：</p> <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/" title="二叉树之构造类问题">二叉树之构造类问题</a> 中包含构造类问题的习题以及思路<p>核心思想都是通过构造左子树 + 右子树 连接根节点，只不过「细节和边界」略有不同，在尝试过后，使用左闭右开区间会<code>稍微</code>好处理一些</p><p>其实核心就是 <strong>子树 也是 树</strong>，所以递归的处理问题只要把大问题处理好小问题就可以很简单的处理了</p><p>105: 前序按照 中左右的顺序，所以可以先碰到的作为root节点然后递归的构造左右子树：</p><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2646359/tu-jie-cong-on2-dao-onpythonjavacgojsrus-aob8/">灵神 - 105</a></p></blockquote><p><img src="/posts/Blind-Sheet/1707907886-ICkiSC-lc105-c.png" alt="1707907886-ICkiSC-lc105-c"></p><p>106: 后序按照 左右中的顺序，所以可以从右开始碰到的作为root节点然后递归的构造左右子树：</p><p>但是注意这里的区间略有不同</p><p><img src="/posts/Blind-Sheet/1708475214-fiBgmD-LC106-c.png" alt="1708475214-fiBgmD-LC106-c"></p><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 105:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    Map&lt;Integer, Integer&gt; num2Idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> {</span><br><span class="line">        <span class="comment">// preorder 中左右 inorder 左中右</span></span><br><span class="line">        <span class="comment">// 恢复顺序 根，左右</span></span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) {</span><br><span class="line">            num2Idx.put(inorder[i], i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> building(<span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">building</span><span class="params">(<span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="comment">// System.out.println(preStart + " " + preEnd + " " + inStart + " " + inEnd);</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxInorder</span> <span class="operator">=</span> findNodeThruInorder(preorder[preStart]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> idxInorder - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构造左子树</span></span><br><span class="line">        root.left = building(preStart + <span class="number">1</span>, preStart + leftSize, inStart, idxInorder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = building(preStart + leftSize + <span class="number">1</span>, preEnd, idxInorder + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findNodeThruInorder</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">return</span> num2Idx.get(val);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 106:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] inorder, postorder;</span><br><span class="line">    Map&lt;Integer, Integer&gt; num2Idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">        <span class="comment">// 继续根左子树，右子树来构造</span></span><br><span class="line">        <span class="comment">// inorder 是 左中右， postorder 左右中</span></span><br><span class="line">        <span class="comment">// 后序遍历就是从根节点右往左而已</span></span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) {</span><br><span class="line">            num2Idx.put(inorder[i], i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> building(<span class="number">0</span>, inorder.length, <span class="number">0</span>, postorder.length);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">building</span><span class="params">(<span class="type">int</span> postStart, <span class="type">int</span> postEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="comment">// System.out.println(postStart + " " + postEnd + " " + inStart + " " + inEnd);</span></span><br><span class="line">        <span class="keyword">if</span> (postStart &gt;= postEnd || inStart &gt;= inEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> postorder[postEnd - <span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> num2Idx.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> idx - inStart;</span><br><span class="line"></span><br><span class="line">        root.left = building(postStart, postStart + leftSize, inStart, idx);</span><br><span class="line"></span><br><span class="line">        root.right = building(postStart + leftSize, postEnd - <span class="number">1</span>, idx + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></p><blockquote><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/290289/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/">LC解法</a></p></blockquote><p>两种解法一个DFS，一个BFS</p><p>DFS中还是延续了构造类问题的解法，构造 根 + 左子树 + 右子树</p><p>序列化：这里选择使用前序遍历，因为方便找到根节点当节点 = null时加入string</p><p>反序列化：dfs遍历，每一次移动一个位置，碰到 “null” 时return null，要不就构造节点</p><p>BFS是层序遍历，另外我们需要一个deque来保存制作好的节点在反序列化时移动left， rightcursor</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> {</span><br><span class="line">    StringBuilder sb;</span><br><span class="line">    String preOrder;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        buildWithPreOrder(root);</span><br><span class="line">        preOrder = sb.toString();</span><br><span class="line">        <span class="keyword">return</span> preOrder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildWithPreOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        buildWithPreOrder(root.left);</span><br><span class="line">        buildWithPreOrder(root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> {</span><br><span class="line">        String[] dataLs = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">// Arrays.stream(dataLs).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> building(dataLs);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">building</span><span class="params">(String[] dataLs)</span> {</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= dataLs.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (dataLs[idx].equals(<span class="string">"null"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.valueOf(dataLs[idx]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.left = building(dataLs);</span><br><span class="line">        root.right = building(dataLs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> bfsSerilize(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">bfsSerilize</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dq.add(root);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) {</span><br><span class="line">                sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sb.append(cur.val + <span class="string">","</span>);</span><br><span class="line">                dq.addLast(cur.left);</span><br><span class="line">                dq.addLast(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// System.out.println(sb.toString());</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> {</span><br><span class="line">        <span class="keyword">if</span> (data.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] dataArr = data.split(<span class="string">","</span>);</span><br><span class="line">        Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(dataArr[<span class="number">0</span>]));</span><br><span class="line">        dq.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; dataArr.length &amp;&amp; right &lt; dataArr.length) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">curLeft</span> <span class="operator">=</span> dataArr[left], curRight = dataArr[right];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (!curLeft.equals(<span class="string">"null"</span>)) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(curLeft));</span><br><span class="line">                cur.left = leftChild;</span><br><span class="line">                dq.addLast(leftChild);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!curRight.equals(<span class="string">"null"</span>)) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(curRight));</span><br><span class="line">                cur.right = rightChild;</span><br><span class="line">                dq.addLast(rightChild);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            left += <span class="number">2</span>; </span><br><span class="line">            right = left + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></tbody></table></figure><h1>Graph</h1><p><a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></p><p>经典的BFS和DFS</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="type">int</span>[][] image;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] floodFill(<span class="type">int</span>[][] image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color) {</span><br><span class="line">        n = image.length; </span><br><span class="line">        m = image[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="built_in">this</span>.image = image;</span><br><span class="line">        <span class="type">int</span> <span class="variable">originalColor</span> <span class="operator">=</span> image[sr][sc];</span><br><span class="line">        <span class="comment">// dfs(sr, sc, color, originalColor);</span></span><br><span class="line">        bfs(sr, sc, color, originalColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color, <span class="type">int</span> originalColor)</span> {</span><br><span class="line">        <span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sr &gt;= n || sc &lt; <span class="number">0</span> || sc &gt;= m) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (image[sr][sc] != originalColor) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[sr][sc]) <span class="keyword">return</span>;</span><br><span class="line">        image[sr][sc] = color;</span><br><span class="line">        visited[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            dfs(sr + dx[i], sc + dy[i], color, originalColor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color, <span class="type">int</span> originalColor)</span> {</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[] {sr, sc});</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="type">int</span>[] cur = dq.pollFirst();</span><br><span class="line">                <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> cur[<span class="number">0</span>], curY = cur[<span class="number">1</span>];</span><br><span class="line">                image[curX][curY] = color;</span><br><span class="line">                visited[curX][curY] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> curX + dx[d], newY = curY + dy[d];</span><br><span class="line">                    <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= n || newY &lt; <span class="number">0</span> || newY &gt;= m || image[newX][newY] != originalColor || visited[newX][newY]) <span class="keyword">continue</span>;</span><br><span class="line">                    dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[] {newX, newY});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></p><p>对于这种多源的问题我们可以反过来考虑，让终点入队，这里让终点入队的好处是我们就可以让每一个点都只被visited一次从而避免多次（至多4次）visit 节点</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span>[][] mat;</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] mat) {</span><br><span class="line">        <span class="comment">// BFS 第一个碰见的一定是最近的</span></span><br><span class="line">        <span class="built_in">this</span>.n = mat.length; </span><br><span class="line">        <span class="built_in">this</span>.m = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.mat = mat;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    mat[i][j] = -<span class="number">1</span>; <span class="comment">// 这样既有visited过的效果又可以记录最短距离</span></span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) {</span><br><span class="line">                    dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[] {i, j});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bfs(dq);</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Deque&lt;<span class="type">int</span>[]&gt; dq)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span>[] cur = dq.pollFirst();</span><br><span class="line">                <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> cur[<span class="number">0</span>], curY = cur[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> curX + dx[i], newY = curY + dy[i];</span><br><span class="line">                    <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= n || newY &lt; <span class="number">0</span> || newY &gt;= m || mat[newX][newY] != -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    mat[newX][newY] = level; <span class="comment">// 相当于更新了visited 以及 答案</span></span><br><span class="line">                    dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[] {newX, newY});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week2</title>
      <link href="/posts/CS5520-Week2/"/>
      <url>/posts/CS5520-Week2/</url>
      
        <content type="html"><![CDATA[<h1>Week 2</h1><h1>Android Architecture</h1><p>an activity represents a screen of an application.</p><p>In Android, one way to define the entry point into your application is to create an activity and specify it in the manifest file. The Activity class (provided by Android) does a bunch of behind the scenes work to start the application running and show itself to the user.</p><p><img src="/posts/CS5520-Week2/Untitled.png" alt="Untitled"></p><h1>Activity Lifecycle</h1><p>Sequence for activity states is:</p><p>Created Started Resumed Paused Stopped Destroyed</p><p><strong>Managing the Activity Life-Cycle</strong></p><p>As a developer you can manage your app’s lifecycle by overriding the event handlers that correspond to these state changes (noted in the diagram above in the grey boxes):</p><ul><li><strong>onCreate():</strong>&nbsp;Perform setup that should only happen <strong>once</strong> for entire life of the activity. The activity is in the created state after this method executes.</li><li><strong>onStart():</strong>&nbsp;<strong>Prepare the activity to enter the foreground and become interactive</strong>. This method is where you should <strong>initialize</strong> the <strong>code</strong> that <strong>maintains the UI.</strong></li><li><strong>onResume():</strong>&nbsp;The activity is <strong>in the foreground</strong>, and is <strong>ready</strong> for users to interact with it. The activity <strong>stays in this state until something happens to take the focus away from the app, such as a phone call or the user hitting the back button.</strong></li><li><strong>onPause():&nbsp;The activity has been interrupted, so it enters the paused state.</strong> The activity no longer has focus, so use this callback to stop anything that shouldn’t be happening when the app doesn’t have focus (for example, the timer or music playing for a game). This needs to have a quick return! It’s not the right place to save application state.</li><li><strong>onStop():</strong>&nbsp;The activity enters the stopped state when it no longer is visible on the screen. In Android API Level 23 or lower, an activity goes from the paused to stopped state immediately; in API Level 24 and higher, it is possible for a window, e.g. a dialog, to partially cover another activity, so an activity might stay in the paused state longer. This is where your activity should perform more CPU intensive and potentially longer running operations, such as persisting the state of the UI and other data operations.</li><li><strong>onDestroy():</strong>&nbsp;The activity enters the destroyed state when the system is killing the process running this activity, when finish() is called, or when the device undergoes an orientation change (in this case, onCreate() will be called immediately, to allow the activity to reconfigure in response to the orientation change). The activity should release any resources it hasn’t already released.</li></ul><h1>Tasks and the Back Stack</h1><p>A task is a collection of activites that ar epart of an application.</p><h1>What makes games addicting</h1>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week3-Views</title>
      <link href="/posts/CS5520-Week3/"/>
      <url>/posts/CS5520-Week3/</url>
      
        <content type="html"><![CDATA[<h1>Week3 - Views, View Groups and Layouts</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View handles rectangle on screen.</span><br><span class="line">ViewGroup handles rectangle on screen, &amp; contains child views</span><br><span class="line">Layout handles rectangle on screen, &amp; contains child views, which are arranged in a manner</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week4-Intents-RecyclerView</title>
      <link href="/posts/CS5520-Week4/"/>
      <url>/posts/CS5520-Week4/</url>
      
        <content type="html"><![CDATA[<h1>Week 4 - Google’s Material Design, Intents &amp; App Manifests, &amp; RecyclerView</h1><p>Material Design 在中文中通常被称为“材料设计”或“质感设计”。这是一种由谷歌开发的综合性设计语言，旨在合成经典设计原则与科技创新的可能性，以创建一种视觉语言。材料设计基于纸张和墨水的物理特性，但通过数字屏幕和科技的能力来实现，旨在提供一致性、直观性和美观性，改善用户体验，并在谷歌的移动应用、Android应用以及许多其他公司的网页和移动应用中得到广泛应用。</p><p>材料设计的核心特点包括响应式动画和过渡、深度效果（如光照和阴影）、基于网格的布局以及一系列的组件和指南，这些都旨在帮助开发者创建具有一致性、直观性和现代美学的应用界面。在Android平台上，采用材料设计原则对于确保应用与Android生态系统内其他应用保持一致、提升用户体验、吸引并保持用户的兴趣具有重要意义。此外，材料设计作为一种跨平台的设计语言，也支持在iOS和Web应用程序中使用，帮助开发者在不同平台之间保持设计的一致性。</p><h1>Intents and Intent Filter</h1><p>Intent is a message to request action from another app component</p><p>Intent filter which implicit intents your app can receive</p><p>Explicit Intents and Implicit Intent</p><p>在Android开发中，“意图（Intents）”和“意图过滤器（Intent Filters）”是两个核心概念，它们用于应用程序之间的通讯以及内部组件之间的消息传递。</p><h3 id="意图（Intents）">意图（Intents）</h3><p>意图是一个消息传递对象，可以用来请求另一个应用组件的动作。它们主要用于启动活动（Activities）、启动服务（Services）或者传送广播（Broadcasts）。根据使用方式的不同，意图分为显式意图和隐式意图。</p><ul><li><strong>显式意图（Explicit Intents）</strong>：直接指定了要启动或通信的组件（例如，活动、服务或接收器）的名称。它们通常用于应用内组件之间的交互。例如，从一个活动启动另一个活动时，你会明确指定要启动的目标活动。</li><li><strong>隐式意图（Implicit Intents）</strong>：不直接指定要启动的组件，而是声明一个要执行的动作和提供必要数据的类型。系统通过意图过滤器来判断哪个组件能够响应该意图。隐式意图主要用于触发不同应用中的组件。例如，你可以通过隐式意图请求打开一个网页，系统会通过安装的应用中的意图过滤器来决定用哪个浏览器打开该网页。</li></ul><h3 id="意图过滤器（Intent-Filters）">意图过滤器（Intent Filters）</h3><p>意图过滤器用于指定一个组件（活动、服务或广播接收器）愿意接受的意图类型。它在应用的清单文件（AndroidManifest.xml）中声明，用于描述一个组件能够响应的动作、数据和数据类型。当系统接收到一个隐式意图时，它会检查所有组件的意图过滤器，找到能够处理该意图的组件。</p><p>总结一下，意图和意图过滤器是Android应用开发中用于组件间通信和交互的基础。显式意图直接指定目标组件，适用于应用内部通信；而隐式意图声明一个动作，让系统找到合适的组件来处理，适用于跨应用通信。意图过滤器则定义了组件愿意接受和处理的意图类型。</p><p>当然可以。以下是一个Android开发中使用显式意图和隐式意图的简单代码示例：</p><h3 id="显式意图（Explicit-Intent）示例">显式意图（Explicit Intent）示例</h3><p>假设你有两个活动：<code>MainActivity</code> 和 <code>SecondActivity</code>。你想从 <code>MainActivity</code> 启动 <code>SecondActivity</code>。</p><p><strong>MainActivity.java:</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在MainActivity中创建并启动显式意图</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">explicitIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">startActivity(explicitIntent);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，你通过指定当前的上下文（<code>MainActivity.this</code>）和要启动的活动类（<code>SecondActivity.class</code>）来创建一个显式意图。然后，你通过调用 <code>startActivity()</code> 方法来启动 <code>SecondActivity</code>。</p><h3 id="隐式意图（Implicit-Intent）示例">隐式意图（Implicit Intent）示例</h3><p>现在，假设你想让用户选择一个应用来浏览网页，而不是直接指定使用哪个应用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个隐式意图来打开网页</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">implicitIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, Uri.parse(<span class="string">"&lt;https://www.example.com&gt;"</span>));</span><br><span class="line"><span class="comment">// 验证是否有应用可以处理这个意图</span></span><br><span class="line"><span class="keyword">if</span> (implicitIntent.resolveActivity(getPackageManager()) != <span class="literal">null</span>) {</span><br><span class="line">    startActivity(implicitIntent);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 处理找不到应用的情况</span></span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>, <span class="string">"No application can handle this request."</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个隐式意图的例子中，你通过指定一个动作（<code>Intent.ACTION_VIEW</code>）和数据（网页的URI）来创建意图。<code>resolveActivity()</code> 方法用于检查是否有应用能够处理这个意图。如果有，那么使用 <code>startActivity()</code> 方法启动一个能够浏览指定网址的应用；如果没有，你可以提示用户没有应用可以处理这个请求。</p><h3 id="意图过滤器（Intent-Filter）示例">意图过滤器（Intent Filter）示例</h3><p>为了让 <code>SecondActivity</code> 能够响应隐式意图，你需要在应用的清单文件（<code>AndroidManifest.xml</code>）中为 <code>SecondActivity</code> 添加意图过滤器：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"https"</span> <span class="attr">android:host</span>=<span class="string">"www.example.com"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个意图过滤器声明 <code>SecondActivity</code> 能够处理查看（<code>ACTION_VIEW</code>）动作的意图，且这些意图的数据URI符合特定的模式（在这个例子中是打开 <code>https://www.example.com</code> 的网页）。这样，当有符合这些条件的隐式意图被触发时，<code>SecondActivity</code> 就可以作为处理该意图的候选。</p><p>这些代码样例提供了使用显式和隐式意图进行基本Android应用开发操作的简单入门指南。</p><h1>Bundle and Parcel and Configuration Change</h1><h2 id="Bundle-and-Parcel">Bundle and Parcel</h2><h3 id="数据序列化的必要性"><strong>数据序列化的必要性</strong></h3><p>当你在内存中引用一个对象时，这个对象可能包含对其他对象的引用。如果你直接将这个对象的字节写入磁盘，然后在之后读取回来，原来的对象引用所指向的其他对象可能已经不存在了。这是因为对象引用指向的是内存中的位置，而当程序重新运行时，这些位置所存储的内容可能已经发生了变化或者被释放了。</p><h3 id="数据序列化（Serialization）"><strong>数据序列化（Serialization）</strong></h3><p>数据序列化是解决上述问题的过程。它涉及到将一个对象及其引用的所有对象转换成一个字节流，这个字节流包含了所有实际的数据而不是数据的引用。这样，当你从磁盘读取这个字节流时，你可以通过反序列化（Deserialization）来重建原始对象及其引用的对象。这个过程有时也被称为“扁平化（Flattening）”和“非扁平化（Unflattening）”。</p><h3 id="序列化在Android中的应用"><strong>序列化在Android中的应用</strong></h3><p>在Android开发中，序列化不仅用于数据持久化（例如将对象写入磁盘），也用于在不同的活动（Activities）或不同的进程之间传递数据。由于不同活动或进程不能直接访问相同的对象内存，所以需要将对象及其引用的数据转换成序列化的形式，以便传递实际数据而非引用。</p><h3 id="Bundle-和-Map"><strong>Bundle 和 Map</strong></h3><p><strong><code>Bundle</code></strong> 在Android中用于在活动之间传递数据，它类似于Java中的**<code>Map</code><strong>，包含键值对。虽然</strong><code>Map</code><strong>也可以用于存储键值对，但</strong><code>Bundle</code><strong>相比之下对值的类型有更严格的限制，以确保序列化的数据不包含对外部对象的引用。这样，当</strong><code>Bundle</code>**被传递时，它包含的是实际数据，而不是数据的引用，确保了数据的完整性和独立性。</p><h3 id="Parcel"><strong>Parcel</strong></h3><p><strong><code>Parcel</code></strong> 是**<code>Bundle</code><strong>的一个更灵活的版本，提供了一个定义好的接口，允许你在自己的代码中处理序列化和反序列化，而不是完全依赖Android系统来做这些工作。如果你不确定使用哪个，通常建议使用</strong><code>Bundle</code>**，因为它更简单，且适用于大多数情况。</p><h2 id="Configuration">Configuration</h2><p>For example, a checkbox that was checked will end up unchecked in the newly created activity.</p><p>There are three basic solutions:</p><p>When the activity is being destroyed, onSaveInstanceState() will called.&nbsp; Override this method to save the state in a Bundle when.&nbsp; When the activity is created again, the Bundle will be passed to it, and you can restore the state from the Bundle.&nbsp; Review the course materials on Bundle and Parcel, and then read the Configuration Changes section in this link:</p><p><a href="https://developer.android.com/reference/android/app/Activity#configuration-changes">https://developer.android.com/reference/android/app/Activity#configuration-changesLinks to an external site.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week5-Threads</title>
      <link href="/posts/CS5520-Week5/"/>
      <url>/posts/CS5520-Week5/</url>
      
        <content type="html"><![CDATA[<h1>Week 5 - Threads, AsyncTask, Broadcast</h1><h1>Android Threads</h1><p>Main Thread and UI Thread Use Interchangblely</p><p>When Launch new Activity, it happens on Main Thread unlsess explicitly done something to have it run on other threads</p><p>The Android User Interface (UI) toolkit refers to a set of tools and APIs provided by the Android framework that developers use to design and manage the user interface of their applications. This toolkit includes a wide range of UI elements such as buttons, text views, list views, layout managers, and many more, which are essential for creating interactive and visually appealing applications.</p><p>Android Uer Interface toolkit is not thread safe</p><p>Rules to follow:</p><ol><li>Never block UI/Main Thread ← 所以也不需要intensive的东西</li><li>Do not access UI from a non-UI Thread</li></ol><h2 id="Android-Components">Android Components:</h2><p>在Android开发中，Activities（活动）、Services（服务）和Broadcast Receivers（广播接收器）是三种主要的应用组件，每种组件都有其特定的用途和生命周期。下面是每种组件的简介和比较，以及相应的例子。</p><h3 id="Activities（活动）"><strong>Activities（活动）</strong></h3><ul><li><strong>定义：</strong> Activity是一个代表单个屏幕的UI组件，用户可以与之互动。它通常充当应用程序中的一个界面，用于显示信息、接收用户输入等。</li><li><strong>用例：</strong> 例如，一个电子邮件应用可能有一个显示收件箱列表的Activity，点击某个邮件后，会启动另一个Activity来显示邮件内容。</li></ul><h3 id="Services（服务）"><strong>Services（服务）</strong></h3><ul><li><strong>定义：</strong> Service是一个用于在后台执行长时间运行操作而不提供用户界面的组件。服务可以在应用程序的背景中执行任务，即使用户没有直接与应用程序交互。</li><li><strong>用例：</strong> 例如，一个音乐播放应用可以使用Service在后台播放音乐，即使用户离开了应用的界面。</li></ul><h3 id="Broadcast-Receivers（广播接收器）"><strong>Broadcast Receivers（广播接收器）</strong></h3><ul><li><strong>定义：</strong> Broadcast Receiver是一种用于接收和响应来自其他应用程序或系统的广播通知的组件。它们主要用于监听和响应系统级事件，如屏幕关闭、电池电量低等。</li><li><strong>用例：</strong> 例如，应用程序可以注册一个Broadcast Receiver来监听设备启动完成的广播，以便在设备启动时执行某些操作。</li></ul><h2 id="Process-Heirarchy">Process Heirarchy</h2><p>手机的资源比较紧缺所以会按照层级来移除低等级的Process</p><ol><li>Foreground Process<ol><li>most important, required to do right now</li><li>一般指：<ol><li>Running an activity the user is interacting with</li><li>BroadcastReceiver that is currently running</li><li>Service currently executing code in a callback</li></ol></li></ol></li><li>Visible Process<ol><li>Activity visible on Screen but not active (onPause() has been called)</li><li>Service is running in the foreground ← Music Player playing music</li><li>Service that manages something the user might be aware of ← live wallpaper</li></ol></li><li>Service Process<ol><li>Hosting a service that is started</li><li>Usually not as visible to users</li><li>Doing something the user cares about</li><li>eg updating or downloading something</li></ol></li><li>Cached Process (Android use LRU strategy)<ol><li>not currently active, but could become active soon</li></ol></li></ol><p>If the main thread cannot finish executing blocks of work within 16ms, the user may observe hitching, lagging, or a lack of UI responsiveness to input. If the main thread blocks for approximately five seconds, the system displays the&nbsp;<em><a href="https://developer.android.com/training/articles/perf-anr">Application Not Responding</a></em>&nbsp;(ANR) dialog, allowing the user to close the app directly.</p><h1>Java Runnable - Threads</h1><p><img src="/posts/CS5520-Week5/Untitled.png" alt="Untitled"></p><p>![Untitled 1](/posts/CS5520-Week5/Untitled 1.png)</p><p>![Untitled 2](/posts/CS5520-Week5/Untitled 2.png)</p><p>您上传了三张关于并发编程中的进度图（progress graphs）和关键部分（critical sections）与不安全区域（unsafe regions）的图表。这些图表是并发编程概念的视觉表示，让我们来逐一解读。</p><h3 id="第一张图：Trajectories-in-Progress-Graphs">第一张图：Trajectories in Progress Graphs</h3><p>这张图展示了两个线程（Thread 1 和 Thread 2）的可能执行轨迹。轨迹是合法的状态转换序列，描述了线程可能的并发执行。图中的示例轨迹是：</p><p><code>H1, L1, U1, H2, L2, S1, T1, U2, S2, T2</code></p><p>这意味着：</p><ul><li>Thread 1 从 H1 开始，执行到 L1，然后是 U1。</li><li>然后，Thread 2 从 H2 开始，执行到 L2。</li><li>接着是 Thread 1 的 S1，T1。</li><li>然后是 Thread 2 的 U2，S2，T2。</li></ul><p>这个轨迹通过红色箭头标出，表明了线程的执行顺序和交替。</p><h3 id="第二张图：Critical-Sections-and-Unsafe-Regions">第二张图：Critical Sections and Unsafe Regions</h3><p>第二张图说明了什么是关键部分和不安全区域。关键部分是指访问共享资源（在这个例子中是 <code>cnt</code> 变量）时的代码区域，应该避免两个线程同时进入此区域。不安全区域是图中标红区域，表示如果两个线程的执行轨迹同时进入这个区域，就可能发生竞态条件（race condition），导致不可预测的结果。</p><h3 id="第三张图：Critical-Sections-and-Unsafe-Regions-with-Safe-Trajectory">第三张图：Critical Sections and Unsafe Regions with Safe Trajectory</h3><p>第三张图显示了一个安全的执行轨迹，即在任何时候都避免进入不安全区域。绿色箭头表示了一个安全轨迹的例子，这个轨迹没有进入不安全区域，因此对于共享变量 <code>cnt</code> 来说是正确的。</p><h3 id="总结">总结</h3><ul><li><strong>轨迹（Trajectory）</strong>：线程的执行序列。</li><li><strong>关键部分（Critical Section）</strong>：一个或多个线程访问共享资源的代码区域。</li><li><strong>不安全区域（Unsafe Region）</strong>：可能导致并发错误的状态集合。</li><li><strong>安全轨迹（Safe Trajectory）</strong>：一条不穿越任何不安全区域的轨迹。</li></ul><p>这些图是并发编程中同步和互斥概念的可视化表示。它们用于教学和理解如何在多线程环境中安全地协调对共享资源的访问。</p><p>![Untitled 3](/posts/CS5520-Week5/Untitled 3.png)</p><p>您上传的图片显示了一个名为 <code>RaceCondition</code> 的类，它包含一个名为 <code>sharedResource</code> 的共享资源和一个名为 <code>startTwoThreads</code> 的方法。这个方法创建并启动两个线程，<code>t1</code> 和 <code>t2</code>。线程 <code>t1</code> 将 <code>sharedResource</code> 的值增加1（<code>sharedResource++</code>），而线程 <code>t2</code> 将其减少1（<code>sharedResource--</code>）。</p><p>以下是根据前面的图表分析的结果：</p><h3 id="轨迹（Trajectory）">轨迹（Trajectory）</h3><p>在这个示例中，轨迹是两个线程对 <code>sharedResource</code> 变量执行的操作序列。例如，如果 <code>t1</code> 先执行，然后是 <code>t2</code>，轨迹可能是 <code>H1, L1, U1, H2, L2, U2</code>。但是，由于操作系统的调度，我们无法保证执行的顺序。如果线程 <code>t1</code> 和 <code>t2</code> 几乎同时运行，它们对 <code>sharedResource</code> 的操作可能会交错，导致多种可能的轨迹。</p><h3 id="关键部分（Critical-Section）">关键部分（Critical Section）</h3><p>在这个例子中，关键部分是对 <code>sharedResource</code> 的增加和减少操作。由于这些操作不是原子的（也就是说，它们不是一个不可分割的单个操作），它们可以被另一个线程的操作中断。如果两个线程同时进入关键部分，就可能导致 <code>sharedResource</code> 的最终值不正确。</p><h3 id="不安全区域（Unsafe-Region）">不安全区域（Unsafe Region）</h3><p>不安全区域是指如果两个线程的操作交错发生时，可能导致数据不一致的状态集合。在这个代码示例中，不安全区域包括了所有可能导致 <code>sharedResource</code> 更新不正确的状态。例如，如果线程 <code>t1</code> 执行 <code>sharedResource++</code> 但在完成这个操作之前被线程 <code>t2</code> 打断，线程 <code>t2</code> 执行 <code>sharedResource--</code>，那么最终 <code>sharedResource</code> 的值可能不会反映两个操作。</p><h3 id="安全轨迹（Safe-Trajectory）">安全轨迹（Safe Trajectory）</h3><p>一个安全轨迹是一种线程执行顺序，其中不发生任何进入不安全区域的情况。要实现安全轨迹，需要同步机制来确保当一个线程在执行对 <code>sharedResource</code> 的操作时，另一个线程不能执行其操作。在Java中，可以通过使用 <code>synchronized</code> 关键字或显式的锁（如 <code>ReentrantLock</code>）来保证操作的原子性，从而创建一个安全的轨迹。</p><h3 id="为什么">为什么</h3><p>由于Java中的线程调度是不确定的，因此两个线程对 <code>sharedResource</code> 的操作可能会以不可预测的方式交错。这就是为什么这段代码存在竞态条件的风险，以及为什么不使用同步机制时，不能保证 <code>sharedResource</code> 的值是线程安全的。通过使用同步机制，我们可以确保每次只有一个线程能够进入关键部分，从而避免不安全区域并保证数据的一致性。</p><p>要解决这种竞态条件，您可以使用 <code>synchronize</code> 关键字来确保对共享资源 <code>sharedResource</code> 的操作是原子性的，这样同一时间只有一个线程能够访问和修改它。</p><p>在Java中，有几种方法可以使用 <code>synchronize</code> 关键字来同步对共享资源的访问：</p><ol><li><p><strong>同步方法（Synchronized Method）</strong>：<br>您可以将整个方法声明为同步的，这将锁定包含该方法的对象实例，以便一次只有一个线程可以执行该方法。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    sharedResource++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> {</span><br><span class="line">    sharedResource--;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>同步块（Synchronized Block）</strong>：<br>如果您只想同步方法中的一部分代码（也就是关键部分），您可以使用同步块。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) {</span><br><span class="line">        sharedResource++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) {</span><br><span class="line">        sharedResource--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><p>在这两种情况下，<code>this</code> 引用的是包含 <code>synchronized</code> 代码的对象实例。当一个线程进入一个同步的方法或块时，它会获得该对象的锁，并在退出时释放锁。其他线程必须等待锁被释放才能执行同步的代码。</p><p>这是您原始代码的修改版本，使用了同步方法来解决竞态条件：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaceCondition</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sharedResource</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">        sharedResource++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> {</span><br><span class="line">        sharedResource--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTwoThreads</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                increment();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                decrement();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过同步 <code>increment</code> 和 <code>decrement</code> 方法，我们确保了 <code>sharedResource</code> 的增加和减少操作是线程安全的。</p><p>在Java中，<code>wait()</code>, <code>notify()</code>, 和 <code>notifyAll()</code> 是 <code>Object</code> 类的一部分，它们用于线程间的通信，特别是在同步代码块内部。这些方法用来协调需要共享资源的多个线程之间的交互，特别是当某些条件不满足时，线程需要等待其他线程来改变这些条件。</p><h3 id="wait">wait()</h3><p><code>wait()</code> 方法用于使当前执行的线程暂停执行（进入等待状态）直到其他线程调用同一对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。调用 <code>wait()</code> 之前，线程必须持有该对象的锁，调用 <code>wait()</code> 后，它会释放锁并进入对象的等待池。一旦该线程被 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒，它会尝试重新获取锁，并在成功后继续执行。</p><h3 id="notify">notify()</h3><p><code>notify()</code> 方法用于唤醒在此对象的等待池中等待的单个线程。如果有多个线程都在等待，那么会选择其中一个线程（选择方式不确定）进行唤醒。被唤醒的线程将尝试重新获得对象的锁，一旦获得，它可以继续执行。</p><h3 id="notifyAll">notifyAll()</h3><p><code>notifyAll()</code> 方法唤醒在此对象的等待池中等待的所有线程。这不是立即将锁分配给这些线程，而是让它们竞争对象锁。只有锁可用时，这些线程中的一个才能继续执行。<code>notifyAll()</code> 通常用于通知所有等待的线程条件可能已经满足，让它们重新检查条件是否达到了可以继续执行的状态。</p><h3 id="使用示例">使用示例</h3><p>假设你有一个生产者-消费者问题，其中消费者线程需要等待生产者线程在队列中放入对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedResource</span> {</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">while</span> (list.size() == capacity) {</span><br><span class="line">            wait(); <span class="comment">// 等待消费者消费产品</span></span><br><span class="line">        }</span><br><span class="line">        list.add(value);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) {</span><br><span class="line">            wait(); <span class="comment">// 等待生产者生产产品</span></span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产了</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，<code>produce()</code> 和 <code>consume()</code> 方法都是同步的，这意味着它们在执行前要获取 <code>SharedResource</code> 对象的锁。如果条件不满足（例如，队列满或空），生产者或消费者将调用 <code>wait()</code> 并释放锁，进入等待状态。当一个生产者或消费者更改了条件后，它将调用 <code>notifyAll()</code> 来唤醒所有等待的线程，这些线程将尝试重新获取锁，并检查它们的条件是否现在满足了。</p><p>重要的是要记住，使用这些方法时需要注意正确的条件循环（通常是 <code>while</code> 循环），以避免虚假唤醒带来的问题。此外，在调用 <code>wait()</code>, <code>notify()</code>, 或 <code>notifyAll()</code> 时，线程必须持有那个对象的锁。</p><p>![Untitled 4](/posts/CS5520-Week5/Untitled 4.png)</p><p>在您提供的代码示例中，使用了读写锁（<code>ReentrantReadWriteLock</code> 或类似的锁实现），这是一个支持多个读取操作和一个写入操作的锁机制。</p><h3 id="为什么需要读锁（Read-Lock）">为什么需要读锁（Read Lock）</h3><ol><li><strong>数据一致性</strong>：即使是看似简单的读取操作，也可能会因为同时进行的写入操作而返回不一致的数据。例如，如果一个线程正在读取一个值，同时另一个线程在写入这个值，没有合适的同步可能导致读取操作获得一个无效的值。</li><li><strong>防止写入时读取</strong>：读锁可以确保没有写操作正在进行，这样读取操作就可以安全地进行。在这种锁的机制中，任何时候都可以有多个读取操作进行，只要没有写锁被持有。</li></ol><h3 id="作用">作用</h3><ol><li><strong>多读单写</strong>：读写锁允许多个线程同时读取，但保证只有一个线程进行写入，从而在保持并发读取的同时，还能保证写入的独占性和数据的完整性。</li><li><strong>性能优化</strong>：相比于传统的互斥锁（如<code>synchronized</code>关键字或<code>ReentrantLock</code>），读写锁在只进行读取操作时允许更高的并发性，这可以在多线程环境下显著提高性能。</li><li><strong>避免读取脏数据</strong>：使用读锁可以确保在读取期间不会有其他线程进行写入，这意味着读取操作不会得到部分更新的“脏数据”。</li></ol><p>在您的代码中，<code>readState()</code> 方法在读取 <code>sharedResource</code> 前获取了读锁，并在返回值后释放了读锁。这确保了在执行读取操作时，不会有其他线程正在执行写入操作（<code>changeState()</code> 方法），从而保持了数据的一致性和完整性。</p><h3 id="正确的锁释放">正确的锁释放</h3><p>在 <code>finally</code> 块中释放锁是非常重要的，因为它确保了即使在尝试获取或返回共享资源时发生异常，锁也会被释放，这样就不会导致死锁或资源不再可用。</p><p>这段代码就体现了一种在多线程环境中保证数据一致性的好做法，它通过适当地使用锁来同步对共享资源的访问。</p><p>在Java中，创建线程有两种常见的方法：继承 <code>Thread</code> 类和实现 <code>Runnable</code> 接口。下面是两种方法的说明和示例。</p><h3 id="继承-Thread-类">继承 <code>Thread</code> 类</h3><p>当你继承 <code>Thread</code> 类时，你需要重写其 <code>run</code> 方法来定义线程执行的代码。然后你可以创建该类的实例并调用 <code>start</code> 方法来启动新线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 代码在线程中执行</span></span><br><span class="line">        System.out.println(<span class="string">"Thread running: "</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="实现-Runnable-接口">实现 <code>Runnable</code> 接口</h3><p>实现 <code>Runnable</code> 接口是创建线程的另一种方式。你需要实现 <code>run</code> 方法，然后将 <code>Runnable</code> 实现类的实例传递给 <code>Thread</code> 类的构造器，并启动线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 代码在线程中执行</span></span><br><span class="line">        System.out.println(<span class="string">"Thread running using Runnable"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="继承-Thread-类-vs-实现-Runnable-接口">继承 <code>Thread</code> 类 vs 实现 <code>Runnable</code> 接口</h3><p>虽然这两种方式都可以用来创建线程，但它们之间有一些重要的区别：</p><ol><li><strong>实现 <code>Runnable</code> 接口的优点</strong>：<ul><li>Java不支持多重继承。如果你的类已经继承了另一个类，你就不能再继承 <code>Thread</code> 类，但你仍然可以实现 <code>Runnable</code> 接口。</li><li>实现 <code>Runnable</code> 接口可以使类更加灵活地被多个线程实例共享和执行。</li></ul></li><li><strong>继承 <code>Thread</code> 类的缺点</strong>：<ul><li>继承 <code>Thread</code> 类意味着你不能再继承其他类，因为Java不支持多重继承。</li><li>当你继承 <code>Thread</code> 类时，你的线程类不能被其他的子类再次扩展。</li></ul></li></ol><p>通常情况下，实现 <code>Runnable</code> 接口被认为是更好的做法，因为它更加灵活，使你的线程代码可以被多个执行器（Executors）或线程共享，而不是限制在单个 <code>Thread</code> 对象中。</p><p>![Untitled 5](/posts/CS5520-Week5/Untitled 5.png)</p><ol><li><strong><code>differentThread</code></strong> 类继承自 <strong><code>Thread</code></strong> 类。它在其 <strong><code>run()</code></strong> 方法内部包含一个循环，循环会执行10次。</li><li>在 <strong><code>differentThread</code></strong> 的 <strong><code>run()</code></strong> 方法中，使用了 <strong><code>Handler.post()</code></strong> 方法。这并不是创建了一个新的线程，而是在Android的UI线程中安排一个 <strong><code>Runnable</code></strong> 对象执行。这是因为对UI的操作需要在UI线程中执行，而 <strong><code>Handler.post()</code></strong> 是将一个任务排队到UI线程的事件队列中，这样它就可以在UI线程中被处理。</li><li><strong><code>final int finalI = i;</code></strong> 这行代码是创建了一个在内部匿名 <strong><code>Runnable</code></strong> 类中使用的最终变量（因为局部变量在内部类中使用时必须是最终的或事实上最终的）。</li><li>在每次循环中，都会通过 <strong><code>Handler.post()</code></strong> 发布一个新的 <strong><code>Runnable</code></strong> 到UI线程的消息队列中，这个 <strong><code>Runnable</code></strong> 设置 <strong><code>TextView</code></strong> 的文本。这不是创建新线程，而是在UI线程中调度任务。</li><li><strong><code>Thread.sleep(1000);</code></strong> 使 <strong><code>differentThread</code></strong> 睡眠1秒钟，这是在 <strong><code>differentThread</code></strong> 线程中进行的，不会影响UI线程。</li></ol><p>通过循环创建10个thread:</p><p>如果您去掉 <code>textHandler.post()</code> 并且是在一个普通的Java环境（而不是Android），直接在循环内部创建并启动线程，那么您将会创建多个线程。以下是一个简单的Java示例，它在一个循环中创建和启动了10个线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleThreadsExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 每次循环创建一个新的线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    <span class="comment">// 在这里放入每个线程需要执行的代码</span></span><br><span class="line">                    System.out.println(<span class="string">"Running in a new thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="comment">// 启动线程</span></span><br><span class="line">            thread.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，每次循环都会创建一个新的 <code>Thread</code> 实例，并将一个新的 <code>Runnable</code> 实例传递给它。然后调用 <code>start()</code> 方法启动线程。每个线程将在控制台输出它正在运行的线程名称。这样，一共会有10个线程被创建并启动，它们将并发执行。</p><h2 id="Runnable">Runnable:</h2><p>在Java中，<code>Runnable</code> 是一个接口，用于创建可以由线程执行的任务。它是并发编程的核心接口之一，表示一个抽象的可执行任务。</p><h3 id="定义">定义</h3><p><code>Runnable</code> 接口非常简单，它只有一个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="实现">实现</h3><p>当一个类实现了 <code>Runnable</code> 接口，它需要提供 <code>run</code> 方法的实现。<code>run</code> 方法定义了线程启动时执行的操作。以下是一个实现 <code>Runnable</code> 接口的简单示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 这里是线程要执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">"MyRunnable is running."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="使用">使用</h3><p>要执行一个实现了 <code>Runnable</code> 接口的任务，你需要将它传递给一个 <code>Thread</code> 对象然后启动该线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当调用 <code>thread.start()</code> 时，新的线程会启动并执行 <code>run</code> 方法中定义的代码。</p><h3 id="优点">优点</h3><p>使用 <code>Runnable</code> 接口的主要优点是它更加灵活。由于Java不支持多重继承，如果你已经继承了另一个类，就不能再继承 <code>Thread</code> 类。但你仍然可以实现 <code>Runnable</code> 接口来定义线程行为。这使得 <code>Runnable</code> 成为创建和管理线程的首选方式，尤其是当需要执行多个相同任务的时候，可以重用同一个 <code>Runnable</code> 实例来创建多个 <code>Thread</code> 实例。</p><h3 id="与-Callable-的比较">与 <code>Callable</code> 的比较</h3><p><code>Runnable</code> 接口与 <code>Callable</code> 接口相似，但有一个主要区别：<code>Runnable</code> 的 <code>run</code> 方法不返回值也不抛出异常，而 <code>Callable</code> 的 <code>call</code> 方法可以返回值并且可以抛出异常。因此，<code>Callable</code> 通常与 <code>Future</code> 结合使用，可以获取异步计算的结果。</p><p><code>Runnable</code> 通常用于那些不需要返回结果的场景，例如，只是简单地运行一些后台任务，比如日志记录、监控文件系统变化等。</p><h2 id="Threading-in-Android">Threading in Android</h2><p>Threads are three types in Android:</p><p>UI Thread</p><ul><li>Main thread: Excuting Android components and updating UI elements</li><li></li></ul><p>Binder Thread</p><ul><li>Commnuciate between threads in different processes</li><li>each process has a thread pool for incoming requests</li></ul><p>Background Thread</p><ul><li>App-created threads - Worker thread</li><li>Descendants of UI thread</li></ul><p>In Android, both processes and threads are fundamental units of execution, but they serve different roles:</p><h3 id="Process-in-Android">Process in Android:</h3><ul><li>Each Android app runs in its own process, which is an instance of a Linux process.</li><li>Processes are isolated by the Android runtime, meaning that one process cannot normally access the memory of another process.</li><li>Each process has its own virtual machine (VM), so code from one app cannot directly affect the code of another app.</li><li>Processes are a heavy-weight unit of execution in terms of system resources.</li></ul><h3 id="Thread-in-Android">Thread in Android:</h3><ul><li><p>Inside each Android app process, multiple threads can be created.</p></li><li><p>Threads are lighter-weight units of execution that share the same memory space within the process.</p></li><li><p>Threads within the same process can communicate with each other more easily than between processes.</p></li><li><p><strong>All threads of an application are in the same Linux process, but each thread can perform different tasks in parallel.</strong></p><p>threads from one app do indeed compete with all other threads on the device for CPU resources. Here’s how it works:</p><ol><li><strong>CPU Scheduling:</strong><br>The operating system’s scheduler manages all threads on the device, regardless of their originating process. The scheduler decides which threads to run, when to run them, and for how long, based on various factors such as thread priorities, CPU affinity, and other scheduling policies.</li><li><strong>Thread Priorities:</strong><br>Each thread has a priority that influences its scheduling. The Linux kernel uses these priorities to decide which threads should be allocated CPU time. In Android, the main thread, or UI thread, of an app typically has a higher priority because it must remain responsive to user input.</li><li><strong>Concurrency:</strong><br>Modern devices typically have multiple CPU cores, allowing true parallel execution of threads. However, when the number of active threads exceeds the number of available CPU cores, the scheduler has to allocate time slices for each thread to share the CPU resources, which is where the competition comes into play.</li><li><strong>Resource Sharing:</strong><br>Even though threads within an app share the same memory space and resources of their parent process, they still need to use shared system resources such as the CPU and memory. This sharing necessitates competition among all threads on the device.</li><li><strong>Fairness and Responsiveness:</strong><br>The scheduler in the operating system aims to balance fairness (giving each thread a chance to run) with responsiveness (ensuring that high-priority threads, like those handling user interface interactions, are given preference). Android’s scheduler also includes considerations to minimize the impact of background applications on the foreground application’s performance.</li><li><strong>Background vs. Foreground:</strong><br>Android tries to give more CPU time to the foreground app to ensure a smooth user experience. Background apps have their threads scheduled with lower priority compared to the threads of the foreground app.</li></ol><p>In conclusion, while threads are conceptually within the scope of their own app’s process, they are indeed competing with threads from other apps and system processes for CPU time. The operating system’s scheduler is responsible for managing this competition in a way that aims to be fair and maintain a responsive system.</p></li></ul><h3 id="Competition-and-Scheduling">Competition and Scheduling:</h3><ul><li>Threads do not compete across different processes for execution time. Instead, the Linux kernel scheduler decides which process gets time on the CPU. Within each process, the threads are scheduled for execution time based on thread priority and other factors.</li><li>When a thread is created in Android, it competes for CPU time with all other threads within the same priority level across all processes on the device. The scheduler, based on various criteria, decides which thread runs next.</li><li>The main UI thread (also known as the main thread) is the default thread that handles all UI operations and is created when an Android app starts. It must remain responsive to avoid Application Not Responding (ANR) errors.</li></ul><h3 id="Android’s-Thread-Management">Android’s Thread Management:</h3><ul><li>Android does enforce some rules and best practices to manage threads efficiently:<ul><li>CPU-intensive or blocking operations should not be performed on the main UI thread but rather on background threads.</li><li>The <code>AsyncTask</code> class, <code>HandlerThread</code>, and other concurrency constructs such as <code>java.util.concurrent</code> package classes can be used to perform tasks on background threads and communicate back to the main thread for UI updates.</li><li>Starting from Android 5.0 (API level 21), the <code>JobScheduler</code> class allows you to schedule tasks or work across multiple threads with conditions (like network availability).</li></ul></li></ul><p>In summary, while each Android app runs in its own process, it can create multiple threads. These threads do compete for CPU resources with threads from other apps, but the competition is managed by the operating system’s scheduler. The main thread in each app is special and should be kept free from blocking operations to maintain a responsive user interface.</p><h2 id="AsynchTask">AsynchTask</h2><p>![Untitled 6](/posts/CS5520-Week5/Untitled 6.png)</p><p>![Untitled 7](/posts/CS5520-Week5/Untitled 7.png)</p><h2 id="Broadcast-Receivers">Broadcast Receivers</h2><p>allows to be notified when an event occurs</p><ul><li>complete tasks in less than 10 seconds</li><li>often use with initializing a service</li></ul><p>![Untitled 8](/posts/CS5520-Week5/Untitled 8.png)</p><p>Alarm Manager to allow the broadcastreceiver to run in the future - use case: update new headlines</p><p>In Android, <code>IntentFilter</code> and <code>BroadcastReceiver</code> are components used in the context of inter-process communication. They work together to allow an application to receive intents that are broadcast by the system or other applications.</p><h3 id="BroadcastReceiver">BroadcastReceiver</h3><p>A <code>BroadcastReceiver</code> is an Android component that responds to broadcast messages from other applications or from the system itself. These messages are wrapped in <code>Intent</code> objects. Broadcasts can be used to deliver many kinds of events to applications that aren’t necessarily running at the time of the broadcast. For example, an application can register to receive system events, like when the Android device boots up, when the battery is low, or when the user has taken a picture.</p><p>Here’s a simple example of a <code>BroadcastReceiver</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> {</span><br><span class="line">        <span class="comment">// Handle the received broadcast event.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BOOT_COMPLETED.equals(action)) {</span><br><span class="line">            <span class="comment">// The device has finished booting</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="IntentFilter">IntentFilter</h3><p>An <code>IntentFilter</code> specifies the types of intents that a <code>BroadcastReceiver</code> can respond to. It declares the capabilities of a <code>BroadcastReceiver</code>, filtering out intents that are of not interest to the receiver. An <code>IntentFilter</code> can be declared in code or in the AndroidManifest.xml file.</p><p>For example, an <code>IntentFilter</code> can be set up to listen for a boot completion event like this:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_BOOT_COMPLETED);</span><br><span class="line"><span class="type">MyBroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBroadcastReceiver</span>();</span><br><span class="line">registerReceiver(receiver, filter);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Or in the AndroidManifest.xml:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>In this example, the <code>MyBroadcastReceiver</code> is set up to listen for the system’s boot completion broadcast. When the system sends an intent with the action <code>ACTION_BOOT_COMPLETED</code>, <code>MyBroadcastReceiver</code> will receive it because of the matching intent filter.</p><h3 id="Registration">Registration</h3><p><code>BroadcastReceivers</code> can be registered in two ways:</p><ol><li><strong>Static Registration:</strong> This is done in the AndroidManifest.xml file. The system knows about the receiver from the app’s installation time, and the receiver can be called to respond to events even if the app is not currently running.</li><li><strong>Dynamic Registration:</strong> This happens at runtime within the app’s code. The app must be running to register the receiver, often done in an activity or service. When the app is not running or is killed, the receiver does not receive broadcasts.</li></ol><p>When using broadcast receivers, especially for listening to system-wide broadcasts, it is important to consider the performance implications and the best practices for registering and using receivers, as unnecessary use of broadcasts can negatively impact the performance of the application and the overall device.</p><p>The <code>onReceive()</code> method of a <code>BroadcastReceiver</code> is where you handle the logic that should be executed when the broadcast intent is received. The actions taken can vary greatly depending on the intent’s action and the app’s functionality.</p><p>Let’s say we have an application that needs to schedule some data synchronization after the device finishes booting. The logic inside <code>onReceive()</code> for handling <code>Intent.ACTION_BOOT_COMPLETED</code> could look something like this:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootCompletedReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> {</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {</span><br><span class="line">            <span class="comment">// Schedule data synchronization</span></span><br><span class="line">            scheduleDataSync(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleDataSync</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="comment">// Assuming you have a method to schedule jobs</span></span><br><span class="line">        <span class="comment">// This could be using JobScheduler, WorkManager, or any other scheduling mechanism</span></span><br><span class="line">        DataSyncScheduler.schedule(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let's say we also want to send a notification to the user after boot</span></span><br><span class="line">        sendBootNotification(context, <span class="string">"Device Ready"</span>, <span class="string">"Your device is ready and data sync will start soon."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendBootNotification</span><span class="params">(Context context, String title, String text)</span> {</span><br><span class="line">        <span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (notificationManager == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the NotificationChannel, but only on API 26+ because</span></span><br><span class="line">        <span class="comment">// the NotificationChannel class is new and not in the support library</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span><br><span class="line">            <span class="type">CharSequence</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"boot_channel"</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">"Notifications after boot"</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">importance</span> <span class="operator">=</span> NotificationManager.IMPORTANCE_DEFAULT;</span><br><span class="line">            <span class="type">NotificationChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(<span class="string">"boot"</span>, name, importance);</span><br><span class="line">            channel.setDescription(description);</span><br><span class="line">            <span class="comment">// Register the channel with the system</span></span><br><span class="line">            notificationManager.createNotificationChannel(channel);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        NotificationCompat.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(context, <span class="string">"boot"</span>)</span><br><span class="line">                .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">                .setContentTitle(title)</span><br><span class="line">                .setContentText(text)</span><br><span class="line">                .setPriority(NotificationCompat.PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Issue the notification.</span></span><br><span class="line">        notificationManager.notify(<span class="number">0</span>, builder.build());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>In the provided code snippet:</p><ol><li>When the <code>ACTION_BOOT_COMPLETED</code> event is received, <code>scheduleDataSync()</code> is called to schedule a data synchronization task. This could be done using Android’s <code>JobScheduler</code>, <code>AlarmManager</code>, or <code>WorkManager</code> APIs.</li><li>A notification is sent to the user indicating that the device has booted and data synchronization will start soon. This is handled by <code>sendBootNotification()</code> method.</li></ol><p>Remember, the <code>onReceive()</code> method runs on the main thread of your application, and you should not perform long-running operations there. If you need to do substantial work, start a service or use <code>WorkManager</code> to offload that work to a background thread. Also, <code>onReceive()</code> has a time limit of about 10 seconds; exceeding this limit can result in the app being killed by the system.</p>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week6-Networking</title>
      <link href="/posts/CS5520-Week6/"/>
      <url>/posts/CS5520-Week6/</url>
      
        <content type="html"><![CDATA[<h1>Week 6 - Networking and Connectivity</h1><h2 id="Understanding-Android-Networking">Understanding Android Networking</h2><p>Data Transfer for Android</p><p>Pulling data from a network location to a device</p><p>sending data from device to a network location</p><p>How they connect?</p><p>Difference in WIFI or Cellular:</p><p>Power Consumption</p><p>Speed</p><p>Cost</p><p>Availability</p><h2 id="Example">Example</h2><h3 id="Embedded-Webview">Embedded Webview</h3><p>Implement web view to display HTML content</p><ol><li>webview client<ol><li>override the default behavior for loading URLs</li></ol></li></ol><p>a <strong><code>WebView</code></strong> is a component that allows you to display web pages inside your application. It acts like a mini web browser within your app, enabling you to render HTML, JavaScript, and CSS content. This is particularly useful for displaying content online or for incorporating web-based interfaces within a native Android application.</p><p>The <strong><code>WebView</code></strong> class is part of the <strong><code>android.webkit</code></strong> package and provides various methods to manage and control the behavior of the web content it displays. You can use it to load URLs or HTML content directly, control navigation, and interact with web pages.</p><p>A <strong><code>WebViewClient</code></strong> is a class that helps to handle various events within a <strong><code>WebView</code></strong>, such as page loading, finishing, errors, and URL redirections. By extending the <strong><code>WebViewClient</code></strong> class and overriding its methods, developers can provide custom behavior for these events instead of relying on the default behavior. For example, you might override <strong><code>onPageStarted</code></strong> to show a loading spinner when a new page starts loading and <strong><code>onPageFinished</code></strong> to hide the spinner once the page has fully loaded.</p><p>some key methods within <strong><code>WebViewClient</code></strong>:</p><ul><li><strong><code>onPageStarted(WebView view, String url, Bitmap favicon)</code></strong>: This method is called when the page starts loading.</li><li><strong><code>onPageFinished(WebView view, String url)</code></strong>: This method is called when the page finishes loading.</li><li><strong><code>shouldOverrideUrlLoading(WebView view, String url)</code></strong>: This method allows you to take control when a new URL is about to be loaded in the current WebView. You can decide whether you want to load it within the WebView or in a different browser.</li></ul><p>Using <strong><code>WebViewClient</code></strong> is essential for creating a seamless web experience within your app, as it allows you to handle web-related events and customize the interaction according to your application’s requirements.</p><h3 id="Code-Demo">Code Demo</h3><p><img src="/posts/CS5520-Week6/Untitled.png" alt="Untitled"></p><p>mWebView.setWebViewClient() Override 的作用是使得url不会redirect去其他browser而是在这个软件本身里load</p><h3 id="Web-Service">Web Service</h3><p>Android provides HTTP URL connections</p><p>Use threads for running async</p><h3 id="Code-Demo-for-Interacting-with-Web-Service">Code Demo for Interacting with Web Service</h3><p>![Untitled](/posts/CS5520-Week6/Untitled 1.png)</p><p>![Untitled](/posts/CS5520-Week6/Untitled 2.png)</p><p>![Untitled](/posts/CS5520-Week6/Untitled 3.png)</p><p>![Untitled](/posts/CS5520-Week6/Untitled 4.png)</p><p>![Untitled](/posts/CS5520-Week6/Untitled 5.png)</p><p>This is a callback, override this to let result shows.</p><p><strong><code>onPostExecute</code></strong> 是 Android <strong><code>AsyncTask</code></strong> 类的一个回调方法，用于在后台任务完成后处理后台计算的结果。<strong><code>AsyncTask</code></strong> 是 Android 提供的一个用于简化在后台线程上执行任务并在主线程上更新UI的类。虽然从Android 11开始，<strong><code>AsyncTask</code></strong> 被标记为废弃（deprecated），但理解其工作原理对于了解Android的异步编程模型仍然很有价值。</p><h3 id="工作流程"><strong>工作流程</strong></h3><ol><li><strong><code>onPreExecute()</code></strong>：在主线程上执行，通常用于设置任务开始之前的UI，如显示进度条。</li><li><strong><code>doInBackground(Params...)</code></strong>：在后台线程上执行，用于执行耗时的计算。不能在此方法中直接更新UI。</li><li><strong><code>onProgressUpdate(Progress...)</code></strong>：在主线程上执行，用于更新任务进度。需要从**<code>doInBackground</code><strong>方法中调用</strong><code>publishProgress(Progress...)</code>**来触发。</li><li><strong><code>onPostExecute(Result)</code></strong>：在主线程上执行，用于处理后台计算的结果并更新UI。此方法的参数是**<code>doInBackground</code>**方法的返回值。</li></ol><h3 id="onPostExecute-详解"><strong><code>onPostExecute</code> 详解</strong></h3><ul><li><strong>执行线程</strong>：**<code>onPostExecute(Result result)</code>**方法在主线线程（UI线程）上执行，确保了安全地更新UI组件。</li><li><strong>参数</strong>：**<code>Result</code><strong>是</strong><code>doInBackground(Params...)</code>**方法的返回值，代表后台操作的结果。</li><li><strong>用途</strong>：通常用于在后台任务完成后，根据后台计算的结果更新UI，例如填充列表数据、更改视图状态或显示计算结果。</li><li><strong>注意事项</strong>：由于**<code>onPostExecute</code>**在主线程上执行，因此不应在此方法中执行任何耗时的操作，以免阻塞UI线程。</li></ul><p>你的理解是对的，<strong><code>onPostExecute</code><strong>确实是一个在执行后的回调，用于根据后台任务的结果来更新UI。但随着</strong><code>AsyncTask</code><strong>的废弃，现在推荐使用其他现代的异步处理机制，如</strong><code>java.util.concurrent</code><strong>包下的类（例如</strong><code>ExecutorService</code></strong>），或者是**<code>Kotlin</code>**协程来处理异步任务和UI更新。</p><p>![Untitled](/posts/CS5520-Week6/Untitled 6.png)</p><p>conn.setDoInput() retrive from serverå</p><h2 id="Being-Power-Aware-when-updating">Being Power-Aware when updating</h2><p>![Untitled](/posts/CS5520-Week6/Untitled 7.png)</p><p>Bundle + Prefetching</p><p>Get data in a bundle / cluster</p><p>Data Saver</p>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week7-Data-Storage</title>
      <link href="/posts/CS5520-Week7/"/>
      <url>/posts/CS5520-Week7/</url>
      
        <content type="html"><![CDATA[<h1>Week 7 Data Storage and Retrieval Module</h1><p>Strict Mode, SQLite</p><h2 id="Strict-Mode">Strict Mode</h2><p>It is a mode to help find problems in code where things on the main thread works not as expected. This includes dis access, database access or network access.</p><p><img src="/posts/CS5520-Week7/Untitled.png" alt="Untitled"></p><p>其实就是进入一个log模式来输出详细的log</p><h2 id="SQLite">SQLite</h2><p>![Untitled 1](/posts/CS5520-Week7/Untitled 1.png)</p><p>![Untitled 2](/posts/CS5520-Week7/Untitled 2.png)</p><h3 id="SQLite-with-ADB-Android-Debug-Bridge">SQLite with ADB (Android Debug Bridge)</h3><ol><li>Select a virtial devices that not play store support<ol><li>不然不能使用super user (su)</li></ol></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb -e shell (-e 是emulator)</span><br><span class="line">su</span><br><span class="line">找到 package name 对应的文件夹 （under /data/data)</span><br><span class="line">找到database文件夹</span><br><span class="line">找 *.db 文件 </span><br><span class="line">sqlite3 *.db</span><br><span class="line">&gt; SQL 操作</span><br><span class="line">&gt; .<span class="built_in">exit</span> 退出</span><br></pre></td></tr></tbody></table></figure><h2 id="SQLite-with-Device-File-Explorer">SQLite with Device File Explorer</h2><p>Android Studio → View → Tool Windows → Device File Explorer</p><p>先下载到本地然后使用其他的工具打开 （有必要吗？晕了）</p><h2 id="Android-Room-Persistence-Library">Android Room Persistence Library</h2><p>The Android Room Persistence Library provides a high level interface on top of SQLite. It is worth using SQLite directly so that you get an understanding of what is underneath it all before you begin using the high level interface.</p>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS5520-Week8-Firebase</title>
      <link href="/posts/CS5520-Week8/"/>
      <url>/posts/CS5520-Week8/</url>
      
        <content type="html"><![CDATA[<h1>Week 8 - Firebase</h1><h1>Introduction to Firebase</h1><p>firebase is a framework that provides backend data capabilities:</p><p>cloud messaging, user authentication, etc</p><h2 id="Firebase-cloud-messaging">Firebase cloud messaging</h2><p>A capability that sends messages to android devices that have your firebase enabled app installed</p><p>Firebase Cloud Messaging (FCM) 是一个跨平台的消息传递解决方案，可以让你可靠地发送通知和消息到Android、iOS和网页应用上。</p><p>在FCM中，"system tray"通常指的是Android设备上的通知栏。当应用程序在后台或者完全关闭的状态下收到通知时，这些通知会显示在设备的系统托盘中，也就是屏幕顶部的下拉通知栏。用户可以在这里看到各种通知信息，并且可以从系统托盘中直接打开对应的通知，通常会打开应用程序的某个特定界面或执行某些操作。</p><p>具体到FCM，这意味着当一个通知消息被发送到一个设备并且该应用程序不在前台运行时，这个通知将会显示在系统托盘中，而不是直接通过应用程序打开一个界面或活动（Activity）。这种类型的通知被称为“通知消息”（notification message），与“数据消息”（data message）相对，后者即使应用在后台也可以被应用程序的代码接收和处理。</p><p><img src="/posts/CS5520-Week8/Untitled.png" alt="Untitled"></p><h3 id="instance-ID">instance ID</h3><p>Identifies a single app instance.</p><p>Developer需要去记录和track instanceID</p><p>开发者需要记录和跟踪 Instance ID（或现在通常称为FCM注册令牌）的原因主要是为了实现目标推送。这意味着，当你想要向特定的用户或设备发送消息时，你需要知道它们的注册令牌。例如，如果你正在开发一个即时消息应用，你需要能够向特定用户发送消息，这时你就需要知道用户设备的令牌。</p><p>记录和跟踪令牌通常涉及以下步骤：</p><ol><li><strong>获取和存储令牌</strong>：当应用在用户设备上安装并首次运行时，FCM SDK 会生成一个注册令牌。你的应用需要监听令牌生成事件，并将其上传到你的服务器。</li><li><strong>更新令牌</strong>：令牌可能会因为应用重新安装、用户清除应用数据、操作系统更新等原因更改。FCM SDK 会在令牌更改时通知你的应用。你的应用需要监听这些更改，并更新服务器上的记录。</li><li><strong>维护令牌关联</strong>：你需要确保用户的账户信息和注册令牌之间的映射是最新的。这通常意味着在用户登录、登出、注册设备或更改设备时更新服务器上的记录。</li><li><strong>安全性</strong>：因为令牌是向特定设备发送信息的关键，所以必须确保这些数据的传输和存储是安全的。</li></ol><p>关于新的令牌管理系统，Firebase 逐渐推出了一些改进，以简化令牌管理过程。这些改进可能包括自动令牌刷新和简化的API来处理令牌。Firebase建议使用FCM SDK的最新版本，以确保你的应用可以利用这些改进。</p><p><strong><code>InstanceID</code></strong> 被用来获取FCM注册令牌，但是现在通常推荐的做法是直接使用由 <strong><code>FirebaseMessaging</code></strong> 服务提供的令牌。<strong><code>FirebaseInstanceId</code></strong> 类和相关的API已经被弃用，因为FirebaseMessaging服务现在提供了获取和刷新令牌的功能。</p><p><strong><code>InstanceID</code></strong> 提供了一种在应用实例之间安全地识别设备的方式。每当一个客户端应用实例注册到接收FCM消息时，它都会获得一个唯一的ID，即 <strong><code>InstanceID</code></strong>。这个 <strong><code>InstanceID</code></strong> 表示的是一个应用实例在一个设备上的身份，并且通常与一个应用的注册令牌（registration token）相关联。</p><p>每一个app有一个instanceID</p><p>![Untitled 1](/posts/CS5520-Week8/Untitled 1.png)</p><h2 id="Database-for-Firebase-Realtime-Database">Database for Firebase Realtime Database</h2><p>Firebase提供了两种主要的数据库选项：Cloud Firestore和Firebase Realtime Database。它们都是NoSQL数据库，用于存储和同步客户端和服务器之间的数据，但它们在数据模型、查询能力、数据同步等方面有显著的不同。</p><p>以下是两者的主要区别：</p><p><strong>Cloud Firestore:</strong></p><ol><li><strong>数据模型</strong>：Firestore是一个文档-集合数据库。数据被存储在文档中，文档再被组织在集合中。每个文档可以包含复杂的数据类型，并且可以包含子集合。</li><li><strong>查询</strong>：Firestore支持更复杂的查询。你可以进行多字段排序和复合查询，而不需要在客户端进行额外的过滤。</li><li><strong>扩展</strong>：Firestore是设计来自动扩展的，它适用于更大规模的应用程序。</li><li><strong>离线支持</strong>：Firestore提供了内置的离线支持。即使设备没有网络连接，应用程序也可以从缓存中读取和写入数据。</li><li><strong>价格</strong>：计费基于读取、写入和删除操作的次数，以及存储的数据量和网络带宽。</li><li><strong>数据一致性和事务</strong>：Firestore提供了强一致性的读写操作和复杂的事务支持。</li></ol><p><strong>Firebase Realtime Database:</strong></p><ol><li><strong>数据模型</strong>：Realtime Database是一个大的JSON树。它非常适合简单的数据，但不适合层次结构很深的数据。</li><li><strong>查询</strong>：查询功能较基础。如果你需要进行复杂的查询，可能需要在客户端进行额外的数据处理。</li><li><strong>实时同步</strong>：Realtime Database的特点是可以快速同步数据。所有的客户端都可以几乎实时地看到数据的更新。</li><li><strong>离线支持</strong>：虽然也支持离线操作，但是需要手动配置和管理。</li><li><strong>价格</strong>：计费基于网络带宽和存储的数据量，而不是操作的次数。</li><li><strong>数据一致性和事务</strong>：提供了基本的事务支持，数据一致性在分布式系统中可能稍微弱一些。</li></ol><p><strong>选择哪一个?</strong><br>选择使用Firestore还是Realtime Database取决于你的特定需求。如果你需要更复杂的查询和更强的数据结构，或者你的应用程序需要自动扩展以支持更多的用户，Firestore可能是更好的选择。如果你的应用程序需要高性能的实时同步，Realtime Database可能更合适。</p><h2 id="Code-Demo">Code Demo</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.neu.madcourse.firebasedemo.realtimedatabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.RadioButton;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.android.gms.tasks.Task;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.ChildEventListener;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.DataSnapshot;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.DatabaseError;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.DatabaseReference;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.FirebaseDatabase;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.MutableData;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.Transaction;</span><br><span class="line"><span class="keyword">import</span> com.google.firebase.database.ValueEventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.neu.madcourse.firebasedemo.R;</span><br><span class="line"><span class="keyword">import</span> edu.neu.madcourse.firebasedemo.realtimedatabase.models.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Here, we will demonstrate the use of Firebase Realtime DB which syncs your data across different</span></span><br><span class="line"><span class="comment"> * devices that are accessing the same DB in realtime.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealtimeDatabaseActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> RealtimeDatabaseActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FirebaseDatabase mDatabase;</span><br><span class="line">    <span class="keyword">private</span> TextView user1;</span><br><span class="line">    <span class="keyword">private</span> TextView score_user1;</span><br><span class="line">    <span class="keyword">private</span> TextView user2;</span><br><span class="line">    <span class="keyword">private</span> TextView score_user2;</span><br><span class="line">    <span class="keyword">private</span> RadioButton player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint("RestrictedApi")</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> {</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_realtime_database);</span><br><span class="line"></span><br><span class="line">        user1 = (TextView) findViewById(R.id.username1);</span><br><span class="line">        user2 = (TextView) findViewById(R.id.username2);</span><br><span class="line">        score_user1 = (TextView) findViewById(R.id.score1);</span><br><span class="line">        score_user2 = (TextView) findViewById(R.id.score2);</span><br><span class="line">        player = (RadioButton) findViewById(R.id.player1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect with firebase</span></span><br><span class="line">        mDatabase = FirebaseDatabase.getInstance();</span><br><span class="line">        <span class="comment">// The documentation mentions that you do not need to add the URL if your location is</span></span><br><span class="line">        <span class="comment">// us-central1, but at times it does not work. If it does not work, then add the url of your</span></span><br><span class="line">        <span class="comment">// db in the getInstance() call. eg: getInstance("https://testfirebase-default-rtdb.firebaseio.com/")</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the score in realtime</span></span><br><span class="line">        mDatabase.getReference().child(<span class="string">"users"</span>).addChildEventListener(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChildEventListener</span>() {</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildAdded</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line">                        showScore(dataSnapshot);</span><br><span class="line">                        Log.e(TAG, <span class="string">"onChildAdded: dataSnapshot = "</span> + dataSnapshot.getValue().toString());</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildChanged</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line">                        showScore(dataSnapshot);</span><br><span class="line">                        Log.v(TAG, <span class="string">"onChildChanged: "</span> + dataSnapshot.getValue().toString());</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildRemoved</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot)</span> {</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildMoved</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancelled</span><span class="params">(<span class="meta">@NonNull</span> DatabaseError databaseError)</span> {</span><br><span class="line">                        Log.e(TAG, <span class="string">"onCancelled:"</span> + databaseError);</span><br><span class="line">                        Toast.makeText(getApplicationContext()</span><br><span class="line">                                , <span class="string">"DBError: "</span> + databaseError, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add 5 points Button</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFivePoints</span><span class="params">(View view)</span> {</span><br><span class="line">        RealtimeDatabaseActivity.<span class="built_in">this</span>.onAddScore(mDatabase.getReference(), player.isChecked() ? <span class="string">"user1"</span> : <span class="string">"user2"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method resets the scores of both the players back to 0 on the DB as well as the app.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view the button reference from the XML file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetUsers</span><span class="params">(View view)</span> {</span><br><span class="line"></span><br><span class="line">        User user;</span><br><span class="line">        user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"user1"</span>, <span class="string">"0"</span>);</span><br><span class="line">        Task&lt;Void&gt; t1 = mDatabase.getReference().child(<span class="string">"users"</span>).child(user.username).setValue(user);</span><br><span class="line"></span><br><span class="line">        user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"user2"</span>, <span class="string">"0"</span>);</span><br><span class="line">        Task&lt;Void&gt; t2 = mDatabase.getReference().child(<span class="string">"users"</span>).child(user.username).setValue(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!t1.isSuccessful() &amp;&amp; !t2.isSuccessful()){</span><br><span class="line">            Toast.makeText(getApplicationContext(),<span class="string">"Unable to reset players!"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!t1.isSuccessful() &amp;&amp; t2.isSuccessful()){</span><br><span class="line">            Toast.makeText(getApplicationContext(),<span class="string">"Unable to reset player1!"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1.isSuccessful() &amp;&amp; t2.isSuccessful()){</span><br><span class="line">            Toast.makeText(getApplicationContext(),<span class="string">"Unable to reset player2!"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add data to firebase button</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAddDataToDb</span><span class="params">(View view)</span> {</span><br><span class="line">        <span class="comment">// Write a message to the database</span></span><br><span class="line">        <span class="type">DatabaseReference</span> <span class="variable">myRef</span> <span class="operator">=</span> mDatabase.getReference(<span class="string">"message"</span>);</span><br><span class="line"></span><br><span class="line">        Task&lt;Void&gt; t = myRef.setValue(<span class="string">"Hello, World!"</span>);</span><br><span class="line"></span><br><span class="line">        t.addOnCompleteListener(task -&gt; {</span><br><span class="line">            <span class="keyword">if</span>(!t.isSuccessful()){</span><br><span class="line">                Toast.makeText(getApplicationContext()</span><br><span class="line">                        , <span class="string">"Failed to write value into firebase. "</span> , Toast.LENGTH_SHORT).show();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                Toast.makeText(getApplicationContext()</span><br><span class="line">                        , <span class="string">"Write Successful."</span> , Toast.LENGTH_SHORT).show();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read from the database by listening for a change to that item.</span></span><br><span class="line">        myRef.addValueEventListener(<span class="keyword">new</span> <span class="title class_">ValueEventListener</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataChange</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot)</span> {</span><br><span class="line">                <span class="comment">// This method is called once with the initial value and again</span></span><br><span class="line">                <span class="comment">// whenever data at this location is updated.</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> dataSnapshot.getValue(String.class);</span><br><span class="line">                Log.d(TAG, <span class="string">"Value is: "</span> + value);</span><br><span class="line">                <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> (TextView) findViewById(R.id.dataUpdateTextView);</span><br><span class="line">                tv.setText(value);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancelled</span><span class="params">(<span class="meta">@NonNull</span> DatabaseError error)</span> {</span><br><span class="line">                <span class="comment">// Failed to read value</span></span><br><span class="line">                Log.w(TAG, <span class="string">"Failed to read value."</span>, error.toException());</span><br><span class="line">                Toast.makeText(getApplicationContext()</span><br><span class="line">                        , <span class="string">"Failed to write value into firebase. "</span> , Toast.LENGTH_SHORT).show();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method represents adding 5 points to the score of the specified player.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postRef   a reference of the database</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user      String specifying whether it is user 1 or 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onAddScore</span><span class="params">(DatabaseReference postRef, String user)</span> {</span><br><span class="line">        postRef</span><br><span class="line">                .child(<span class="string">"users"</span>)</span><br><span class="line">                .child(user)</span><br><span class="line">                .runTransaction(<span class="keyword">new</span> <span class="title class_">Transaction</span>.Handler() {</span><br><span class="line">                    <span class="meta">@NonNull</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Transaction.Result <span class="title function_">doTransaction</span><span class="params">(<span class="meta">@NonNull</span> MutableData mutableData)</span> {</span><br><span class="line"></span><br><span class="line">                        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mutableData.getValue(User.class);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">                            <span class="keyword">return</span> Transaction.success(mutableData);</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        user.score = String.valueOf(Integer.parseInt(user.score) + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                        mutableData.setValue(user);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Transaction.success(mutableData);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(DatabaseError databaseError, <span class="type">boolean</span> successful,</span></span><br><span class="line"><span class="params">                                           DataSnapshot dataSnapshot)</span> {</span><br><span class="line">                        <span class="comment">// Transaction completed</span></span><br><span class="line">                        Log.d(TAG, <span class="string">"postTransaction:onComplete:"</span> + databaseError);</span><br><span class="line">                        <span class="keyword">if</span> (successful) {</span><br><span class="line">                            Toast.makeText(RealtimeDatabaseActivity.<span class="built_in">this</span>,</span><br><span class="line">                                    <span class="string">"Score Updated"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            Toast.makeText(RealtimeDatabaseActivity.<span class="built_in">this</span></span><br><span class="line">                                    , <span class="string">"DBError: "</span> + databaseError, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Displays the score using the DataSnapshot object by getting the "User" object corresponding</span></span><br><span class="line"><span class="comment">     * values from it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSnapshot  Immutable copies of the data at a Firebase Database location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showScore</span><span class="params">(DataSnapshot dataSnapshot)</span> {</span><br><span class="line">        <span class="comment">//Getting the user object corresponding value from the dataSnapshot</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> dataSnapshot.getValue(User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSnapshot.getKey() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//Appropriately updating the score of the user by querying on the name of the user.</span></span><br><span class="line">            <span class="keyword">if</span> (dataSnapshot.getKey().equalsIgnoreCase(<span class="string">"user1"</span>)) {</span><br><span class="line">                score_user1.setText(String.valueOf(user.score));</span><br><span class="line">                user1.setText(user.username);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                score_user2.setText(String.valueOf(user.score));</span><br><span class="line">                user2.setText(user.username);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码是使用Firebase Realtime Database的Android客户端库进行实时数据同步的示例。它展示了如何连接到Firebase数据库，并且设置了一个监听器来监听数据的变化。以下是代码逐行解释：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect with firebase</span></span><br><span class="line">mDatabase = FirebaseDatabase.getInstance();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这行代码获取了 <code>FirebaseDatabase</code> 的一个实例。这是与Firebase Realtime Database进行交互的入口点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The documentation mentions that you do not need to add the URL if your location is</span></span><br><span class="line"><span class="comment">// us-central1, but at times it does not work. If it does not work, then add the url of your</span></span><br><span class="line"><span class="comment">// db in the getInstance() call. eg: getInstance("&lt;https://testfirebase-default-rtdb.firebaseio.com/&gt;")</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这段注释解释了通常情况下如果你的数据库位于us-central1（一个常用的Firebase地区），你不需要在 <code>getInstance()</code> 方法中提供数据库的URL。但是如果默认的方式不起作用，你可能需要直接提供数据库的完整URL。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the score in realtime</span></span><br><span class="line">mDatabase.getReference().child(<span class="string">"users"</span>).addChildEventListener(</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这行代码设置了一个指向数据库中 <code>"users"</code> 节点的引用，并为它添加了一个 <code>ChildEventListener</code>。这意味着任何在 <code>"users"</code> 节点下的子节点发生的变化都会通知这个监听器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ChildEventListener</span>() {</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这行代码创建了 <code>ChildEventListener</code> 的一个匿名类实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildAdded</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line">    showScore(dataSnapshot);</span><br><span class="line">    Log.e(TAG, <span class="string">"onChildAdded: dataSnapshot = "</span> + dataSnapshot.getValue().toString());</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当一个新的子节点被添加到 <code>"users"</code> 下时，<code>onChildAdded</code> 方法会被调用。它接收一个 <code>DataSnapshot</code> 对象，包含了被添加的子节点的数据。这里它调用了一个 <code>showScore</code> 方法（未在代码中显示）来处理新添加的数据，并且使用 <code>Log.e</code> 记录了一个错误级别的日志。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildChanged</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line">    showScore(dataSnapshot);</span><br><span class="line">    Log.v(TAG, <span class="string">"onChildChanged: "</span> + dataSnapshot.getValue().toString());</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当 <code>"users"</code> 下的某个子节点的数据发生变化时，<code>onChildChanged</code> 方法会被调用。同样地，它使用 <code>DataSnapshot</code> 来获取变化的数据，并调用 <code>showScore</code> 方法来处理变化的数据，然后记录一个详细级别的日志。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildRemoved</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot)</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当 <code>"users"</code> 下的某个子节点被移除时，<code>onChildRemoved</code> 方法会被调用。这里没有实现具体的操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildMoved</span><span class="params">(<span class="meta">@NonNull</span> DataSnapshot dataSnapshot, String s)</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果子节点在列表中的位置发生了变化，<code>onChildMoved</code> 方法会被调用。这通常发生在节点的某个排序属性被修改时。同样，这里没有实现具体的操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancelled</span><span class="params">(<span class="meta">@NonNull</span> DatabaseError databaseError)</span> {</span><br><span class="line">    Log.e(TAG, <span class="string">"onCancelled:"</span> + databaseError);</span><br><span class="line">    Toast.makeText(getApplicationContext(), <span class="string">"DBError: "</span> + databaseError, Toast.LENGTH_SHORT).show();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果监听过程中发生了错误，<code>onCancelled</code> 方法会被调用。这里它记录了一个错误并显示了一个Toast消息给用户。</p><p>整体来说，这段代码演示了如何在Android应用中使用Firebase Realtime Database来监听 <code>users</code> 节点下子节点的增加和变化，并在数据变化时进行一些处理。</p><p>在这段代码中，<strong><code>.child().child()</code></strong> 方法是用来定位和操作 Firebase Realtime Database 中的特定路径或节点的。</p><ul><li><strong><code>.child("users")</code></strong> 定位到数据库中名为 <strong><code>"users"</code></strong> 的节点。这通常是一个顶级节点，包含了所有用户相关的信息。</li><li><strong><code>.child(user)</code></strong> 进一步定位到 <strong><code>"users"</code></strong> 节点下特定用户名对应的子节点。这里的 <strong><code>user</code></strong> 参数应该是一个字符串，表示特定用户的唯一标识符或用户名。</li></ul><h2 id="Notification">Notification</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.neu.madcourse.firebasedemo.notification;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.NotificationChannel;</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager;</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationManagerCompat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.neu.madcourse.firebasedemo.FakeCallActivity;</span><br><span class="line"><span class="keyword">import</span> edu.neu.madcourse.firebasedemo.R;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Upgrade the method based on the latest Android version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendNotificationActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> {</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        createNotificationChannel();</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_send_notification);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNotificationChannel</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// This must be called early because it must be called before a notification is sent.</span></span><br><span class="line">        <span class="comment">// Create the NotificationChannel, but only on API 26+ because</span></span><br><span class="line">        <span class="comment">// the NotificationChannel class is new and not in the support library</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span><br><span class="line">            <span class="type">CharSequence</span> <span class="variable">name</span> <span class="operator">=</span> getString(R.string.channel_name);</span><br><span class="line">            <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> getString(R.string.channel_description);</span><br><span class="line">            <span class="type">int</span> <span class="variable">importance</span> <span class="operator">=</span> NotificationManager.IMPORTANCE_DEFAULT;</span><br><span class="line">            <span class="type">NotificationChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(getString(R.string.channel_id), name, importance);</span><br><span class="line">            channel.setDescription(description);</span><br><span class="line">            <span class="comment">// Register the channel with the system; you can't change the importance</span></span><br><span class="line">            <span class="comment">// or other notification behaviors after this</span></span><br><span class="line">            <span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> getSystemService(NotificationManager.class);</span><br><span class="line">            notificationManager.createNotificationChannel(channel);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(View view)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare intent which is triggered if the</span></span><br><span class="line">        <span class="comment">// notification is selected</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ReceiveNotificationActivity.class);</span><br><span class="line">        <span class="type">PendingIntent</span> <span class="variable">pIntent</span> <span class="operator">=</span> PendingIntent.getActivity(<span class="built_in">this</span>, (<span class="type">int</span>) System.currentTimeMillis(), intent, <span class="number">0</span>);</span><br><span class="line">        <span class="type">PendingIntent</span> <span class="variable">callIntent</span> <span class="operator">=</span> PendingIntent.getActivity(<span class="built_in">this</span>, (<span class="type">int</span>) System.currentTimeMillis(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, FakeCallActivity.class), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build notification</span></span><br><span class="line">        <span class="comment">// Need to define a channel ID after Android Oreo</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">channelId</span> <span class="operator">=</span> getString(R.string.channel_id);</span><br><span class="line">        NotificationCompat.<span class="type">Builder</span> <span class="variable">notifyBuild</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(<span class="built_in">this</span>, channelId)</span><br><span class="line">                <span class="comment">//"Notification icons must be entirely white."</span></span><br><span class="line">                .setSmallIcon(R.drawable.foo)</span><br><span class="line">                .setContentTitle(<span class="string">"New mail from "</span> + <span class="string">"test@test.com"</span>)</span><br><span class="line">                .setContentText(<span class="string">"Subject"</span>)</span><br><span class="line">                .setPriority(NotificationCompat.PRIORITY_HIGH)</span><br><span class="line">                <span class="comment">// hide the notification after its selected</span></span><br><span class="line">                .setAutoCancel(<span class="literal">true</span>)</span><br><span class="line">                .addAction(R.drawable.foo, <span class="string">"Call"</span>, callIntent)</span><br><span class="line">                .setContentIntent(pIntent);</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationManagerCompat</span> <span class="variable">notificationManager</span> <span class="operator">=</span> NotificationManagerCompat.from(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// // notificationId is a unique int for each notification that you must define</span></span><br><span class="line">        notificationManager.notify(<span class="number">0</span>, notifyBuild.build());</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在Android O（API 级别 26）及更高版本中，<code>NotificationChannel</code>（通知渠道）是一种重要的概念，它为用户提供了更丰富的控制通知的能力。通过使用通知渠道，应用可以将通知分组，并允许用户对这些不同类型的通知进行细致的控制。这意味着用户可以根据自己的需要调整每个通知渠道的重要性级别、声音、振动等设置。</p><p><strong>为什么需要<code>NotificationChannel</code>？</strong></p><p>随着应用越来越复杂，它们需要向用户发送多种类型的通知，如消息提醒、进度更新、动作提示等。在Android O之前，所有的通知设置都是全局应用的，用户无法根据通知的类型进行个性化设置。<code>NotificationChannel</code>的引入解决了这个问题，使用户能够根据自己的偏好来管理通知。</p><p><strong>如何使用<code>NotificationChannel</code>？</strong></p><ol><li><strong>创建通知渠道</strong>：当应用运行在Android O及更高版本上时，你需要创建一个或多个<code>NotificationChannel</code>实例，并将其提交给系统。每个通知渠道都有一个唯一的ID和用户可见的名称。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span><br><span class="line">    <span class="type">CharSequence</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"My Channel"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">"Channel Description"</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">importance</span> <span class="operator">=</span> NotificationManager.IMPORTANCE_DEFAULT;</span><br><span class="line">    <span class="type">NotificationChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(CHANNEL_ID, name, importance);</span><br><span class="line">    channel.setDescription(description);</span><br><span class="line">    <span class="comment">// 在NotificationManager中注册通知渠道</span></span><br><span class="line">    <span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> getSystemService(NotificationManager.class);</span><br><span class="line">    notificationManager.createNotificationChannel(channel);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol><li><strong>发送通知</strong>：创建通知时，指定通知要使用的通知渠道ID。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(<span class="built_in">this</span>, CHANNEL_ID)</span><br><span class="line">        .setSmallIcon(R.drawable.notification_icon)</span><br><span class="line">        .setContentTitle(<span class="string">"My notification"</span>)</span><br><span class="line">        .setContentText(<span class="string">"Hello World!"</span>)</span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_DEFAULT);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol><li><strong>用户控制</strong>：用户可以进入系统设置，查看应用的每个通知渠道，并根据需要调整通知的行为（如关闭某个通知渠道的声音）。</li></ol><p><strong>重要性</strong></p><ul><li><code>NotificationChannel</code>提供了向后兼容的解决方案。对于运行在Android O以下版本的设备，应用仍然可以发送通知，但无需创建通知渠道。</li><li>一旦创建，通知渠道的某些设置就不能通过应用程序更改，只能由用户在系统设置中更改。因此，应用应当谨慎地规划其通知渠道的策略。</li></ul><p>通过引入<code>NotificationChannel</code>，Android增强了通知系统的灵活性和用户控制能力，提升了用户体验。</p><p>这段代码是用于在Android应用中创建和触发一个通知的。以下是代码的逐行解释：</p><ol><li><strong>创建NotificationBuilder对象</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Notification</span> <span class="variable">noti</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(context: <span class="built_in">this</span>, channelId)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里使用了<code>NotificationCompat.Builder</code>构造函数来创建一个新的通知构建器对象。它接收两个参数：一个是上下文（<code>this</code>通常指的是当前的<code>Activity</code>或<code>Application</code>），另一个是通知渠道的ID。从Android O开始，所有通知都必须通过一个通知渠道发送。</p><ol><li><strong>设置通知的各种属性</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.setContentTitle(<span class="string">"Notified! "</span> + Integer.toString(notificationGeneration++))</span><br><span class="line">.setContentText(<span class="string">"Subject Text"</span>)</span><br><span class="line">.setSmallIcon(R.drawable.foo)</span><br><span class="line">.setTicker(<span class="string">"Ticker text"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这部分代码设置了通知的标题、文本内容、小图标和滚动文字（在状态栏上显示的一小段文本）。</p><ol><li><strong>添加动作</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.addAction(R.drawable.foo, title: <span class="string">"Call"</span>, callIntent)</span><br><span class="line">.addAction(R.drawable.thinking_face, title: <span class="string">"More"</span>, moreIntent)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>addAction</code>方法用于在通知中添加动作按钮。每个动作都有一个图标、标题和一个<code>Intent</code>，当用户点击这个动作时，该<code>Intent</code>会被触发。</p><ol><li><strong>设置内容Intent</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.setContentIntent(moreIntent).build();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里为通知设置了一个<code>Intent</code>，当用户点击通知本身时会触发这个<code>Intent</code>。</p><ol><li><strong>获取NotificationManager服务</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这行代码从系统服务中获取<code>NotificationManager</code>实例，这个服务负责展示所有的通知。</p><ol><li><strong>设置通知标志</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noti.flags |= Notification.FLAG_AUTO_CANCEL;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过设置<code>FLAG_AUTO_CANCEL</code>标志，这个通知在用户点击后会自动被取消。</p><ol><li><strong>发送通知</strong>:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notificationManager.notify(NOTIFICATION_UNIQUE_ID, noti);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>最后，<code>notify</code>方法用于触发通知。它接收一个唯一的ID（这里是<code>NOTIFICATION_UNIQUE_ID</code>）和<code>Notification</code>对象。这个唯一ID允许应用更新或取消这个特定的通知。</p><p>注释部分还提到了一个备选方案，即使用一个唯一的ID生成策略（在这个例子中是<code>notificationGeneration</code>变量）来确保每个通知都有不同的ID，这样新的通知不会覆盖旧的通知。这通常在你需要在同一时间显示多个通知时很有用。</p><p>整体来说，这段代码演示了如何在Android应用中创建一个具有基本属性和动作的通知，并通过<code>NotificationManager</code>将其显示给用户。</p><p>在Android中，<code>Notification</code>对象有一个<code>flags</code>字段，它是一个整数（<code>int</code>），用于设置通知的行为。这个字段可以接受多个标志的组合，这些标志是<code>Notification</code>类中定义的常量。</p><p><code>FLAG_AUTO_CANCEL</code>是<code>Notification</code>类中定义的一个标志，当这个标志被设置时，它会指示系统在用户点击了通知之后自动将其取消（关闭）。这意味着通知将不再显示在通知栏中。</p><p><code>|=</code>是Java中的按位或赋值运算符，它用于将特定的位设置为<code>1</code>。如果你想在不改变其他位的情况下添加一个标志，你可以使用这个运算符。下面是如何使用<code>|=</code>运算符来设置<code>FLAG_AUTO_CANCEL</code>标志的示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noti.flags |= Notification.FLAG_AUTO_CANCEL;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这行代码的执行过程如下：</p><ol><li>读取<code>noti.flags</code>当前的值。</li><li>执行按位或运算（<code>|</code>），将<code>noti.flags</code>的值与<code>Notification.FLAG_AUTO_CANCEL</code>的值结合起来。如果<code>FLAG_AUTO_CANCEL</code>中对应的位是<code>1</code>，那么在结果中该位也会被设置为<code>1</code>，这样<code>FLAG_AUTO_CANCEL</code>就被添加到了<code>flags</code>字段中。</li><li>将新值赋回<code>noti.flags</code>。</li></ol><p>通过这种方式，即使<code>noti.flags</code>中已经设置了其他的标志，使用<code>|=</code>也不会影响它们，只会添加新的标志。这是一种在不改变现有位的情况下设置特定位的常用技术。</p><p>所以，<code>|=</code>用于设置<code>FLAG_AUTO_CANCEL</code>，它不是自动取消的原因，而是用于在不覆盖现有标志的情况下添加这个标志的方法。<code>FLAG_AUTO_CANCEL</code>本身定义了通知在点击后应该自动被取消的行为。</p>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mobile App Development</title>
      <link href="/posts/Mobile-App-Development/"/>
      <url>/posts/Mobile-App-Development/</url>
      
        <content type="html"><![CDATA[<h1>CS 5520 Mobile App Development</h1><ul><li><a href="/posts/CS5520-Week2/" title="CS5520-Week2">CS5520-Week2</a></li><li><a href="/posts/CS5520-Week3/" title="CS5520-Week3-Views">CS5520-Week3-Views</a></li><li><a href="/posts/CS5520-Week4/" title="CS5520-Week4-Intents-RecyclerView">CS5520-Week4-Intents-RecyclerView</a> </li><li><a href="/posts/CS5520-Week5/" title="CS5520-Week5-Threads">CS5520-Week5-Threads</a> </li><li><a href="/posts/CS5520-Week6/" title="CS5520-Week6-Networking">CS5520-Week6-Networking</a></li><li><a href="/posts/CS5520-Week7/" title="CS5520-Week7-Data-Storage">CS5520-Week7-Data-Storage</a> </li><li><a href="/posts/CS5520-Week8/" title="CS5520-Week8-Firebase">CS5520-Week8-Firebase</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> courses </tag>
            
            <tag> NEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前置知识</title>
      <link href="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
      <url>/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1>设计模式</h1><p>目前经典的设计模式有22个</p><h1>关键术语</h1><h2 id="面向对象基础">面向对象基础</h2><p>老四样：</p><ul><li>抽象</li><li>封装</li><li>多态</li><li>继承</li></ul><h3 id="抽象">抽象</h3><p>根据真实世界对象来设计程序中的对象。程序中的对象并不需要能够百分之百准确地反映其原型 （极少情况下才需要做到这一点）。 实际上， 「对象只需模拟真实对象的特定属性和行为即可」</p><h3 id="封装">封装</h3><p>细节都被隐藏起来，能够交互的只有提供的「接口」</p><p>封装：一个对象对其他对象隐藏部分状态和行为，而仅向程序其他部分暴露有限的借口的能力</p><p>比如<code>private</code> <code>protected</code></p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%B0%81%E8%A3%85_1.png" alt="封装_1"></p><h3 id="继承">继承</h3><p>根据已有类创建新类的能力，具体作用在于代码复用</p><p>“使用继承后， 子类将拥有与其父类相同的接口。 如果父类中声明了某个方法， 那么你将无法在子类中隐藏该方法。 你还<strong>必须实现所有</strong>的抽象方法， 即使它们对于你的子类而言没有意义。 ”</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%BB%A7%E6%89%BF_1.png" alt="继承_1"></p><h3 id="多态">多态</h3><p>声明为抽象。 这让我们得以忽略父类中该方法的所有默认实现， 从而强制要求所有子类自行提供该方法的实现。子类重写超类的方法</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%A4%9A%E6%80%81_1.png" alt="多态_1"></p><p>多态的特殊机制使得程序可以追踪对象的子类并调用其方法， 从而执行恰当的行为。<br>多态是指程序能够检测对象所属的实际类， 并在当前上下文不知道其真实类型的情况下调用其实现的能力。<br>可将多态看作是一个对象 “假扮” 为其他东西 （通常是其扩展的类或实现的接口） 的能力。 在我们的示例中， 袋中的狗和猫就相当于是假扮成了一般的动物。”</p><h2 id="关系">关系</h2><p>关系分为：</p><ul><li>依赖</li><li>关联</li><li>聚合</li><li>组合</li></ul><h3 id="依赖">依赖</h3><p>是「最基础，最微弱」的关系类型</p><p>如果修改一个类的定义可能会造成另一个类的变化。那么就说这两个类之间有依赖关系。</p><blockquote><p>通过让代码依赖「接口」或「抽象类」从而降低依赖程度</p></blockquote><blockquote><p>UML 不会展示所有依赖，仅展示对于沟通想法来说的重要的依赖关系</p></blockquote><p>用 <code>虚线箭头</code> 来表示</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB_%E4%BE%9D%E8%B5%961.png" alt="关系_依赖1"></p><h3 id="关联">关联</h3><p>一个对象使用另一个对象 或 与另一个对象进行交互的关系</p><p>关联 是一种特殊的依赖，一个对象总有访问与其交互对象的权限</p><p>一般使用 关联 来表示类似于 <code>成员变量</code> 的东西，这个关系将一直存在。</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB_%E5%85%B3%E8%81%941.png" alt="关系_关联1"></p><h3 id="依赖-vs-关联">依赖 vs 关联</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Professor</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field Student&nbsp;student</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">teach</span><span class="params">(Course&nbsp;c)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.student.remember(c.getKnowledge())</span><br></pre></td></tr></tbody></table></figure><p>而Course 作为 一个参数，Course 是作为 依赖</p><p>Student 是 Professor 的一个成员变量，Student 类 是 Professor 的 不仅是 <code>依赖</code> 而上升为 <code>关联</code></p><h3 id="聚合">聚合</h3><p>一般表示 一对多 多对多 整体对部分</p><p>一个对象拥有 一组其他对象，扮演容器和集合的角色。</p><p>组建可以独立于容器，也可以同时链接多个容器。</p><p>表示：</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB_%E8%81%9A%E5%90%881.png" alt="关系_聚合1"></p><h3 id="组合">组合</h3><p>组合是一种特殊的聚合，对象由 一个或多个其他对象实例构成。组件仅能作为容器的一部分存在</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB_%E7%BB%84%E5%90%881.png" alt="关系_组合1"></p><h3 id="聚合-vs-组合">聚合 vs 组合</h3><p>比如 大学 嘎 则 院系 消失 因为 大学管理院系的生命周期</p><p>但是 院系 嘎 教授 不一定会 嘎，因为 是聚合关系</p><p>组合使得两个 tight 的更紧了</p><h3 id="总结">总结</h3><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93.png" alt="关系总结"></p><ul><li>依赖： 对类 B 进行修改会影响到类 A 。</li><li>关联： 对象 A 知道对象 B。 类 A 依赖于类 B。</li><li>聚合： 对象 A 知道对象 B 且由 B 构成。 类 A 依赖于类 B。</li><li>组合： 对象 A 知道对象 B、 <strong>由 B 构成而且管理着 B 的生命周期</strong>。 类 A 依赖于类 B。</li></ul><h1>设计模式</h1><h2 id="算法-vs-设计模式">算法 vs 设计模式</h2><p>算法：明确定义达成特定目标的所需一系列步骤。像一道菜谱：提供达成目标的「明确」步骤</p><p>模式：解决方案的更高层次描述。像蓝图：知道最终结果和功能，自己确定如何实现的步骤</p><h2 id="分类">分类</h2><ul><li><p>创建型</p><ul><li>“提供创建对象的机制， 增加已有代码的灵活性和可复用性”</li></ul></li><li><p>结构型</p><ul><li>“对象和类组装成较大的结构， 并同时保持结构的灵活和高效。”</li></ul></li><li><p>行为</p><ul><li>“行为模式负责对象间的高效沟通和职责委派。”</li></ul></li></ul><h1>软件设计原则</h1><h2 id="代码复用">代码复用</h2><p>从 类 转向 模式 再到 框架，复用程度不断增加</p><p>模式提供的复用方式比框架风险小。</p><h2 id="扩展性">扩展性</h2><p>需要应对未来可能发生的变化来提供具有可扩展性的代码</p><h2 id="设计原则">设计原则</h2><p>从而保证灵活的设计</p><h2 id="封装变化的内容">封装变化的内容</h2><p>定位程序中的变化内容并与不变的内容分开从而使得将变更造成的影响最小化</p><p>封装掉变化的内容从而可以保护其他代码不受负面影响。</p><h3 id="封装方法">封装方法</h3><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85.png" alt="方法封装"></p><p>将计算税金的逻辑抽取到一个单独的方法中， 并对原始方法隐藏该逻辑</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%852.png" alt="方法封装2"></p><p>隔离后就可以只修改getTaxrate的逻辑，并且如果税率计算逻辑变得过于复杂， 也能更方便地将其移动到独立的类中。</p><h3 id="封装类">封装类</h3><p>新增行为通常还会带来助手成员变量和方法，将这些内容抽出来到一个新类中</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%B1%BB%E5%B0%81%E8%A3%85.png" alt="类封装"></p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%B1%BB%E5%B0%81%E8%A3%852.png" alt="类封装2"></p><h2 id="面向接口进行开发">面向接口进行开发</h2><p>这样的好处是，我们依赖的是抽象类型而不是具体类</p><ul><li>确定一个对象对另一对象的确切需求： 它需执行哪些方法？</li><li>在一个新的接口或抽象类中描述这些方法。</li><li>让被依赖的类实现该接口。</li><li>现在让有需求的类依赖于这个接口， 而不依赖于具体的类。 你仍可与原始类中的对象进行互动， 但现在其连接将会灵活得多。</li></ul><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91.png" alt="面向接口开发"></p><h2 id="组合优于继承">组合优于继承</h2><p>继承有比较多的缺点：</p><ul><li><p>子类不能减少超类的接口。 你必须实现父类中所有的抽象方法， 即使它们没什么用。</p></li><li><p>在重写方法时， 你需要确保新行为与其基类中的版本兼容。 这一点很重要， 因为子类的所有对象都可能被传递给以超类对象为参数的任何代码， 相信你不会希望这些代码崩溃的。</p></li><li><p>继承打破了超类的封装， 因为子类拥有访问父类内部详细内容的权限。 此外还可能会有相反的情况出现， 那就是程序员为了进一步扩展的方便而让超类知晓子类的内部详细内容。</p></li><li><p>子类与超类紧密耦合。 超类中的任何修改都可能会破坏子类的功能。</p></li><li><p>通过继承复用代码可能导致平行继承体系的产生。 继承通常仅发生在一个维度中。 只要出现了两个以上的维度， 你就必须创建数量巨大的类组合， 从而使类层次结构膨胀到不可思议的程度</p></li></ul><p>总结：复写所有抽象方法 + 兼容性 + 打破封装 + 增加耦合 + 类层次膨胀</p><p><strong>组合是代替继承的一种方法</strong>。 继承代表类之间的 “是” 关系 （汽车是交通工具）， 而组合则代表 “有” 关系 （汽车有一个引擎）。</p><p>这个原则也能应用于<strong>聚合</strong> （一种更松弛的组合变体， 一个对象可引用另一个对象， 但并不管理其生命周期）。 例如： 一辆汽车上有司机， 但是司机也可能会使用另一辆汽车， 或者选择步行而不使用汽车。</p><h3 id="例子">例子</h3><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF1.png" alt="组合优于继承1"></p><p>类越来越多</p><p>可以通过进行 组/聚 合优化：</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF2.png" alt="组合优于继承2"></p><h2 id="SOLID">SOLID</h2><p>SOLID 五原则 让软件设计更易于理解、 更加灵活和更易于维护的五个原则的简称。</p><h3 id="「S」ingle-Responsibility-Principle-单一职责原则">「S」ingle Responsibility Principle 单一职责原则</h3><p>每一个类应当只负责软件中的一个功能，并将其完全封装在该类中。</p><p>使用场景：“开始感觉在同时关注程序特定方面的内容时有些困难的话， 请回忆单一职责原则并考虑现在是否应将某些类分割为几个部分。”</p><p>例子：</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%991.png" alt="单一职责原则1"></p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%992.png" alt="单一职责原则2"></p><h3 id="「O」pen-closed-Principle-开闭原则">「O」pen/closed Principle 开闭原则</h3><p>对于扩展，类应当 「开放」，对于修改，类应该「封闭」</p><p>实现新功能时保持已有代码不变</p><p>开放：对一个类扩展时可以创建它的子类并对其做任何事情，比如新增方法，重写方法。</p><p>封闭：比如字段设置了 <code>final</code> 从而限制了扩展，那么就不是开放，并且如果一个类做好了充分的准备来使得其他类能够使用，即接口明确定义不会修改，那么该类就是封闭/完整</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%991.png" alt="开闭原则1"></p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%992.png" alt="开闭原则2"></p><p>现在当需要实现新的运输方式那么<code>扩展</code> <code>Shipping</code>接口创建新类即可，订单在这里就不会被破坏，属于封闭。</p><h3 id="「L」iskov-Substitution-Principle-里氏替换原则">「L」iskov Substitution Principle 里氏替换原则</h3><p>扩展类时，应该要能在<strong>不修改客户端代码的情况下</strong>将<strong>子类的对象作为父类对象</strong>进行传递。其意味着子类需要和父类行为兼容，重写方法时，对基类进行 <code>扩展</code> 而不是进行<code>替换</code></p><p>这个原则是用于<strong>预测子类是否与代码兼容</strong>。是否能与其超类对象协作的一组检查。主要服务于开发程序库和框架时。</p><p>举个例子，假设你有一个父类 <code>Bird</code> 和一个继承自 <code>Bird</code> 的子类 <code>Sparrow</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Bird is flying"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Sparrow is flying"</span>)</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>Sparrow</code> 是 <code>Bird</code> 的子类，并且重写了 <code>fly</code> 方法。根据里氏替换原则，任何期望 <code>Bird</code> 类型对象的代码都应该能够接受 <code>Sparrow</code> 对象，而不需要做任何改变。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">let_it_fly</span>(<span class="params">bird: Bird</span>):</span><br><span class="line">    bird.fly()</span><br><span class="line"></span><br><span class="line">sparrow = Sparrow()</span><br><span class="line">let_it_fly(sparrow)  <span class="comment"># 这里传递了一个 Sparrow 对象</span></span><br></pre></td></tr></tbody></table></figure><p>在这段代码中，<code>let_it_fly</code> 函数接受一个 <code>Bird</code> 类型的对象，并调用它的 <code>fly</code> 方法。由于 <code>Sparrow</code> 是 <code>Bird</code> 的子类，我们可以创建一个 <code>Sparrow</code> 对象并将其传递给 <code>let_it_fly</code> 函数。根据里氏替换原则，这应该能够正常工作，因为 <code>Sparrow</code> 完全兼容 <code>Bird</code> 类的接口。</p><p>需要有一些对于子类的形式要求：</p><ul><li><p>“子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象”</p><ul><li>“假设某个类有个方法用于给猫咪喂食：  <strong>feed­(Cat c)</strong> 。 客户端代码总是会将 “猫 （cat）” 对象传递给该方法。</li><li>好的方式： 假如你创建了一个子类并重写了前面的方法， 使其能够给任何 “动物 （ani­mal， 即 ‘猫’ 的超类）” 喂食：  <strong>feed­(Animal c)</strong> 。 如果现在你将一个子类对象而非超类对象传递给客户端代码， 程序仍将正常工作。 该方法可用于给任何动物喂食， 因此它仍然可以用于给传递给客户端的任何 “猫” 喂食。</li><li>不好的方式： 你创建了另一个子类且限制喂食方法仅接受 “孟加拉猫 （Ben­gal­Cat， 一个 ‘猫’ 的子类）”：  feed­(Bengal­Cat c) 。 如果你用它来替代链接在某个对象中的原始类，客户端中会发生什么呢？ 由于该方法只能对特殊种类的猫进行喂食， 因此无法为传递给客户端的普通猫提供服务， 从而将破坏所有相关的功能。</li></ul></li><li><p>“子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。 正如你所看到的， 对于返回值类型的要求与对于参数类型的要求相反。”</p><blockquote><p>return 越具体越好<br>parameters 越抽象越好</p></blockquote><ul><li>假设buyCat() : Cat, 返回猫</li><li>好：重写为 buyCat(): BengalCat</li><li>不好：重写为 buyCat(): Animal</li></ul></li><li><p>异常类型必须与基础方法的异常或者子类相匹配</p></li><li><p>子类不应该加强前置条件，也不能削弱后置条件</p></li><li><p>超类的不变量需要保留</p></li><li><p>子类不能修改超类中私有变量的值</p></li></ul><h3 id="「I」terface-Segregation-Principle-接口隔离原则">「I」terface Segregation Principle 接口隔离原则</h3><p>客户端不应该强迫依赖于其不使用的方法。</p><p>应该提升细粒度将导致臃肿的方法分割给其他接口：</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" alt="接口隔离原则1"></p><h3 id="「D」ependency-Inversion-Principle-依赖倒置原则">「D」ependency Inversion Principle 依赖倒置原则</h3><p>高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。 抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口。</p><ul><li>低层次的类实现基础操作 （例如磁盘操作、 传输网络数据和连接数据库等）。</li><li>高层次类包含复杂业务逻辑以指导低层次类执行特定操作。</li></ul><p>依赖倒置原则建议改变这种依赖方式。</p><p>作为初学者， 你最好使用业务术语来对高层次类依赖的低层次操作接口进行描述。 例如， 业务逻辑应该调用名为 open­Report­(file)的方法， 而不是 open­File­(x) 、  read­Bytes­(n)和 close­File­(x)等一系列方法。 这些接口被视为是高层次的。<br>现在你可基于这些接口创建高层次类， 而不是基于低层次的具体类。 这要比原始的依赖关系灵活很多。<br>一旦低层次的类实现了这些接口， 它们将依赖于业务逻辑层， 从而倒置了原始的依赖关系。</p><p>依赖倒置原则通常和开闭原则共同发挥作用： 你无需修改已有类就能用不同的业务逻辑类扩展低层次的类。</p><p>修改前，高层次 <code>BudgetReport</code> 依赖于 低层次的 数据库操作方法，如果数据库的版本或者功能发生改变，那么<code>BudgeReport</code>就可能不能工作：</p><p><img src="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.png" alt="依赖倒置原则"></p>]]></content>
      
      
      <categories>
          
          <category> 工程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code-Refactor</title>
      <link href="/posts/Code-Refactor/"/>
      <url>/posts/Code-Refactor/</url>
      
        <content type="html"><![CDATA[<h1>Code Smells</h1><p>需要避免这些</p><h2 id="Bloaters">Bloaters:</h2><p>Code, methods and classes that have invreased to such gargantuan proportions that are hard to work with. They accumulate over time as the program evolves</p><h3 id="Long-Method">Long Method</h3><p>A method contains too many lines of code</p><p>(Method that is longer than ten lines should take care about it)</p><h4 id="原因：">原因：</h4><p>一般情况下加入原本方法比添加新方法看起来要简单一些并且方法的长度是逐渐增长的，因此是不容易被一次发现的。</p><h4 id="方案：">方案：</h4><p>As a rule of thumb, <strong>if you feel the need to comment on something inside a method</strong>, you should <strong>take this code and put it in a new method.</strong></p><h5 id="Extract-Method">Extract Method</h5><p>合并逻辑相通的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// code fragment that can be grouped together</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> {</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print details.</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Move this code to a separate new method (or function) and replace the old code with a call to the method.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> {</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> {</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Reduce-local-variables-and-parameters-before-extracting-a-method">Reduce local variables and parameters before extracting a method</h5><p>If local variables and parameters interfere with extracting a method, use</p><ul><li><strong>Replace Temp with Query</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// place the result of an expression in a local variable for later use in your code.</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateTotal</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> quantity * itemPrice;</span><br><span class="line">  <span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) {</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Move the entire expression to a separate method and return the result from it. Query the method instead of using a variable. Incorporate the new method in other methods, if necessary.</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateTotal</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) {</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="type">double</span> <span class="title function_">basePrice</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> quantity * itemPrice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Introduce Parameter Object</strong></li></ul><p>Methods contain a repeating group of parameters:</p><p>![Introduce Parameter Object - Before](/posts/Code-Refactor/Introduce Parameter Object - Before.png)</p><p>Replace these parameters with an object:</p><p>![Introduce Parameter Object - After](/posts/Code-Refactor/Introduce Parameter Object - After.png)</p><ul><li><strong>Preserve Whole Object</strong>.</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: Several values are from an object and then pass them as parameters to a method:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> daysTempRange.getLow();</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> daysTempRange.getHigh();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">withinPlan</span> <span class="operator">=</span> plan.withinRange(low, high);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good: Pass the whole object</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">withinPlan</span> <span class="operator">=</span> plan.withinRange(daysTempRange);</span><br></pre></td></tr></tbody></table></figure><h5 id="Replace-Method-with-Method-Object">Replace Method with Method Object</h5><p>If none of the previous recipes help, try moving the entire method to a separate object via <strong>Replace Method with Method Object</strong>.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: A long method in which the local variables are so intertwined that you can't apply Extract Method.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">double</span> primaryBasePrice;</span><br><span class="line">    <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// Perform long computation.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Transform the method into a separate class so that the local variables become fields of the class. Then you can split the method into several methods within the same class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PriceCalculator</span>(<span class="built_in">this</span>).compute();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriceCalculator</span> {</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PriceCalculator</span><span class="params">(Order order)</span> {</span><br><span class="line">    <span class="comment">// Copy relevant information from the</span></span><br><span class="line">    <span class="comment">// order object.</span></span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Perform long computation.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Conditionals-and-Loops">Conditionals and Loops</h5><p><code>if判断</code>和<code>loop</code>可以尝试放在一个单独的方法中</p><p>For conditionals, use <strong>Decompose Conditional</strong>.</p><p>If loops are in the way, try <strong>Extract Method</strong>.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: complex conditional (if-then/else or switch).</span></span><br><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) {</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Decompose the complicated parts of the conditional into separate methods: the condition, then and else.</span></span><br><span class="line"><span class="keyword">if</span> (isSummer(date)) {</span><br><span class="line">  charge = summerCharge(quantity);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: Code fragment that can be grouped together.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printProperties</span><span class="params">(List users)</span> {</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">    result += users.get(i).getName();</span><br><span class="line">    result += <span class="string">" "</span>;</span><br><span class="line">    result += users.get(i).getAge();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Move this code to a separate new method (or function) and replace the old code with a call to the method.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printProperties</span><span class="params">(List users)</span> {</span><br><span class="line">  <span class="keyword">for</span> (User user : users) {</span><br><span class="line">    System.out.println(getProperties(user));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String <span class="title function_">getProperties</span><span class="params">(User user)</span>  {</span><br><span class="line">  <span class="keyword">return</span> user.getName() + <span class="string">" "</span> + user.getAge();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="总结">总结</h4><p>更多的方法带来的性能差是可以忽略的且更易读的代码能够带来更好的结构化以及潜在优化</p><h3 id="Large-Class">Large Class</h3><p>Class that contains many fields/method/lines of code</p><h4 id="原因">原因</h4><p>和 Long Method 类似，只管认为加field比加class要容易的多</p><h4 id="方案">方案</h4><p>When a class is wearing too many (functional) hats, think about splitting it up.</p><h5 id="Extract-as-Class">Extract (as) Class</h5><p><strong>Extract Class</strong> helps if part of the behavior of the large class can be spun off into a separate component. 分离部分行为到单独的组件中</p><p><img src="/posts/Code-Refactor/large_class_1.png" alt="large_class_1"></p><h5 id="Extract-as-Subclass">Extract (as) Subclass</h5><p><strong>Extract Subclass</strong> helps if part of the behavior of the large class can be implemented in different ways or is used in rare cases.</p><p><img src="/posts/Code-Refactor/large_class_2.png" alt="large_class_2"></p><h5 id="Extract-as-Interface">Extract (as) Interface</h5><p><strong>Extract Interface</strong> helps if it’s necessary to have a list of the operations and behaviors that the client can use.</p><p><img src="/posts/Code-Refactor/large_class_3.png" alt="large_class_3"></p><h5 id="Duplicate-Observed-Data">Duplicate Observed Data</h5><p>If a large class is responsible for the graphical interface, you may try to move some of its data and behavior to a separate domain object. In doing so, it may be necessary to store copies of some data in two places and keep the data consistent. Duplicate Observed Data offers a way to do this.</p><p>当一个类负责图形界面(GUI)时，同时还包含域(domain)数据的问题。在这个问题中，图形界面和域数据的逻辑耦合在了一起，这可能导致类变得过于复杂，并且难以维护。</p><p><img src="/posts/Code-Refactor/large_class_4.png" alt="large_class_4"></p><p>这张图展示了代码重构的一个常见模式，即“Duplicate Observed Data”模式。这个模式解决了当一个类负责图形界面(GUI)时，同时还包含域(domain)数据的问题。在这个问题中，图形界面和域数据的逻辑耦合在了一起，这可能导致类变得过于复杂，并且难以维护。</p><p><strong>问题（左侧）:</strong> 在重构前的设计中，<code>IntervalWindow</code> 类同时负责显示信息（GUI）和存储数据（域数据）。这个类中有三个文本字段（<code>TextField</code>），每个字段都有对应的失去焦点（FocusLost）事件处理函数，还有计算长度和计算结束时间的函数。这样的设计让 <code>IntervalWindow</code> 类承担了过多的职责，违反了单一职责原则，也使得该类过于庞大且难以测试。</p><p><strong>解决方案（右侧）:</strong> 图展示了如何将域数据从 <code>IntervalWindow</code> 类中分离出来，创建了一个新的 <code>Interval</code> 类。<code>IntervalWindow</code> 依然保留有界面相关的文本字段和事件处理函数，但是域数据（起始时间、结束时间和长度）现在被移到了新的 <code>Interval</code> 类中，这个类有自己的起始时间、结束时间和长度属性，以及计算长度和计算结束时间的方法。</p><p><strong>这样做的好处包括:</strong></p><ol><li><strong>单一职责原则</strong>：每个类都只处理一个职责，<code>IntervalWindow</code> 负责界面的显示，而 <code>Interval</code> 负责数据的处理。</li><li><strong>更容易测试</strong>：因为 <code>Interval</code> 类只处理数据，所以比起含有GUI代码的类，它更容易进行单元测试。</li><li><strong>更低的耦合度</strong>：这种分离减少了类之间的依赖性，使得修改界面或数据模型时，可以减少对另一部分的影响。</li><li><strong>更容易维护和扩展</strong>：清晰的分离使得后续维护和添加新功能时更加简单。</li></ol><p>在这种模式下，<code>IntervalWindow</code> 类会观察（Observe） <code>Interval</code> 类的实例。当 <code>Interval</code> 的数据发生变化时，<code>IntervalWindow</code> 可以更新其显示的数据。这通常通过某种形式的观察者模式来实现，其中 <code>Interval</code> 类会通知所有注册的观察者数据的变化。这样，任何时候 <code>Interval</code> 的数据改变了，<code>IntervalWindow</code> 都可以得到通知，并更新用户界面。</p><h4 id="总结-2">总结</h4><ul><li>Refactoring of these classes spares developers from needing to remember a large number of attributes for a class. [重构这些类使开发人员无需记住类的大量属性。]</li><li>In many cases, splitting large classes into parts avoids duplication of code and functionality. [在许多情况下，将大类分成几个部分可以避免代码和功能的重复。]</li></ul><h3 id="Primitive-Obsession">Primitive Obsession</h3><ul><li>Use of primitives instead of small objects for simple tasks (such as currency, ranges, special strings for phone numbers, etc.)</li><li>Use of constants for coding information (such as a constant <code>USER_ADMIN_ROLE = 1</code> for referring to users with administrator rights.)</li><li>Use of string constants as field names for use in data arrays.</li></ul><p>"Primitive obsession"是一个常见的编码问题，指的是开发者过度使用原始数据类型（如int、float、boolean等）来表示应该由对象表示的概念。这个术语反映了一种倾向：即使在面向对象编程中，也倾向于使用基本数据类型而不是设计小型的类来表示具有业务逻辑的概念。</p><p>解决"primitive obsession"可以提高代码的可读性、可维护性和灵活性。</p><ol><li><p><strong>使用原始数据类型而不是小对象进行简单任务</strong>：</p><ul><li>这里的“primitive”是指原始数据类型。例如，使用<code>int</code>或<code>double</code>来表示货币值可能会导致精度问题和缺乏表达力。更好的做法是创建一个<code>Currency</code>类，它可以封装货币的值和货币类型（比如美元、欧元等），同时提供货币相关的操作和转换。</li></ul></li><li><p><strong>使用常量进行编码信息</strong>：</p><ul><li>在这个上下文中，使用类似<code>USER_ADMIN_ROLE = 1</code>的常量代表了一种“primitive”的使用方式，因为它使用数字（一个原始类型）来代表用户角色。这种做法的问题在于它通常不够表达，而且容易出错。替代的方法是使用枚举（Enum）或者小型类，这样可以提供更加类型安全和描述性更强的方法来代表用户角色。</li></ul></li><li><p><strong>使用字符串常量作为数据数组中的字段名称</strong>：</p><ul><li><p>在这种情况下，“primitive”通常是指字符串类型。例如，当使用字符串来访问数据结构中的值时，这可能会导致拼写错误和与数据结构的耦合。通过创建小型类或结构体，我们可以更安全地封装数据，同时还可以提供更清晰的API和错误检查。</p></li><li><p>当然可以。使用字符串常量作为数据数组中的字段名称通常发生在我们处理键值对集合，如JSON对象或者Java中的<code>Map</code>时。</p><p>假设我们有一个表示用户的<code>Map</code>，在没有使用小对象封装的情况下，它可能看起来是这样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">user.put(<span class="string">"name"</span>, <span class="string">"John Doe"</span>);</span><br><span class="line">user.put(<span class="string">"email"</span>, <span class="string">"john.doe@example.com"</span>);</span><br><span class="line">user.put(<span class="string">"role"</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>在上述代码中，字段名称如<code>"name"</code>、<code>"email"</code>和<code>"role"</code>都是直接使用字符串常量。这种方式的问题在于，它容易出错（比如拼写错误）并且不利于重构（比如当字段名称变更时，所有的字符串都需要修改）。</p><p>一个更好的做法是使用常量来代替这些字符串字面量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConstants</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EMAIL</span> <span class="operator">=</span> <span class="string">"email"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROLE</span> <span class="operator">=</span> <span class="string">"role"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">user.put(UserConstants.NAME, <span class="string">"John Doe"</span>);</span><br><span class="line">user.put(UserConstants.EMAIL, <span class="string">"john.doe@example.com"</span>);</span><br><span class="line">user.put(UserConstants.ROLE, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>这样，如果字段名需要更改，我们只需要在<code>UserConstants</code>类中修改一次，而不需要在整个代码库中寻找和替换所有的硬编码字符串。</p><p>但是，要彻底解决"primitive obsession"的问题，我们应该创建一个用户类来封装这些属性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String email, <span class="type">int</span> role)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以添加getter和setter方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"John Doe"</span>, <span class="string">"john.doe@example.com"</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>现在，我们有了一个类型安全的对象，其中的字段名称是类的属性，而不是字符串字面量。这种方式不仅减少了错误的机会，而且使得代码更容易阅读和维护。此外，<code>User</code>类可以包含逻辑，比如验证电子邮件的格式或者确定用户角色的权限。</p></li></ul></li></ol><p>简而言之，在这些情况下，"primitive"通常指的是基本数据类型或者直接使用的常量。"Primitive obsession"可能会导致代码难以理解和维护，因为它缺乏抽象层，使得代码中的业务逻辑不够明确。通过引入小对象来封装复杂性，代码会变得更加清晰和健壮。</p><h4 id="原因-2">原因</h4><p>Like most other smells, primitive obsessions are born in moments of weakness. “Just a field for storing some data!” the programmer said. Creating a primitive field is so much easier than making a whole new class, right? And so it was done. Then another field was needed and added in the same way. Lo and behold, the class became huge and unwieldy. - 简单就加了</p><p>Primitives are often used to “simulate” types. So instead of a separate data type, you have a set of numbers or strings that form the list of allowable values for some entity. Easy-to-understand names are then given to these specific numbers and strings via constants, which is why they’re spread wide and far. - 用于代表一些东西</p><p>Another example of poor primitive use is field simulation. The class contains a large array of diverse data and string constants (which are specified in the class) are used as array indices for getting this data.</p><h4 id="方案-2">方案</h4><h5 id="Replace-Set-of-Fields-with-Object">Replace Set of Fields with Object</h5><p>If you have a large variety of primitive fields, it may be possible to logically group some of them into their own class. Even better, move the behavior associated with this data into the class too. For this task, try <strong>Replace Data Value with Object</strong>.</p><p><img src="/posts/Code-Refactor/primitive_obsession_1.png" alt="primitive_obsession_1"></p><p>将一部分原始变量打包进入一个class</p><h5 id="Primitive-Fields-in-Method-Parameters">Primitive Fields in Method Parameters</h5><p>If the values of primitive fields are used in method parameters, go with <strong>Introduce Parameter Object</strong> or <strong>Preserve Whole Object</strong>.</p><p><img src="/posts/Code-Refactor/primitive_obsession_2.png" alt="primitive_obsession_2"></p><p>在这个示例中，“primitive fields”指的是原始数据类型的字段。在Java语言中，原始类型（primitive types）包括基础的数据类型，例如<code>int</code>、<code>double</code>、<code>float</code>、<code>boolean</code>等，它们不是对象，不属于任何类的实例，并且通常用于表示简单的数值或真/假值。</p><p>然而，在这个上下文中，术语“primitive fields”可能被用来泛指那些<strong>没有被封装在对象中的简单数据类型的字段</strong>。例如，在方法参数中直接使用两个<code>Date</code>类型的参数（<code>start</code>和<code>end</code>）而不是一个封装了这两个字段的对象。虽然<code>Date</code>类型在Java中不是原始类型（它实际上是一个对象），这里的“primitive”可能是用来指代那些还没有被进一步抽象或封装的字段。</p><p>“引入参数对象”（Introduce Parameter Object）。该策略的目的是简化方法签名并提高代码的可读性和可维护性。</p><ul><li><p><strong>问题</strong>：有多个方法（如<code>amountInvoicedIn</code>、<code>amountReceivedIn</code>和<code>amountOverdueIn</code>）接受相同的参数（<code>start</code>和<code>end</code>日期），这导致了重复的参数组，并且每次调用这些方法时都需要重复这些参数。</p></li><li><p><strong>解决方案</strong>：创建一个新的类或对象来封装这些参数，例如<code>DateRange</code>对象，它包含<code>start</code>和<code>end</code>日期。然后，可以将这个对象作为单个参数传递给方法，从而减少参数的数量并使方法调用更加清晰。</p></li></ul><p>重构后，方法调用变得更加简洁，因为只需要传递一个<code>DateRange</code>对象而不是两个分开的<code>Date</code>对象。这样做的好处包括减少重复代码，使方法调用更加直观，以及提供了进一步重构的可能性，例如，如果将来需要在日期范围中添加更多的信息或功能，只需要修改<code>DateRange</code>类即可。</p><p>让我们用Java代码举个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码，方法参数中直接使用了Date类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountInvoicedIn</span><span class="params">(Date start, Date end)</span> {</span><br><span class="line">        <span class="comment">// 计算逻辑...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountReceivedIn</span><span class="params">(Date start, Date end)</span> {</span><br><span class="line">        <span class="comment">// 计算逻辑...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountOverdueIn</span><span class="params">(Date start, Date end)</span> {</span><br><span class="line">        <span class="comment">// 计算逻辑...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码，引入了一个新的DateRange类来封装日期范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateRange</span> {</span><br><span class="line">    <span class="keyword">private</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> Date end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateRange</span><span class="params">(Date start, Date end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DateRange类的其他有用方法和逻辑...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountInvoicedIn</span><span class="params">(DateRange dateRange)</span> {</span><br><span class="line">        <span class="comment">// 使用dateRange.getStart()和dateRange.getEnd()进行计算...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountReceivedIn</span><span class="params">(DateRange dateRange)</span> {</span><br><span class="line">        <span class="comment">// 使用dateRange.getStart()和dateRange.getEnd()进行计算...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">amountOverdueIn</span><span class="params">(DateRange dateRange)</span> {</span><br><span class="line">        <span class="comment">// 使用dateRange.getStart()和dateRange.getEnd()进行计算...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个重构的过程中，通过引入<code>DateRange</code>类，我们不仅简化了方法签名，而且提高了代码的可读性和可维护性。这也是设计模式中的封装原则的一个应用。</p><p>另一个方法是保留整个Object</p><p><img src="/posts/Code-Refactor/primitive_obsession_3.png" alt="primitive_obsession_3"></p><h5 id="Get-Rid-of-Type-codes">Get Rid of Type codes</h5><p>When complicated data is coded in variables, use <strong>Replace Type Code with Class</strong>, <strong>Replace Type Code with Subclasses</strong> or <strong>Replace Type Code with State/Strategy</strong>.</p><p><img src="/posts/Code-Refactor/primitive_obsession_4.png" alt="primitive_obsession_4"></p><p><img src="/posts/Code-Refactor/primitive_obsession_5.png" alt="primitive_obsession_5"></p><p><img src="/posts/Code-Refactor/primitive_obsession_6.png" alt="primitive_obsession_6"></p><p>有时候，使用子类可能不是最佳选择，特别是当类型代码影响对象的状态，但又不能或不应该用子类来表示时。在这种情况下，可以使用状态或策略模式来替换类型代码。</p><p>状态/策略模式允许你将行为封装在不同的对象中，并在运行时切换对象的行为。你创建一个状态接口或策略接口，并为每种类型代码创建实现该接口的具体类。然后，你可以在运行时根据需要将这些对象替换为不同的状态或策略。</p><p>例如，如果<code>Employee</code>对象的类型会在其生命周期中改变，那么使用状态模式可以在不同的状态之间切换而不需要创建和销毁对象。</p><p><strong>不能使用子类的情况：</strong></p><ul><li><strong>类型动态变化</strong>：如果对象的类型在其生命周期中需要改变，使用子类就不太适合了。因为一旦创建了一个对象的实例，它的类就不能改变了。</li><li><strong>类爆炸</strong>：如果类型代码的组合非常多，创建对应的子类会导致类数量爆炸，增加系统复杂性。</li><li><strong>多维度变化</strong>：如果对象的行为由多个独立的维度影响，那么使用子类可能会导致重复代码。在这种情况下，策略模式可以让你独立地改变对象的各个方面。</li><li><strong>共享行为</strong>：如果不同的类型代码共享一些行为，使用子类可能会导致这些共享行为的重复实现。而状态/策略模式允许共享行为被多个状态/策略共用。</li></ul><h5 id="Replace-Array-with-Object">Replace Array with Object</h5><p>If there are arrays among the variables, use <strong>Replace Array with Object</strong>.</p><p><img src="/posts/Code-Refactor/primitive_obsession_7.png" alt="primitive_obsession_7"></p><h4 id="总结-3">总结</h4><p>Code becomes more flexible thanks to use of objects instead of primitives.</p><p>Better understandability and organization of code. Operations on particular data are in the same place, instead of being scattered. No more guessing about the reason for all these strange constants and why they’re in an array.</p><p>Easier finding of duplicate code.</p><h3 id="Long-Parameter-List">Long Parameter List</h3><blockquote><p>More than three or four parameters for a method</p></blockquote><h4 id="原因：-2">原因：</h4><p>在面向对象编程中，一个核心原则是降低类之间的耦合度，即使类之间的依赖关系最小化。这通常被视为一种良好的设计实践，因为它可以增加代码的模块性和可重用性，并简化系统的测试和维护。</p><p>考虑一个生成报告的方法，需要多种数据（如标题、页码、内容等）。最初，这些数据的获取可能直接在方法内部进行，使得方法与数据源高度耦合。为了降低耦合，决定在调用该生成报告方法之前先在外部准备好所有必要的数据，然后通过参数传递给方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportGenerator</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateReport</span><span class="params">(String title, <span class="type">int</span> pageNumber, List&lt;String&gt; content)</span> {</span><br><span class="line">        <span class="comment">// 生成报告的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportService</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareAndGenerateReport</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> dataSource.getTitle(); <span class="comment">// 获取标题</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> dataSource.getPageNumber(); <span class="comment">// 获取页码</span></span><br><span class="line">        List&lt;String&gt; content = dataSource.getContent(); <span class="comment">// 获取内容</span></span><br><span class="line">        <span class="type">ReportGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReportGenerator</span>();</span><br><span class="line">        generator.generateReport(title, pageNumber, content); <span class="comment">// 传递参数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尽管这种设计减少了<code>ReportGenerator</code>对数据来源的直接依赖，提高了类之间的独立性，但它也引入了长参数列表的问题。当方法依赖于多个外部创建的对象时，这些对象必须通过方法的参数列表传递，导致参数数量急剧增加。</p><h4 id="方案-3">方案</h4><h5 id="Replace-Parameter-with-Method-Call">Replace Parameter with Method Call</h5><p>假如某些arguments是<code>另一个object</code>方法执行的结果，可以将这些arguments替换为<code>方法内部的</code>Method Call。</p><p><img src="/posts/Code-Refactor/long_parameter_list_1.png" alt="long_parameter_list_1"></p><h5 id="Preserve-Whole-Object">Preserve Whole Object</h5><p>我们可以pass一个包含所有需要参数的object到方法里</p><p><img src="/posts/Code-Refactor/long_parameter_list_2.png" alt="long_parameter_list_2"></p><h5 id="Introduce-Parameter-Object">Introduce Parameter Object</h5><p>和上面的方法其实有点类似上面的是将被调用本身的object存入，这个是创建一个新的object存入，这个方法适用于parameters 来自于不同的source。</p><p><img src="/posts/Code-Refactor/long_parameter_list_3.png" alt="long_parameter_list_3"></p><h4 id="总结-4">总结</h4><p>比较简单，但是如果去掉某个参数会导致耦合度增加，那就不要删掉了</p><h3 id="Data-Clumps">Data Clumps</h3><blockquote><p>Different Parts of the code contain identical groups of variables. These Clumps should be turned into their own classes</p></blockquote><h4 id="原因-3">原因</h4><p>封装失败导致的，相关连的变量应该被组合为一个对象。所以可以 尝试删除一个变量然后看看其他值是否仍然有意义。比如：如果删除了 <code>user</code> 后，剩余的 <code>startDate</code>, <code>endDate</code>, 和 <code>roomNumber</code> 仍描述了预订的时间和地点，但缺少了执行操作的用户信息，这是业务逻辑不完整的表现。这说明 <code>startDate</code>, <code>endDate</code>, <code>roomNumber</code>, 和 <code>user</code> 这组变量彼此之间存在强烈的逻辑关联，应该一起考虑，它们的组合描述了一个完整的业务操作 —— 预订或取消预订一个会议室。</p><h4 id="方案-4">方案</h4><h5 id="Extract-Class">Extract Class</h5><p><img src="/posts/Code-Refactor/Data_Clumps_1.png" alt="Data_Clumps_1"></p><h5 id="Introduce-Parameter-Object-2">Introduce Parameter Object</h5><p><img src="/posts/Code-Refactor/Data_Clumps_2.png" alt="Data_Clumps_2"></p><h5 id="Preserve-Whole-Object-2">Preserve Whole Object</h5><p>传入参数所对应的对象，而不是单独的几个field</p><p><img src="/posts/Code-Refactor/Data_Clumps_3.png" alt="Data_Clumps_3"></p><h4 id="总结-5">总结</h4><p>解决方案很多和长参数列表类似，其实就是通过抽出到某一个class或者直接使用从而避免长/重复Clumps</p><h2 id="Object-Orientation-Abusers">Object-Orientation Abusers</h2><blockquote><p>不规范的使用oop</p></blockquote><h3 id="Switch-Statements">Switch Statements</h3><h4 id="原因-4">原因</h4><blockquote><p>非常复杂的<code>switch</code>或者<code>if</code></p></blockquote><p>一般原因可能是一开始很小但是随着不停的加入条件但是单块swtich不断变大。</p><p>在oop中，条件判断应该很少，这是因为OOP可以使用多态的特性</p><p>比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 switch 的传统方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">(String userType)</span> {</span><br><span class="line">    <span class="keyword">switch</span> (userType) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Admin"</span>:</span><br><span class="line">            performAdminOperation();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Moderator"</span>:</span><br><span class="line">            performModeratorOperation();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"User"</span>:</span><br><span class="line">            performUserOperation();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Invalid user type"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多态的 OOP 方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">implements</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> {</span><br><span class="line">        performAdminOperation();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Moderator</span> <span class="keyword">implements</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> {</span><br><span class="line">        performModeratorOperation();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularUser</span> <span class="keyword">implements</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> {</span><br><span class="line">        performUserOperation();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过采用多态性，每个用户类负责定义其操作的具体实现，系统的其他部分则不需要知道用户的具体类型，也不需要 <code>switch</code> 语句。这样做提高了代码的模块化和可维护性，并使得添加新的用户类型变得非常容易。</p><h4 id="方案-5">方案</h4><h5 id="Isolate-switch-Operator">Isolate <code>switch</code> Operator</h5><p>To isolate switch and put it in the right class, need <code>Extract Method</code> and the <code>Move Method</code></p><p>Extract the swtich logic to a code block:</p><p><img src="/posts/Code-Refactor/switch_statements_1.png" alt="switch_statements_1"></p><p>Move the method:</p><p><img src="/posts/Code-Refactor/switch_statements_2.png" alt="switch_statements_2"></p><p>(PS: 感觉这种方法没有什么意义，本质上就是将在另一个class中被经常调用的方法给挪过去，然后调用reference，本质上像是一个Util class)</p><h5 id="Get-Rid-of-Type-Codes">Get Rid of Type Codes</h5><p>这个其实在17514中提到过，少使用 instanceof，多使用多态性质</p><p>当被用于检查type时，use Replace Type Code with Subclasses or Replace Type Code with State/Strategy</p><p>Replace Type Code with Subclasses:<br><img src="/posts/Code-Refactor/switch_statements_3.png" alt="switch_statements_3"></p><p>Replace Type Code with State/Strategy Pattern:</p><p><img src="/posts/Code-Refactor/switch_statements_4.png" alt="switch_statements_4"></p><p>理解两者的不同确实需要更具体的代码示例来阐明。让我们通过具体示例更清晰地区分策略模式和状态模式，并强调在实际使用中它们的区别。</p><p>策略模式的示例：支付方式选择</p><p>假设我们有一个电子商务系统，用户可以选择不同的支付方式（例如信用卡支付、PayPal支付等）。这些支付方式可以被视为不同的策略，用户可以根据自己的需求选择使用哪种支付策略。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信用卡支付策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Paid "</span> + amount + <span class="string">" using Credit Card."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PayPal支付策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaypalPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Paid "</span> + amount + <span class="string">" using PayPal."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> {</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShoppingCart</span><span class="params">(PaymentStrategy paymentStrategy)</span> {</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentStrategy</span><span class="params">(PaymentStrategy paymentStrategy)</span> {</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(<span class="type">int</span> amount)</span> {</span><br><span class="line">        paymentStrategy.pay(amount);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>(<span class="keyword">new</span> <span class="title class_">CreditCardPayment</span>());</span><br><span class="line">        cart.checkout(<span class="number">100</span>);  <span class="comment">// 使用信用卡支付</span></span><br><span class="line"></span><br><span class="line">        cart.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">PaypalPayment</span>());</span><br><span class="line">        cart.checkout(<span class="number">200</span>);  <span class="comment">// 更改为使用 PayPal 支付</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>ShoppingCart</code> 对象可以在不同的支付策略之间灵活切换，但它自身的状态并没有改变，这反映了策略模式的典型用法。</p><p>状态模式的示例：电视状态控制</p><p>现在，让我们考虑一个电视机，它有多种状态（如开启、关闭、静音等）。这些状态决定了电视机的行为，状态改变意味着电视行为的改变。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电视状态接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TVState</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pressPowerButton</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnState</span> <span class="keyword">implements</span> <span class="title class_">TVState</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressPowerButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Turning TV off."</span>);</span><br><span class="line">        <span class="comment">// 切换到关闭状态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OffState</span> <span class="keyword">implements</span> <span class="title class_">TVState</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressPowerButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Turning TV on."</span>);</span><br><span class="line">        <span class="comment">// 切换到开启状态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> {</span><br><span class="line">    <span class="keyword">private</span> TVState state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(TVState state)</span> {</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(TVState state)</span> {</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressPowerButton</span><span class="params">()</span> {</span><br><span class="line">        state.pressPowerButton();</span><br><span class="line">        <span class="comment">// 根据当前状态改变行为</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="keyword">new</span> <span class="title class_">OffState</span>());</span><br><span class="line">        tv.pressPowerButton();  <span class="comment">// 开启电视</span></span><br><span class="line"></span><br><span class="line">        tv.setState(<span class="keyword">new</span> <span class="title class_">OnState</span>());</span><br><span class="line">        tv.pressPowerButton();  <span class="comment">// 关闭电视</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>TV</code> 类的行为随着内部状态的改变而改变。状态的改变通常由状态自身来管理（虽然在这里是由外部控制以简化示例），这反映了状态模式的核心特性：对象通过改变状态改变其行为。</p><p>区别总结</p><p>在策略模式中，选择哪种策略通常是由客户端决定，策略之间相互独立，不知道彼此的存在。而在状态模式中，状态通常是有相互转换逻辑的，每个状态知道在某个动作下应该转换到哪个新状态，这是内部管理的。</p><p>这两个模式虽然结构相似，但它们在设计意图、管理责任和使用上下文中有明显区别。策略模式强调选择，状态模式强调变化。</p><h5 id="Replace-Conditional-With-Polymorphism">Replace Conditional With Polymorphism</h5><p><img src="/posts/Code-Refactor/switch_statements_5.png" alt="switch_statements_5"></p><h5 id="Replace-Parameters-switching-with-Explicit-Methods">Replace Parameters <code>switch</code>ing with Explicit Methods</h5><p><img src="/posts/Code-Refactor/switch_statements_6.png" alt="switch_statements_6"></p><h5 id="Introduce-Null-Object">Introduce Null Object</h5><p>If one of the conditional option is <code>null</code>, use Null Object instead</p><p><img src="/posts/Code-Refactor/switch_statements_7.png" alt="switch_statements_7"></p><h3 id="Temporary-Field">Temporary Field</h3><blockquote><p>Temporary fields get their values (and thus are needed by objects) only under certain circumstances. Outside of these circumstances, they’re empty.</p></blockquote><p>这种一般是因为之后要生成数据现在搁置的情况或者是数据在固定某个if分支中才会被赋值</p><p>另一种情况是避免长参数列表而引入。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportGenerator</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> specialCalculationValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateReport</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="keyword">if</span> (data.isSpecialCase()) {</span><br><span class="line">            specialCalculationValue = complexCalculation(data);</span><br><span class="line">            <span class="comment">// 使用 specialCalculationValue 进行报告生成</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其他情况下，specialCalculationValue 不被使用，保持为空</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">complexCalculation</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 复杂计算</span></span><br><span class="line">        <span class="keyword">return</span> data.getValue() * <span class="number">42</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/posts/Trie%E6%A0%91/"/>
      <url>/posts/Trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>Trie树</h1><p>Trie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。</p><p>其核心是使用**「边」<strong>来代表有无字符，使用</strong>「点」<strong>来记录是否为</strong>「单词结尾」<strong>以及</strong>「其后续字符串的字符是什么」**</p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/">https://leetcode.cn/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/</a></p><p>解决的问题：</p><p>快速的查找字符串以及存储字符串：</p><p><img src="/posts/Trie%E6%A0%91/trie_eg_1.png" alt="trie_eg_1"></p><p>星号代表标记来作为这是一个单词的结尾，说明单词形成了</p><p>一般形式：都是小写字母，都是大写字母，都是数字；一般范围都会比较小</p><h1>步骤：</h1><p>假设 word</p><ol><li>从根结点开始，遍历单词 <code>word</code>，并看当前字母<code>word[i]</code>是否出现过<ol><li>没有 -&gt; 创建一个</li><li>有 -&gt; 遍历到点上</li></ol></li><li>在单词结尾打一个标记</li></ol><h1><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node[] charactersArr;</span><br><span class="line">        <span class="type">boolean</span> isCompleteWord;</span><br><span class="line"></span><br><span class="line">        Node() {</span><br><span class="line">            charactersArr = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="built_in">this</span>.isCompleteWord = isCompleteWord;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> {</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) p.charactersArr[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        p.isCompleteWord = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.isCompleteWord;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/search-suggestions-system/">1268. 搜索推荐系统</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">suggestedProducts</span><span class="params">(String[] products, String searchWord)</span> {</span><br><span class="line">        Arrays.sort(products);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.length; i++) {</span><br><span class="line">            tr.insert(products[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; searchWord.length(); i++) {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span>[] idxes = tr.search(searchWord.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> idxes[<span class="number">0</span>], r = idxes[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= Math.min(l + <span class="number">2</span>, r) &amp;&amp; l != -<span class="number">1</span>; j++) list.add(products[j]);</span><br><span class="line">            ans.add(list);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node[] charArr = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node root;</span><br><span class="line">        Map&lt;Node, Integer&gt; char2MinIdx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Node, Integer&gt; char2MaxIdx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Trie() {</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String product, <span class="type">int</span> wordIdx)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rootP</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; product.length(); i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> product.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (rootP.charArr[idx] == <span class="literal">null</span>) {</span><br><span class="line">                    rootP.charArr[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                    char2MinIdx.put(rootP.charArr[idx], wordIdx);</span><br><span class="line">                }</span><br><span class="line">                char2MaxIdx.put(rootP.charArr[idx], wordIdx);</span><br><span class="line">                rootP = rootP.charArr[idx];</span><br><span class="line">            }</span><br><span class="line">            rootP.isCompleted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] search(String target) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rootP</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length(); i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> target.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (rootP.charArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">                l = char2MinIdx.get(rootP.charArr[idx]);</span><br><span class="line">                r = char2MaxIdx.get(rootP.charArr[idx]);</span><br><span class="line">                rootP = rootP.charArr[idx];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {l, r};</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design-Pattern</title>
      <link href="/posts/Design-Pattern/"/>
      <url>/posts/Design-Pattern/</url>
      
        <content type="html"><![CDATA[<blockquote><div class="note blue icon-padding flat"><i class="note-icon fas fa-tree"></i><blockquote><p>见 <a href="/posts/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" title="前置知识">前置知识</a> 来复习</p></blockquote></div></blockquote><blockquote><p>根据：</p><p><a href="https://refactoring.guru/design-patterns">深入设计模式</a><br>亚历山大 · 什韦茨</p><p>进行的个人总结，感谢支持</p></blockquote><h1>设计模式分类</h1><ul><li>Creational Pattern<ul><li>创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性<ul><li>Factory Method - 工厂方法<ul><li>父类中提供一个创建对象的接口以允许<strong>子类</strong>决定<strong>实例化对象的类型</strong></li></ul></li><li>Abstract Factory - 抽象工厂<ul><li>允许创建一系列相关的对象而 「不用」指定其具体类</li></ul></li><li>Builder - 生成器<ul><li>分步骤创建复杂对象，允许使用相同的创建代码生成不同类型和形式的对象</li></ul></li><li>Prototype - 原型<ul><li>让人能复制已有对象，而又无须使代码依赖他们所属的类</li></ul></li><li>Singleton - 单例<ul><li>让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点</li></ul></li></ul></li></ul></li><li>Structural Pattern<ul><li>结构型模式介绍如何将对象和类组装成较大的结构，并保持结构的灵活和高效<ul><li>Adapter - 适配器<ul><li>让接口不兼容的对象能够相互工作</li></ul></li><li>Bridge - 桥接<ul><li>可将一个大类或一系列紧密相关的类拆分为「抽象」和「实现」两个独立的层次结构，从而能在开发时分别使用</li></ul></li><li>Composite - 组合<ul><li>使用它将对象组合成树状结构，并且像独立对象一样使用它们</li></ul></li><li>Decorator - 装饰<ul><li>通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为</li></ul></li><li>Facade - 外观<ul><li>为程序库，框架或其他复杂类提供一个简单的接口</li></ul></li><li>Flyweight - 享元<ul><li>摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象</li></ul></li><li>Proxy - 代理<ul><li>让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理</li></ul></li></ul></li></ul></li><li>Behavioral Pattern<ul><li>行为模式负责对象间的高效沟通和职责委派</li></ul></li></ul><h1>Creational Pattern</h1><h2 id="工厂方法-Factory-Method">工厂方法 - Factory Method</h2><p><img src="/posts/Design-Pattern/Factory_Method_1.png" alt="Factory_Method_1"></p><blockquote><p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p></blockquote><h3 id="现实问题">现实问题</h3><p>一开始写的代码只支持卡车运输，大部分代码都在卡车类下。一段时间以后，需要支持其他的运输方式，比如海运，那么由于现在的代码几乎都在卡车下，想要实现新的方式就会比较困难。因此不得不大幅度，频繁修改代码，并根据不同的运输对象类在应用中进行不同的处理</p><h3 id="解决方案">解决方案</h3><p>工厂方法建议使用特殊的<strong>工厂方法代替对于对象构造函数的直接调用</strong></p><p><img src="/posts/Design-Pattern/Factory_Method_2.png" alt="Factory_Method_2"></p><p>在 子类的createTransport中调用 new 从而返回产品</p><p>这样的好处是我们现在可以在子类中重写工厂方法，从而改变其创建产品的类型。</p><p>但是，仅当这些产品具有共同的基类或者接口时，子类才可以返回不同类型的产品。同时，基类中的工厂方法还应将返回类型声明为这一公共接口：</p><p><img src="/posts/Design-Pattern/Factory_Method_3.png" alt="Factory_Method_3"></p><p>总结：<code>卡车Truck</code> 和 <code>轮船Ship</code> 类都必须实现 <code>运输Trans­port</code> 接口， 该接口声明了一个名为 <code>deliver交付</code> 的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  <code>陆路运输Road­Logis­tics</code>类中的工厂方法返回卡车对象， 而 <code>海路运输Sea­Logis­tics</code>类则返回轮船对象。</p><p>这样就可以使得调用工厂部分的代码，即客户端代码 不需要知道不同子类和返回实际对象之间的区别。客户端将所有产品都认为是 抽象的 <code>运输</code> 客户端知道所有运输对象都提供 交付 的方法，但是不需要知道具体是怎么实现的。</p><h3 id="结构">结构</h3><p><img src="/posts/Design-Pattern/Factory_Method_4.png" alt="Factory_Method_4"></p><p><code>产品 （Prod­uct）</code> 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p><p><code>具体产品 （Con­crete Prod­ucts</code>） 是产品接口的不同实现。</p><p><code>创建者 （Cre­ator）</code> 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。<br>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。<br>注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p><p><code>具体创建者  （Con­crete Cre­ators</code>） 将会重写基础工厂方法， 使其返回不同类型的产品。<br>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p><h3 id="样例">样例</h3><p><img src="/posts/Design-Pattern/Factory_Method_5.png" alt="Factory_Method_5"></p><p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Win­dows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Win­dows 样式渲染按钮。</p><p>如需该模式正常工作， 基础对话框类必须使用<strong>抽象</strong>按钮 （例如基类或接口）， <strong>以便将其扩展为具体按钮</strong>。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p><p>每向对话框中添加一个新的工厂方法， 你就离<strong>抽象工厂模式</strong>更近一步。</p><h3 id="总结">总结</h3><p>产品接口 + 产品类：</p><p>需要 一个 interface / 基类 product 抽象化从而可以扩展为具体的product</p><p>需要 concrete products 来实现具体的功能</p><p>工厂接口 + 工厂类：</p><p>需要一个Creator 从而让客户端能够调用</p><p>需要 concrete creator来返回具体的实例类型</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span></span><br><span class="line"><span class="comment">//&nbsp;该方法的实现。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Dialog</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;创建者还可提供一些工厂方法的默认实现。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">abstract</span>&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;法并使其返回不同类型的产品来间接修改业务逻辑。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;调用工厂方法创建一个产品对象。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Button</span>&nbsp;<span class="variable">okButton</span>&nbsp;<span class="operator">=</span>&nbsp;createButton()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;现在使用产品。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;okButton.onClick(closeDialog)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体创建者将重写工厂方法以改变其所返回的产品类型。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WindowsDialog</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dialog</span> “is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WebDialog</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dialog</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;产品接口中将声明所有具体产品都必须实现的操作。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体产品需提供产品接口的各种实现。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WindowsButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">(a,&nbsp;b)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染按钮。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;绑定本地操作系统点击事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">HTMLButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">render</span><span class="params">(a,&nbsp;b)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回一个按钮的&nbsp;HTML&nbsp;表述。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">onClick</span><span class="params">(f)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;绑定网络浏览器的点击事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field dialog:&nbsp;Dialog</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;程序根据当前配置或环境设定选择创建者的类型。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">initialize</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">config</span>&nbsp;<span class="operator">=</span>&nbsp;readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Windows"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">dialog</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WindowsDialog</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Web"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">dialog</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WebDialog</span>()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Exception</span>(<span class="string">"错误！未知的操作系统。"</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;类传递给客户端。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.initialize()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;dialog.render()</span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景">使用场景</h3><ol><li><p>无法预知对象确切类别以及依赖关系</p><ol><li>工厂方法将创建产品的代码和实际的使用逻辑分离，从而能在不影响其他代码的情况下扩展产品创建部分的代码</li><li>例如，如果需要向应用中添加一种新产品，我们现在只需要开发新的创建者子类，然后重写其工厂方法即可</li></ol></li><li><p>需要用户扩展应用库或框架的内部组件</p><ol><li>将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</li><li>假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 <code>圆形按钮Round­But­ton子类</code>来继承标准的 <code>按钮But­ton</code>类。 但是， 你需要告诉<code> UI框架UIFrame­work类</code>使用新的子类按钮代替默认按钮。<br>为了实现这个功能， 你可以根据基础框架类开发子类 <code>圆形按钮UI UIWith­Round­But­tons</code> ， 并且重写其 <code>create­Button</code>创建按钮方法。 基类中的该方法返回 <code>按钮对象</code>， 而你开发的子类返回 <code>圆形按钮对象</code>。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。</li></ol></li><li><p>复用对象，而不是每一次都创建新对象</p><ol><li><p>比如数据库连接</p></li><li><p>复用现有对象的方法：</p><p>首先， 你需要创建存储空间来存放所有已经创建的对象。<br>当他人请求一个对象时， 程序将在对象池中搜索可用对象。<br>…然后将其返回给客户端代码。<br>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）</p></li><li><p>我们需要 一个既能够创建新对象， 又可以重用现有对象的普通方法 – 工厂方法：</p><ol><li>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</li><li>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</li><li>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。<br>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。</li><li>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</li><li>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。<br>例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ；  运输及其子类 飞机, 卡车和 火车 。  航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。</li><li>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为</li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品接口以及具体的产品类：</span></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：AirMail</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirMail</span> <span class="keyword">implements</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Using AirMail"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：LandMail</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandMail</span> <span class="keyword">implements</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useProduct</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Using LandMail"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductFactory</span> {</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> pool.get(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (product == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 根据类型创建新产品</span></span><br><span class="line">            <span class="keyword">switch</span> (type) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"AirMail"</span>:</span><br><span class="line">                    product = <span class="keyword">new</span> <span class="title class_">AirMail</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"LandMail"</span>:</span><br><span class="line">                    product = <span class="keyword">new</span> <span class="title class_">LandMail</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="literal">null</span>) {</span><br><span class="line">                pool.put(type, product); <span class="comment">// 将新创建的产品添加到池中</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放产品实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseProduct</span><span class="params">(String type, Product product)</span> {</span><br><span class="line">        pool.put(type, product);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProductFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取AirMail产品实例</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">airMail</span> <span class="operator">=</span> factory.getProduct(<span class="string">"AirMail"</span>);</span><br><span class="line">        airMail.useProduct();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取LandMail产品实例</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">landMail</span> <span class="operator">=</span> factory.getProduct(<span class="string">"LandMail"</span>);</span><br><span class="line">        landMail.useProduct();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>ProductFactory</code> 类管理着一个对象池，当请求一个特定类型的产品时，它首先尝试从池中获取。如果池中没有可用的产品实例，则创建一个新的实例并将其添加到池中。这样，当同一类型的产品再次被请求时，可以重用之前创建的实例，而不是每次都创建新的实例。</p><p>额外的：工厂方法 后 演变为 抽象工厂，原型，生成器 方法</p><h2 id="抽象工厂方法-Abstract-Factory">抽象工厂方法 - Abstract Factory</h2><p>其是一种创建型设计模式，它能 <strong>创建一系列相关的对象</strong> 而无需指定具体类</p><p><img src="/posts/Design-Pattern/abstract_factory_1.png" alt="abstract_factory_1"></p><h3 id="现实问题-2">现实问题</h3><p>假设正在开发一款家具商店模拟器</p><p>代码中有一些类：</p><ol><li>来表示相关产品：椅子，沙发，咖啡桌</li><li>系列产品的不同变体。比如 有 现代风格的椅子，或者XX风格的椅子</li></ol><p><img src="/posts/Design-Pattern/abstract_factory_2.png" alt="abstract_factory_2"></p><p>也就是说对于每一种商品。我们有多种变体。</p><p>因此我们需要对于每一种艺术风格，我们都需要设计一种家具对象。并且我们当然<strong>不希望</strong>在添加新产品/风格的时候修改已有的代码。</p><h3 id="解决方案-2">解决方案</h3><ol><li>抽象工厂模式建议为 <strong>系列中的每一件产品</strong> 明确声明接口。然后确保<strong>所有变体</strong>都<strong>继承/实现</strong>这些接口</li></ol><p>e.g: 所有风格的椅子都实现椅子接口。</p><p><img src="/posts/Design-Pattern/abstract_factory_3.png" alt="abstract_factory_3"></p><ol start="2"><li>然后我们需要一个抽象工厂其包含系列中所有产品构造方法的接口。<code>createChair</code> <code>createSofa</code> <code>createXXX</code>,这些接口都必须返回抽象产品类型也就是 <code>createChair:Chair</code> <code>createSofa:Sofa``createCoffeeTable:CoffeTable</code></li></ol><p><img src="/posts/Design-Pattern/abstract_factory_4.png" alt="abstract_factory_4"></p><ol start="3"><li>对于每一个变体，使用**「抽象工厂接口」来创建不同的「工厂类」** 每一个工厂类都只能返回特定类别的产品，比如VictorianFurnitureFactory 返回 Victorian，Modern 返回 Modern</li></ol><p>这样，客户端就可以通过相应的抽象接口调用工厂和产品类而无需修改客户端代码</p><h3 id="结构-2">结构</h3><p><img src="/posts/Design-Pattern/abstract_factory_5.png" alt="abstract_factory_5"></p><ol><li><em>ProductA, ProductB:</em> （Abstract Product 抽象产品） 构成系列产品的一组不同但相关的产品声明接口</li><li>Concrete ProductX: (Concrete Product 具体产品) 抽象产品的多种不同类型实现。所有变体（风格，比如维多利亚/现代）都必须实现相应的抽象产品（椅子/沙发）</li><li>Abstract Factory 抽象工厂: 接口声明一组创建 <strong>抽象产品</strong>的方法</li><li>ConcreteFactoryX 具体工厂：实现抽象工厂的构建方法，每一个具体工厂都生产且仅创建对应产品变体</li><li>客户端对于具体产品的初始化，其构建方法签名必须返回相应的 <strong>抽象</strong> 产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。客户端只需要通过抽象接口嗲用工厂和产品对象，就能与任何具体工厂/产品变体交互。</li></ol><h3 id="样例-2">样例</h3><p><img src="/posts/Design-Pattern/abstract_factory_6.png" alt="abstract_factory_6"></p><p>这个例子通过使用 <strong>抽象工厂</strong> 模式从而使得客户端代码与具体UI类耦合从而创建跨平台的UI元素，同时确保所创建的元素与制定的操作系统匹配。</p><p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Win­dows 系统下运行的应用程序中显示 macOS 的控件。</p><p>抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。</p><p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。</p><p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。</p><p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。</p><h3 id="总结-2">总结</h3><p>伪代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">//&nbsp;且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span></span><br><span class="line"><span class="comment">//&nbsp;品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span></span><br><span class="line"><span class="comment">//&nbsp;使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span></span><br><span class="line"><span class="comment">//&nbsp;行实例化。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinFactory</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinButton</span>()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacFactory</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">GUIFactory</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createButton</span><span class="params">()</span>:Button&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacButton</span>()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体产品由相应的具体工厂创建。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacButton</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Button</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;macOS&nbsp;样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span></span><br><span class="line"><span class="comment">//&nbsp;品之间才能够正确地进行交互。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">WinCheckbox</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;Windows&nbsp;样式渲染复选框。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">MacCheckbox</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Checkbox</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;根据&nbsp;macOS&nbsp;样式渲染复选框。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码仅通过抽象类型（GUIFactory、Button&nbsp;和&nbsp;Checkbox）使用工厂</span></span><br><span class="line"><span class="comment">//&nbsp;和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field factory:&nbsp;GUIFactory</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field button:&nbsp;Button</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Application</span><span class="params">(factory:&nbsp;GUIFactory)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.factory&nbsp;=&nbsp;factory</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">createUI</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.button&nbsp;=&nbsp;factory.createButton()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">paint</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span></span><br><span class="line"><span class="comment">//&nbsp;始化阶段）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">ApplicationConfigurator</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">config</span>&nbsp;<span class="operator">=</span>&nbsp;readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Windows"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">factory</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">WinFactory</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(config.OS&nbsp;==&nbsp;<span class="string">"Mac"</span>)&nbsp;<span class="type">then</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">factory</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">MacFactory</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Exception</span>(<span class="string">"错误！未知的操作系统。"</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Application</span>&nbsp;<span class="variable">app</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Application</span>(factory)</span><br></pre></td></tr></tbody></table></figure><p>实际的java code例子：</p><p>在这个例子中，我们创建一个关于电子产品的简单场景。</p><p>假设有两类产品：手机和平板电脑，分别有不同的品牌（例如：苹果和三星）。我们将实现抽象工厂和具体工厂来创建这些产品。</p><p>在这个例子中，<code>ElectronicsFactory</code> 是一个抽象工厂接口，定义了创建智能手机和平板电脑的方法。<code>AppleFactory</code> 和 <code>SamsungFactory</code> 是具体的工厂实现，分别创建苹果和三星品牌的产品。客户端代码依赖于抽象工厂和产品接口，而不是具体的实现类，这使得增加新的产品品牌（例如添加一个华为工厂）时，无需修改客户端代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleSmartphone</span> <span class="keyword">implements</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Apple Smartphone"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungSmartphone</span> <span class="keyword">implements</span> <span class="title class_">Smartphone</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Samsung Smartphone"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleTablet</span> <span class="keyword">implements</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Apple Tablet"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungTablet</span> <span class="keyword">implements</span> <span class="title class_">Tablet</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Samsung Tablet"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span>;</span><br><span class="line">    Tablet <span class="title function_">createTablet</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleSmartphone</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tablet <span class="title function_">createTablet</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleTablet</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungFactory</span> <span class="keyword">implements</span> <span class="title class_">ElectronicsFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">createSmartphone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SamsungSmartphone</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tablet <span class="title function_">createTablet</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SamsungTablet</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ElectronicsFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">appleSmartphone</span> <span class="operator">=</span> appleFactory.createSmartphone();</span><br><span class="line">        <span class="type">Tablet</span> <span class="variable">appleTablet</span> <span class="operator">=</span> appleFactory.createTablet();</span><br><span class="line"></span><br><span class="line">        appleSmartphone.display();</span><br><span class="line">        appleTablet.display();</span><br><span class="line"></span><br><span class="line">        <span class="type">ElectronicsFactory</span> <span class="variable">samsungFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SamsungFactory</span>();</span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">samsungSmartphone</span> <span class="operator">=</span> samsungFactory.createSmartphone();</span><br><span class="line">        <span class="type">Tablet</span> <span class="variable">samsungTablet</span> <span class="operator">=</span> samsungFactory.createTablet();</span><br><span class="line"></span><br><span class="line">        samsungSmartphone.display();</span><br><span class="line">        samsungTablet.display();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景-2">使用场景</h3><ol><li>代码需要与多个不同系列的相关产品交互，但是我们无法预先获取相关信息，不希望代码对于产品具体类进行构建<ol><li>抽象工厂的接口可以用于创建么个系列产品的对象，只要代码通过该接口创建对象。</li></ol></li><li>有一个基于一组抽象方法的类，且其主要功能因此变得不明确<ol><li>好的代码需要：每个类仅负责一件事，如果一个类与多个类型产品交互，那么我们可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象公差那个类</li></ol></li></ol><h3 id="实现方式">实现方式</h3><ol><li><strong>以不同的产品类型与产品变体为维度绘制矩阵</strong>：<ul><li>在示例中，我们有两种产品类型：<code>Smartphone</code> 和 <code>Tablet</code>（抽象产品接口），这构成了矩阵的一维。</li><li>另一维是产品变体，即不同品牌：<code>Apple</code> 和 <code>Samsung</code>。每个品牌都有其对应的智能手机和平板电脑产品。</li></ul></li><li><strong>为所有产品声明抽象产品接口，并且让所有具体产品类实现这些接口</strong>：<ul><li>抽象产品接口为 <code>Smartphone</code> 和 <code>Tablet</code>。具体产品类如 <code>AppleSmartphone</code>, <code>SamsungSmartphone</code>, <code>AppleTablet</code>, <code>SamsungTablet</code> 实现了这些接口。</li></ul></li><li><strong>声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法</strong>：<ul><li>抽象工厂接口是 <code>ElectronicsFactory</code>，它定义了创建智能手机和平板电脑的方法（<code>createSmartphone()</code> 和 <code>createTablet()</code>）。</li></ul></li><li><strong>为每种产品变体实现一个具体工厂类</strong>：<ul><li>具体工厂类为 <code>AppleFactory</code> 和 <code>SamsungFactory</code>，每个工厂类都实现了 <code>ElectronicsFactory</code> 接口，并能创建特定品牌的智能手机和平板电脑。</li></ul></li><li><strong>在应用程序中开发初始化代码，根据应用程序配置或当前环境对特定具体工厂类进行初始化，并将该工厂对象传递给所有需要创建产品的类</strong>：<ul><li>客户端代码 (<code>Client</code> 类) 演示了如何根据需要选择并初始化具体工厂（例如 <code>AppleFactory</code> 或 <code>SamsungFactory</code>），并使用这些工厂来创建产品。</li></ul></li><li><strong>找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用</strong>：<ul><li>在客户端代码中，不直接使用产品的构造函数来创建产品实例。相反，它调用工厂对象的 <code>createSmartphone()</code> 和 <code>createTablet()</code> 方法来获取产品实例。</li></ul></li></ol><p>抽象工厂和桥接（bridge） 可以搭配使用，如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p><h2 id="生成器-Builder">生成器 - Builder</h2><p>生成器模式允许我们能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象</p><h3 id="现实问题-3">现实问题</h3><p>有个对象比较复杂，在构造的时候需要对诸多成员变量和嵌套对象进行复杂的初始化工作。这些用于初始化的代码可能深藏于一个包含众多参数且让人基本看不懂的构造函数中；也可能会散落在客户端代码的多个位置</p><p>假如我们需要创建一个 house，house可能有 garage，可能有swimmingpool，garden etc；如果为每种可能的对象都创建一个子类，那么可能会导致程序变得过于复杂。</p><p>一种可行的方法为：我们有一个House的基类，然后创建一系列涵盖所有参数组合的子类。但是这会使得我们在新增了任何参数比如门框大小，雕塑等等都会使得这个房屋的层次结构变得非常复杂。</p><p><img src="/posts/Design-Pattern/builder_1.png" alt="builder_1"></p><p>另一种方法则是实用一个超级构造函数：</p><p><img src="/posts/Design-Pattern/builder_2.png" alt="builder_2"></p><p>但是这样的话就会使得构造函数非常的臃肿，并且我们有很多参数是不会使用的。</p><h3 id="解决方案-3">解决方案</h3><p>生成器模式则建议将对象构造代码从产品类中抽出，并且方位一个<code>生成器</code> 的类中：</p><p><img src="/posts/Design-Pattern/builder_3.png" alt="builder_3"></p><p>这个模式会让构造对象划分为一组步骤：<code>buildWalls()</code> <code>buildDoors()</code>。在创建对象的时候，都需要通过生成器对象来执行一系列步骤。不同的是，我们只需要选择需要的步骤即可。</p><p>当我们需要创建不同形式的产品时，其中的一些构造步骤需要不同的实现，比如木屋需要木制门，铁屋需要铁门等等。</p><p>如果是这种情况，那我们可以创建多个不同的Builder，用不同的方式实现一组相同的创建步骤，然后在创建过程中使用这些生成器来实现不同的对象</p><p><img src="/posts/Design-Pattern/builder_4.png" alt="builder_4"></p><h4 id="主管">主管</h4><p>额外的，我们可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器提供步骤的具体实现</p><p><img src="/posts/Design-Pattern/builder_5.png" alt="builder_5"></p><p>主管类不是必须的，他比较适用于在流水线工程中以便能够重复使用。在一般情况下，客户端代码直接以特定顺序调用创建步骤即可。</p><p>对于客户端代码来说，主管类隐藏了产品构造细节。</p><h3 id="结构-3">结构</h3><p><img src="/posts/Design-Pattern/builder_6.png" alt="builder_6"></p><ol><li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li><li>具体生成器 （Con­crete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li><li>产品 （Prod­ucts） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li><li>主管 （Direc­tor） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li><li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li></ol><h3 id="样例-3">样例</h3><p>使用builder pattern来生成Car以及CarManual</p><p><img src="/posts/Design-Pattern/builder_7.png" alt="builder_7"></p><p>汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有在 汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。</p><p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p><p>每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手册。 当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。</p><p>最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。因此， 我们只能通过负责制造过程的生成器来获取结果对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个</span></span><br><span class="line"><span class="comment">//&nbsp;产品尽管没有同样的接口，但却相互关联。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Car</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;一辆汽车可能配备有&nbsp;GPS&nbsp;设备、行车电脑和几个座位。不同型号的汽车（</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;运动型轿车、SUV&nbsp;和敞篷车）可能会安装或启用不同的功能。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Manual</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;生成器接口声明了创建产品对象不同部件的方法。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会</span></span><br><span class="line"><span class="comment">//&nbsp;有多个以不同方式实现的生成器变体。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CarBuilder</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field car:Car</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">CarBuilder</span><span class="params">()</span>&nbsp;is</span><br><span class="line">  <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;reset（重置）方法可清除正在生成的对象。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.car&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;所有生成步骤都会与同一个产品实例进行交互。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;设置汽车座位的数量。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装指定的引擎。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装行车电脑。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;安装全球定位系统。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;准备。因此生成器实例通常会在&nbsp;`getProduct（获取产品）`方法主体末尾</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;调用重置方法后再去处理之前的结果。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getProduct</span><span class="params">()</span>:Car&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">product</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="built_in">this</span>.car</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.reset()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;product</span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;生成器与其他创建型“模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CarManualBuilder</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Builder</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field manual:Manual</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">CarManualBuilder</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">reset</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.manual&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setSeats</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于汽车座椅功能的文档。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setEngine</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于引擎的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setTripComputer</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于行车电脑的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setGPS</span><span class="params">(...)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;添加关于&nbsp;GPS&nbsp;的介绍。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getProduct</span><span class="params">()</span>:Manual&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回使用手册并重置生成器。</span></span><br><span class="line"><span class="comment">//&nbsp;主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时</span></span><br><span class="line"><span class="comment">//&nbsp;会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并</span></span><br><span class="line"><span class="comment">//&nbsp;不是必需的。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Director</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field builder:Builder</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;过这种方式改变最新组装完毕的产品的最终类型。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">setBuilder</span><span class="params">(builder:Builder)</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.builder&nbsp;=&nbsp;builder</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;主管可使用同样的生成步骤创建多个产品变体。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">constructSportsCar</span><span class="params">(builder:&nbsp;Builder)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.reset()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setSeats(<span class="number">2</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setEngine(<span class="keyword">new</span>&nbsp;<span class="title class_">SportEngine</span>())</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">constructSUV</span><span class="params">(builder:&nbsp;“Builder)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果</span></span><br><span class="line"><span class="comment">//&nbsp;将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">makeCar</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">director</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">CarBuilder</span>&nbsp;<span class="variable">builder</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CarBuilder</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;director.constructSportsCar(builder)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Car</span>&nbsp;<span class="variable">car</span>&nbsp;<span class="operator">=</span>&nbsp;builder.getProduct()</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">CarManualBuilder</span>&nbsp;<span class="variable">builder</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CarManualBuilder</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;产品的存在，也不会对其产生依赖。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Manual</span>&nbsp;<span class="variable">manual</span>&nbsp;<span class="operator">=</span>&nbsp;builder.getProduct()</span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景-3">使用场景</h3><ul><li><p>避免重叠构造函数的出现</p><ul><li>一个构造函数中有十几个可选参数，或者复写这个函数来包含一些较少参数的简化版方法：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Pizza</span>&nbsp;{</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size)&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size,&nbsp;<span class="type">boolean</span>&nbsp;cheese)&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line">&nbsp;&nbsp;Pizza(<span class="type">int</span>&nbsp;size,&nbsp;<span class="type">boolean</span>&nbsp;cheese,&nbsp;<span class="type">boolean</span>&nbsp;pepperoni)&nbsp;{&nbsp;...&nbsp;}</span><br></pre></td></tr></tbody></table></figure><ul><li>生成器模式让你可以分<strong>步骤生成对象</strong>， 而且允许你<strong>仅使用必须的步骤</strong>。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</li></ul></li><li><p>使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p><ul><li>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</li><li>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序</li></ul></li><li><p>使用生成器构造组合树或其他复杂对象。</p><ul><li>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</li></ul></li></ul><h3 id="实现方法">实现方法</h3><ol><li>定义通用步骤，确保可以制造所有形式的产品</li><li>在基本生成器接口中生命这些步骤</li><li>为每个形式的产品创建具体生成器类并实现具体的步骤，还要实现获取构造结果对象的方法。不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</li><li><strong>考虑</strong>创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式.</li><li>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</li><li>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</li></ol><h2 id="原型-Clone-Prototype">原型 - Clone, Prototype</h2><p>原型模式使得能够复制已有对象而又无需使代码依赖他们所属的类</p><h3 id="现实问题-4">现实问题</h3><p>我们有一个对象并且希望生成一个完全相同的复制品。一个可行的办法是创建个属于相同类的对象然后循环复制所有的原始对象的成员变量。</p><p>但是这个的问题在于，我们会有一些<strong>私有成员变量</strong>而这些在对象本身以外是不可见的</p><p>还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p><h3 id="解决方案-4">解决方案</h3><p>通过原型模式我们可以将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个<strong>通用接口</strong>这个接口使得我们能够克隆对象同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个<strong>克隆</strong>方法,</p><p>所有的类对 克隆 这个方法的实现都非常类似。这个方法会：创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。这样我们就可以复制私有成员变量。</p><p>支持克隆的对象被称为<strong>原型</strong></p><p>当对象有十几个成员变量和几百种类型时，我们可以创建一系列不同的类型的对象并用不同的方式对其进行配置。如果所需对象与预先配置的对象相同。直接克隆原型即可。</p><h3 id="结构-4">结构</h3><h4 id="基本实现">基本实现</h4><p><img src="/posts/Design-Pattern/prototype_1.png" alt="prototype_1"></p><ol><li>原型 （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</li><li>具体原型 （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li>客户端 （Client） 可以复制实现了原型接口的任何对象。</li></ol><h4 id="原型注册表实现">原型注册表实现</h4><p><img src="/posts/Design-Pattern/prototype_2.png" alt="prototype_2"></p><p>原型注册表 （Pro­to­type Reg­istry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</p><h3 id="样例-4">样例</h3><p>原型模式可以生成完全相同的几何对象副本，无需代码与对象所属类耦合</p><p><img src="/posts/Design-Pattern/prototype_3.png" alt="prototype_3"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;基础原型。</span></span><br><span class="line"><span class="keyword">abstract</span>&nbsp;<span class="keyword">class</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field X:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field Y:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field color:&nbsp;string</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;常规构造函数。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Shape</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Shape</span><span class="params">(source:&nbsp;Shape)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">this</span><span class="params">()</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.X&nbsp;=&nbsp;source.X</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.Y&nbsp;=&nbsp;source.Y</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.color&nbsp;=&nbsp;source.color</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;clone（克隆）操作会返回一个形状子类。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">abstract</span>&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span><br><span class="line"><span class="comment">//&nbsp;行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span><br><span class="line"><span class="comment">//&nbsp;成的克隆对象。这可以保持克隆结果的一致。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Rectangle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field width:&nbsp;<span class="type">int</span></span><br><span class="line">&nbsp;&nbsp;field height:&nbsp;<span class="type">int</span></span><br><span class="line">  constructor&nbsp;<span class="title function_">Rectangle</span><span class="params">(source:&nbsp;Rectangle)</span>&nbsp;is</span><br><span class="line">    <span class="comment">//&nbsp;需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="line">    <span class="built_in">super</span>(source)</span><br><span class="line">    <span class="built_in">this</span>.width&nbsp;=&nbsp;source.width</span><br><span class="line">    <span class="built_in">this</span>.height&nbsp;=&nbsp;source.height</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Circle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Shape</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field radius:&nbsp;<span class="type">int</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Circle</span><span class="params">(source:&nbsp;Circle)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.radius&nbsp;=&nbsp;source.radius</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">clone</span><span class="params">()</span>:Shape&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码中的某个位置。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field shapes:&nbsp;array&nbsp;of&nbsp;Shape</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Application</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Circle</span>&nbsp;<span class="variable">circle</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.X&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.Y&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;circle.radius&nbsp;=&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(circle)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Circle</span>&nbsp;<span class="variable">anotherCircle</span>&nbsp;<span class="operator">=</span>&nbsp;circle.clone()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(anotherCircle)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;变量&nbsp;`anotherCircle（另一个圆）`与&nbsp;`circle（圆）`对象的内</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;容完全一样。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Rectangle</span>&nbsp;<span class="variable">rectangle</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Rectangle</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;rectangle.width&nbsp;=&nbsp;<span class="number">10</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;rectangle.height&nbsp;=&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;shapes.add(rectangle)</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">businessLogic</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;其完全相同的复制品。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Array</span>&nbsp;<span class="variable">shapesCopy</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Array</span>&nbsp;of&nbsp;Shapes.</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;但在多态机制的帮助下，当我们在某个形状上调用&nbsp;`clone（克隆）`</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(s&nbsp;in&nbsp;shapes)&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapesCopy.add(s.clone())</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;`shapesCopy（形状副本）`数组中包含&nbsp;`shape（形状）`数组所有</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;子元素的复制品.</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景-4">使用场景</h3><ul><li>需要复制一些对象，同时希望代码独立于这些对象所属的具体类<ul><li>这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。<br>原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。实现方法</li></ul></li><li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量<ul><li>在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。</li><li>客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</li></ul></li></ul><h3 id="实现方法-2">实现方法</h3><ol><li>创建 <code>Prototype</code>接口，并在其中加入<code>clone</code>方法。</li><li>原型类必须另行定义一个以<strong>该类对象为参数的构造函数</strong>。<strong>构造函数必须复制参数对象中的所有成员变量值到新建实体中</strong>。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。<br>如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。</li><li>克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。</li><li>可以创建一个中心化原型注册表， 用于存储常用原型。<br>可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。<br>最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</li></ol><h2 id="单例模式-Singleton">单例模式 - Singleton</h2><p>单例是一种能够保证一个类只有一个实例并且提供一个方位该实例的全局节点</p><h3 id="现实问题-5">现实问题</h3><p>由于单例模式<strong>同时</strong>解决了两个问题，所以他其实「违反了」「单一指责原则」</p><ol><li><p>保证一个类只有一个实例。为什么？一个可能的原因是想要控制某些共享资源的访问权限：</p><ol><li><p>如果创建了一个对象，如果过一会决定再创建一个新对象，那么其实获得的是之前已经创建的对象，而不是一个新对象。</p></li><li><p><img src="/posts/Design-Pattern/singleton_1.png" alt="singleton_1"></p></li><li><p>假设有一个应用，需要频繁地访问数据库。如果每次访问数据库时都创建一个新的数据库连接，将会非常耗时且低效，因为建立数据库连接是一个资源密集型和时间密集型的操作。此外，同时打开过多的连接可能会超过数据库的连接限制，导致新的连接失败。</p><p>使用单例模式，你可以创建一个<code>DatabaseConnection</code>类，它负责与数据库建立连接。这个类将被设计为单例，确保应用中的任何组件都使用相同的数据库连接实例，从而有效管理对数据库的访问。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseConnection instance;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DatabaseConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 初始化数据库连接</span></span><br><span class="line">        <span class="built_in">this</span>.connection = <span class="comment">// 创建数据库连接</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DatabaseConnection <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (DatabaseConnection.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DatabaseConnection</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.connection;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>为该实例提供一个全局访问的节点</p><ol><li><p>单例模式允许程序的任何地方访问特定的对象但是它可以「保护该实例<strong>不</strong>被其他代码覆盖」</p></li><li><p>考虑一个应用需要读取一些全局配置信息，如配置文件中的设置。使用单例模式，可以创建一个<code>Configuration</code>类，它加载并存储配置信息，应用中的任何部分都可以访问这些信息，而不需要重复加载。并且无法修改内部的内容，因此是安全的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration instance;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Configuration</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Configuration <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Configuration.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.properties.getProperty(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol><h3 id="解决方案-5">解决方案</h3><p>所有的单例的实现都包含下面两个相同的步骤：</p><ul><li><p>设置默认的构造函数为「私有」，防止其他对象使用单例类的<code>new</code>运算符</p></li><li><p>新建一个静态构建方法作为构造函数。该函数会调用私有的构造函数来创建对象并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这个缓存对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 静态成员变量，存储单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部通过new直接实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {} <span class="comment">// &lt;- 注意他是private的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公开的静态方法，用于获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果实例不存在，则创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 返回实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据代码不难看出，只要调用了这个类里面的getInstance，它总是返回已经创建的相同的对象</p></li></ul><h3 id="真实世界类比">真实世界类比</h3><p>比如政府，一个国家只有一个官方政府。不论组成政府的每个人的身份是什么，这个XX政府这个称谓总是鉴别那些掌权者的全局访问节点</p><h3 id="结构-5">结构</h3><p><img src="/posts/Design-Pattern/singleton_2.png" alt="singleton_2"></p><p>getInstance 来返回其所属类的一个相同实例。单例的构造函数必须对客户端代码隐藏。客户端只通过getInstance的方法来获取对象</p><h3 id="代码样例">代码样例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span></span><br><span class="line"><span class="comment">//&nbsp;都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Database</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">static</span>&nbsp;field instance:&nbsp;Database</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构造方法。</span></span><br><span class="line">  <span class="keyword">private</span>&nbsp;constructor&nbsp;<span class="title function_">Database</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;method&nbsp;<span class="title function_">getInstance</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">if</span>&nbsp;<span class="params">(Database.instance&nbsp;==&nbsp;<span class="literal">null</span>)</span>&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">acquireThreadLock</span><span class="params">()</span>&nbsp;and&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(Database.instance&nbsp;==&nbsp;<span class="literal">null</span>)&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Database.instance&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">Database</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;Database.instance</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;method&nbsp;<span class="title function_">query</span><span class="params">(sql)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里添加限流或缓冲逻辑。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Application</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">main</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Database</span>&nbsp;<span class="variable">foo</span>&nbsp;<span class="operator">=</span>&nbsp;Database.getInstance()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foo.query(<span class="string">"SELECT&nbsp;..."</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Database</span>&nbsp;<span class="variable">bar</span>&nbsp;<span class="operator">=</span>&nbsp;Database.getInstance()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;bar.query(<span class="string">"SELECT&nbsp;..."</span>)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;变量&nbsp;`bar`&nbsp;和&nbsp;`foo`&nbsp;中将包含同一个对象。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景-5">使用场景</h3><ul><li>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。<ul><li>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</li></ul></li><li>如果你需要更加严格地控制全局变量， 可以使用单例模式。<ul><li>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</li></ul></li><li>我们可以随时调整限制并设定生成单例实例的数量， 只需修改 getInstance 方法， 即 getInstance 中的代码即可实现。</li></ul><h3 id="实现方式-2">实现方式</h3><ol><li>在类中添加一个私有静态成员变量用于保存单例实例。</li><li>声明一个公有静态构建方法用于获取单例实例。</li><li>在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li><li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li><li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</li></ol><h3 id="与其他模式的关系">与其他模式的关系</h3><ul><li>外观 (Facade) 类通常可以转换为单例类， 因为在大部分情况下一个外观对象就足够了。</li><li>如果你能将对象的所有共享状态简化为一个享元（cache，缓存）对象， 那么享元就和单例类似了。 但这两个模式有两个根本性的不同。<ul><li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li><li>单例对象可以是可变的。 享元对象是不可变的。</li><li>抽象工厂、 生成器和原型都可以用单例来实现。</li></ul></li></ul><h2 id="创建型设计模式总结">创建型设计模式总结</h2><p>创建型模式主要处理对象创建机制，帮助创建对象时保持系统的灵活性和可维护性。</p><ul><li><p><strong>单例模式</strong>：当需要确保全局只有一个实例存在，并且提供一个访问它的全局访问点时使用。</p><p>例子：数据库连接池的唯一性</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnectionPool</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DatabaseConnectionPool</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DatabaseConnectionPool</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 私有构造器，防止外部直接创建实例</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DatabaseConnectionPool <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回数据库连接</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>工厂方法</strong>和<strong>抽象工厂</strong>：当创建对象时需要考虑系统的灵活性和可扩展性，而不是直接实例化类时使用。工厂方法用于创建一个产品，抽象工厂提供一个接口来创建一系列相关或相互依赖的对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    <span class="keyword">abstract</span> Button <span class="title function_">createButton</span><span class="params">()</span>; <span class="comment">// 工厂方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renderButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> createButton();</span><br><span class="line">        button.render();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows按钮工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS按钮工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮和文本框的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows和MacOS的按钮实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS button"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows和MacOS的文本框实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering Windows text field"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Rendering MacOS text field"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacOSFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSTextField</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>工厂方法模式</strong>着重于创建单一产品（在这个例子中是按钮）。每个具体的工厂类负责创建单一产品的一个具体实现。</li><li><strong>抽象工厂模式</strong>提供一个创建一系列相关或相互依赖产品的接口（在这个例子中是按钮和文本框）。每个具体的工厂类负责创建一系列产品的一组具体实现。</li></ul><h5 id="工厂方法模式">工厂方法模式</h5><ul><li><strong>设计目的</strong>：让子类决定实例化哪一个类。工厂方法模式让类的实例化推迟到子类中进行。</li><li><strong>应用场景</strong>：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由其子类来指定它创建的对象时；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你想将哪一个帮助子类是代理者这一信息局部化时。</li><li><strong>关键实现</strong>：通过继承来改变实例化的类。子类实现抽象工厂方法以创建具体产品。</li></ul><h5 id="抽象工厂模式">抽象工厂模式</h5><ul><li><strong>设计目的</strong>：提供一个接口，用于创建相关或相互依赖对象的家族，而不需要明确指定具体类。</li><li><strong>应用场景</strong>：当需要创建的对象是一系列相关或相互依赖的对象时；当一个系统要独立于它的产品的创建、组合和表示时；当强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，只想显示它们的接口而不是实现时。</li><li><strong>关键实现</strong>：通过对象组合来创建抽象产品的家族。一个工厂实例创建一系列相互依赖的产品。</li></ul><h5 id="核心区别">核心区别</h5><ul><li><strong>产品范围</strong>：工厂方法模式通常用于一个产品等级结构，而抽象工厂模式用于多个产品等级结构。</li><li><strong>控制范围</strong>：工厂方法通过继承来改变实例化哪个类，控制的是生产单一产品的逻辑；抽象工厂通过对象组合来创建一系列产品，控制的是生产多个相互依赖的一系列产品的逻辑。</li><li><strong>实现方式</strong>：工厂方法模式依赖于继承，具体产品由子类创建；抽象工厂模式依赖于接口的实现，具体产品的创建委托给了具体工厂的实例。</li></ul></li><li><p><strong>建造者模式</strong>：当需要创建一个包含多个组成部分的复杂对象时，尤其是当对象的创建过程需要多个步骤，且构造过程需要被细化时使用。</p><p>构建复杂的HTML文档或SQL查询</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDocument</span> {</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; paragraphs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> {</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParagraph</span><span class="params">(String paragraph)</span> {</span><br><span class="line">        paragraphs.add(paragraph);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 将标题和段落组合成HTML文档</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDocumentBuilder</span> {</span><br><span class="line">    <span class="keyword">private</span> HtmlDocument document;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HtmlDocumentBuilder</span><span class="params">()</span> {</span><br><span class="line">        document = <span class="keyword">new</span> <span class="title class_">HtmlDocument</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocumentBuilder <span class="title function_">withTitle</span><span class="params">(String title)</span> {</span><br><span class="line">        document.setTitle(title);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocumentBuilder <span class="title function_">addParagraph</span><span class="params">(String paragraph)</span> {</span><br><span class="line">        document.addParagraph(paragraph);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HtmlDocument <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>原型模式</strong>：当创建一个对象的成本较高，且与其类型相似的对象可能会经常使用时，可以通过复制一个已存在对象来减少创建对象的开销。</p><ul><li><strong>原型模式</strong>的目的是通过<strong>复制现有的实例来创建新的实例</strong>，避免了新实例创建的成本和复杂性。原型模式允许对象在不指定具体类的情况下创建副本。这在需要创建对象的状态与现有对象相似时非常有用。</li><li><strong>单例模式</strong>的目的是确保一个类只有一个实例，并提供一个全局访问点。单例模式主要用于全局状态或共享资源的情况，如配置管理器或数据库连接池。在单例模式中，实例是唯一的，且全局可访问。</li></ul><p>考虑一个后端开发中的场景，如在一个Web应用中管理配置信息的示例。假设你有一个配置对象，它在应用启动时从外部服务加载配置数据，这个过程可能包括网络请求获取数据库连接字符串、API密钥、日志设置等。这个配置对象在应用的不同部分被频繁访问，但是其初始化非常昂贵，因为它涉及到网络请求和数据解析。</p><h5 id="不使用原型模式的情况">不使用原型模式的情况</h5><p>每次你需要配置信息时，都去创建一个新的配置对象并从外部服务加载数据。这不仅增加了网络负载，还可能因为外部服务的响应延迟而显著增加了应用的启动时间。</p><h5 id="使用原型模式的情况">使用原型模式的情况</h5><p>在应用启动时创建一次配置对象，并通过原型模式在需要时克隆它。由于配置数据通常在应用运行期间不会改变，所以这个方法可以避免重复的初始化成本。</p><p>在这个例子中，使用原型模式可以显著减少从外部服务加载配置信息的次数，因为：</p><ul><li><p><strong>初始化成本</strong>：原始配置对象的加载包括网络请求和数据解析，这是一次性的，并在首次创建对象时完成。</p></li><li><p><strong>克隆成本</strong>：通过克隆原始对象来创建新的配置对象实例，避免了重复的网络请求和数据解析。克隆操作主要是内存中的数据复制，其成本远低于外部服务的调用。</p></li><li><p><strong>运行效率</strong>：应用启动和运行过程中对配置数据的访问变得更快，因为避免了重复的耗时操作。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line">      <span class="keyword">private</span> Map&lt;String, String&gt; settings;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Configuration</span><span class="params">()</span> {</span><br><span class="line">          <span class="built_in">this</span>.settings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          <span class="comment">// 假设这里包含从外部服务加载配置的耗时操作</span></span><br><span class="line">          loadConfigurationFromExternalService();</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadConfigurationFromExternalService</span><span class="params">()</span> {</span><br><span class="line">          <span class="comment">// 模拟网络请求和设置加载</span></span><br><span class="line">          settings.put(<span class="string">"dbConnectionString"</span>, <span class="string">"someConnectionString"</span>);</span><br><span class="line">          settings.put(<span class="string">"apiKey"</span>, <span class="string">"someAPIKey"</span>);</span><br><span class="line">          <span class="comment">// 更多配置...</span></span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> {</span><br><span class="line">          <span class="keyword">return</span> settings.get(key);</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Configuration <span class="title function_">clone</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">              <span class="comment">// 浅克隆足够了，因为我们不修改settings内部的数据</span></span><br><span class="line">              <span class="keyword">return</span> (Configuration) <span class="built_in">super</span>.clone();</span><br><span class="line">          } <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="comment">// 不应该发生</span></span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> {</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">          <span class="type">Configuration</span> <span class="variable">originalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">          <span class="type">Configuration</span> <span class="variable">clonedConfig</span> <span class="operator">=</span> originalConfig.clone();</span><br><span class="line">  </span><br><span class="line">          System.out.println(clonedConfig.getSetting(<span class="string">"dbConnectionString"</span>));</span><br><span class="line">          System.out.println(clonedConfig.getSetting(<span class="string">"apiKey"</span>));</span><br><span class="line">          <span class="comment">// 输出与originalConfig加载的相同的配置项，但没有重新从外部服务加载</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"># Structural Pattern</span><br><span class="line"></span><br><span class="line">## 适配器 - Adapter Pattern</span><br><span class="line"></span><br><span class="line">&gt; 适配器是一种结构性设计模式，它能使接口不兼容的对象相互合作</span><br><span class="line"></span><br><span class="line">使一个老的方案通过`adapter`来实现新的方案</span><br><span class="line"></span><br><span class="line">![adapter_guru_1](/posts/Design-Pattern/adapter_guru_1.png)</span><br><span class="line"></span><br><span class="line">### 现实问题</span><br><span class="line"></span><br><span class="line">当想要整合老旧方案到一个新的方案时，在不修改老方案的内容的情况下，使用adapter：</span><br><span class="line"></span><br><span class="line">A special object that converts the <span class="keyword">interface</span> <span class="title class_">of</span> one object so that another object can understand it.</span><br><span class="line"></span><br><span class="line">假如正在开发一款股票市场监测程序，它会从不同来源下载XML格式的股票数据，然后像用户呈现图表。我们现在需要整合一个第三方的分析函数库。但是这个库只兼容JSON格式的数据。</span><br><span class="line"></span><br><span class="line">一个可能的解决方案有：修改程序库使其支持XML。但是这样就需要修改依赖这个程序库的现有代码。或者我们压根可能对这个程序库没有access。</span><br><span class="line"></span><br><span class="line">![adapater_1](/posts/Design-Pattern/adapater_1.png)</span><br><span class="line"></span><br><span class="line">### 解决方案</span><br><span class="line"></span><br><span class="line">此时就需要一个适配器，它是一个特殊的对象，主要目的是转换对象借口，使其能够与其他对象进行交互。</span><br><span class="line"></span><br><span class="line">适配器模式通过封装对象从而将一个复杂的转换过程隐藏起来。被封装的对象甚至不知道有适配器这个东西。</span><br><span class="line"></span><br><span class="line">适配器不仅可以转化不同格式的数据，还有助于采用不同接口的对象之间合作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器实现与其中一个现有对象兼容的接口。 </span><br><span class="line"><span class="number">2.</span> 现有对象可以使用该接口安全地调用适配器方法。 </span><br><span class="line"><span class="number">3.</span> 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</span><br><span class="line"></span><br><span class="line">甚至双向适配器也是可以的这样就可以双向转换调用</span><br><span class="line"></span><br><span class="line">![adapter_2](/posts/Design-Pattern/adapter_2.png)</span><br><span class="line"></span><br><span class="line">对于先前的股票市场问题，为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</span><br><span class="line"></span><br><span class="line">### 结构</span><br><span class="line"></span><br><span class="line">#### 对象适配器：</span><br><span class="line"></span><br><span class="line">适配器实现其冲一个对象的借口，并对另一个对象进行封装。</span><br><span class="line"></span><br><span class="line">![adapter_3](/posts/Design-Pattern/adapter_3.png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 客户端 （Client） 是包含当前程序业务逻辑的类。 </span><br><span class="line"><span class="number">2.</span> 客户端接口 （Client Inter­face） 描述了其他类与客户端代码合作时必须遵循的协议。 </span><br><span class="line"><span class="number">3.</span> 服务 （Ser­vice） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。 </span><br><span class="line"><span class="number">4.</span> 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时**封装了服务对象**。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。 </span><br><span class="line"><span class="number">5.</span> 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</span><br><span class="line"></span><br><span class="line">#### 类适配器</span><br><span class="line"></span><br><span class="line">主要运用了继承机制，适配器同时继承了两个对象的接口（所以需要支持多重继承的语言 比如，C++）</span><br><span class="line"></span><br><span class="line">![adapter_4](/posts/Design-Pattern/adapter_4.png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。 </span><br><span class="line"></span><br><span class="line">### 代码样例</span><br><span class="line"></span><br><span class="line">![adapter_5](/posts/Design-Pattern/adapter_5.png)</span><br><span class="line"></span><br><span class="line">适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//&nbsp;假设你有两个接口相互兼容的类：圆孔（Round­Hole）和圆钉（Round­Peg）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">RoundHole</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">RoundHole</span><span class="params">(radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回孔的半径。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">fits</span><span class="params">(peg:&nbsp;RoundPeg)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="built_in">this</span>.getRadius()&nbsp;&gt;=&nbsp;peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">RoundPeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">RoundPeg</span><span class="params">(radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回钉子的半径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;但还有一个不兼容的类：方钉（Square­Peg）。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">SquarePeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">SquarePeg</span><span class="params">(width)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getWidth</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回方钉的宽度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;适配器类让你能够将方钉放入圆孔中。它会对&nbsp;RoundPeg&nbsp;类进行扩展，以接收适</span></span><br><span class="line"><span class="comment">//&nbsp;配器对象作为圆钉。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">SquarePegAdapter</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">RoundPeg</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;在实际情况中，适配器中会包含一个&nbsp;SquarePeg&nbsp;类的实例。</span></span><br><span class="line">&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;field peg:&nbsp;SquarePeg</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">SquarePegAdapter</span><span class="params">(peg:&nbsp;SquarePeg)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.peg&nbsp;=&nbsp;peg</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">getRadius</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;适配器会假扮为一个圆钉，</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;peg.getWidth()&nbsp;*&nbsp;Math.sqrt(<span class="number">2</span>)&nbsp;/&nbsp;<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码中的某个位置。</span></span><br><span class="line">hole&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">rpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">hole.fits(rpeg)&nbsp;<span class="comment">//&nbsp;true</span></span><br><span class="line"></span><br><span class="line">small_sqpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">large_sqpeg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">hole.fits(small_sqpeg)&nbsp;<span class="comment">//&nbsp;此处无法编译（类型不一致）。</span></span><br><span class="line">    </span><br><span class="line">small_sqpeg_adapter&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">hole.fits(small_sqpeg_adapter)&nbsp;<span class="comment">//&nbsp;true</span></span><br><span class="line">hole.fits(large_sqpeg_adapter)&nbsp;<span class="comment">//&nbsp;false</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="使用场景-6">使用场景</h3><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p><p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p><h3 id="实现方式-3">实现方式</h3><ol><li>确保至少有两个类的接口不兼容：<ul><li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li><li>一个或多个将受益于使用服务类的客户端类。</li></ul></li><li>声明客户端接口， 描述客户端如何与服务交互。</li><li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li><li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li><li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li><li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li></ol><h3 id="与其他模式的关系-2">与其他模式的关系</h3><p><strong>桥接通常会于开发前期进行设计</strong>， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <strong>适配器通常在已有程序中使用</strong>， 让相互不兼容的类能很好地合作。</p><p>适配器可以对已有对象的接口进行修改， <strong>装饰</strong>则能在<strong>不改变对象接口的前提下强化对象功能</strong>。 此外， <strong>装饰还支持递归组合</strong>， 适配器则无法实现。</p><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p><p>外观为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><h2 id="桥接-Bridge">桥接 - Bridge</h2><blockquote><p>桥接是一种结构型设计模式，可将一个「大类」或「一系列紧密相关的类」「拆分」为「抽象」和「实现」两个独立的层次结构，从而能在开发时分别使用。</p></blockquote><h3 id="现实问题-6">现实问题</h3><p>假如你有一个几何 「形状Shape类」， 从它能扩展出两个子类：  「圆形Cir­cle」 和 「方形Square」。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为「红色Red」和「蓝色Blue」的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如「蓝色圆形Blue­Cir­cle」和「红色方形Red­Square」</p><p><img src="/posts/Design-Pattern/bridge_1.png" alt="bridge_1"></p><p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。</p><h3 id="解决方案-6">解决方案</h3><p>这个问题主要是由于「形状」以及「颜色」其实是两个维度的问题。但是放在一个形状类中来进行扩展。而这是继承时容易导致的问题。</p><p><strong>桥接模式通过将「继承」改为「组合」的方式来解决问题</strong></p><p>即抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象从而使得一个类中不必有所有的状态和行为。</p><p><img src="/posts/Design-Pattern/bridge_2.png" alt="bridge_2"></p><p>图示中，我们把颜色相关的代码抽取到红色和蓝色的两个子类的颜色中。然后形状类中添加一个只想某一颜色对象的引用成员变量。那么现在形状类可以将所有与颜色有关的行为交给颜色对象，这种引用就是「形状」和「颜色」之间的桥梁。</p><h4 id="抽象-和-实现">抽象 和 实现</h4><p>抽象部分 - 一般指接口，是一些实体的高阶控制层。该层本身不完成任何「具体」的工作，它需要将工作委派给「实现部分」层</p><blockquote><p>这里的和语言里面的interface 或者 abstract class 没有关系</p></blockquote><p>实际程序中抽象部分是图像用户界面（GUI），而实现部分则是底层操作系统代码（API），GUI层调用API层来对用户的各种操作做出回应。</p><p>一般来说， 你可以在两个独立方向上扩展这种应用：</p><ul><li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li><li>支持多个不同的 API （例如， 能够在 Win­dows、 Linux 和 macOS 上运行该程序）。</li></ul><p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种 API。</p><p><img src="/posts/Design-Pattern/bridge_3.png" alt="bridge_3"></p><p>你可以将特定接口-平台的组合代码抽取到独立的类中， 以在混乱中建立一些秩序。 但是， 你很快会发现这种类的数量很多。 类层次将以指数形式增长， 因为每次添加一个新的 GUI 或支持一种新的 API 都需要创建更多的类。<br>让我们试着用桥接模式来解决这个问题。 该模式建议将类拆分为两个类层次结构：</p><p>抽象部分： 程序的 GUI 层。<br>实现部分： 操作系统的 API。</p><p><img src="/posts/Design-Pattern/bridge_4.png" alt="bridge_4"></p><p>抽象对象控制程序的外观， 并将真实工作委派给连入的实现对象。 不同的实现只要遵循相同的接口就可以互换， 使同一GUI 可在 Win­dows 和 Linux 下运行。</p><p>最后的结果是： 你无需改动与 API 相关的类就可以修改 GUI 类。 此外如果想支持一个新的操作系统， 只需在实现部分层次中创建一个子类即可。</p><p>例如，在一个软件系统中，如果你有一个功能是需要在不同的操作系统（如Windows和Linux）上运行，并且每个操作系统都有自己的GUI接口。如果你直接在应用程序的主体中写入所有的GUI代码，那么这会导致代码与平台强绑定，难以维护。</p><p>为了解决这个问题，你可以将与操作系统相关的GUI部分抽象出来，创建独立的类或者接口来管理这些与平台相关的代码。这样，你的主应用程序就不需要直接处理不同操作系统的GUI细节，而是通过这些抽象的接口来与它们通信。当需要支持新的操作系统时，你只需要添加或修改这些独立的类即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个GUI接口，描述所有操作系统都会实现的GUI操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Windows实现GUI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Linux实现GUI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主应用程序，不直接依赖于任何特定的操作系统GUI实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> {</span><br><span class="line">    <span class="keyword">private</span> GUI gui;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Application</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">this</span>.gui = gui;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        gui.drawButton();</span><br><span class="line">        gui.drawWindow();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，选择适当的GUI实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">GUI</span> <span class="variable">windowsGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsGUI</span>();</span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(windowsGUI);</span><br><span class="line">        app.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要更换到Linux GUI，只需要更换GUI实现</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">linuxGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinuxGUI</span>();</span><br><span class="line">        app = <span class="keyword">new</span> <span class="title class_">Application</span>(linuxGUI);</span><br><span class="line">        app.draw();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="结构-6">结构</h3><p><img src="/posts/Design-Pattern/bridge_5.png" alt="bridge_5"></p><ol><li>抽象部分 （Abstrac­tion） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li><li>实现部分 （Imple­men­ta­tion） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。<br>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</li><li>具体实现 （Con­crete Imple­men­ta­tions） 中包括特定于平台的代码。</li><li>精确抽象 （Refined Abstrac­tion） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li><li>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li></ol><p>从您提供的图片中，我们可以看到桥接模式的结构，它包含以下部分：</p><ol><li><strong>抽象化 (Abstraction)</strong>: 定义高层的接口，它依赖于实现化角色提供的接口进行工作。这是一个核心的角色，它包含对实现化角色的引用。</li><li><strong>实现化 (Implementation)</strong>: 是接口或抽象类，定义了实现化角色必须实现的接口，但不负责具体的实现。</li><li><strong>具体实现化 (Concrete Implementations)</strong>: 实现化角色的具体实现，根据实现化接口来提供具体的操作方法。</li><li><strong>改进抽象化 (Refined Abstraction)</strong>: 是抽象化的子类，扩展或完善了父类定义的方法和属性。</li><li><strong>客户端 (Client)</strong>: 使用抽象化角色定义的接口操作。</li></ol><p>我们可以将 <code>Application</code> 类看作是<strong>抽象化</strong>角色，<code>GUI</code> 接口是<strong>实现化</strong>角色，而 <code>WindowsGUI</code> 和 <code>LinuxGUI</code> 类是<strong>具体实现化</strong>角色。要更明确地映射到桥接模式，具体来说，我们可以创建一个 <code>RefinedGUI</code> 类，它继承自 <code>GUI</code> 接口并添加一些特定的功能。同时，我们可以创建一个客户端类来直接与 <code>Application</code> 类交互。以下是调整后的代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationGUI</span> {</span><br><span class="line">    <span class="keyword">protected</span> GUI gui;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ApplicationGUI</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">this</span>.gui = gui;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedApplicationGUI</span> <span class="keyword">extends</span> <span class="title class_">ApplicationGUI</span> {</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedApplicationGUI</span><span class="params">(GUI gui)</span> {</span><br><span class="line">        <span class="built_in">super</span>(gui);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 使用GUI接口提供的方法</span></span><br><span class="line">        gui.drawButton();</span><br><span class="line">        gui.drawWindow();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加一些改进的操作方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawMenu</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"使用 "</span> + gui.getClass().getSimpleName() + <span class="string">" 绘制菜单"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现化角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Windows风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxGUI</span> <span class="keyword">implements</span> <span class="title class_">GUI</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawButton</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的按钮"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawWindow</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"绘制Linux风格的窗口"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 客户端决定使用的具体实现化角色</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">windowsGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsGUI</span>();</span><br><span class="line">        <span class="type">ApplicationGUI</span> <span class="variable">appGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefinedApplicationGUI</span>(windowsGUI);</span><br><span class="line">        appGUI.draw();</span><br><span class="line">        appGUI.drawMenu();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以轻松切换到Linux GUI</span></span><br><span class="line">        <span class="type">GUI</span> <span class="variable">linuxGUI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinuxGUI</span>();</span><br><span class="line">        appGUI = <span class="keyword">new</span> <span class="title class_">RefinedApplicationGUI</span>(linuxGUI);</span><br><span class="line">        appGUI.draw();</span><br><span class="line">        appGUI.drawMenu();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个调整后的示例中，<code>RefinedApplicationGUI</code> 是一个改进的抽象化角色，它扩展了 <code>ApplicationGUI</code> 抽象化角色的功能。<code>Client</code> 类则充当了客户端角色，它决定使用哪个具体实现化角色，并通过改进的抽象化角色来使用这些功能。这样的结构更清晰地展现了桥接模式的所有组成部分。</p><h3 id="代码样例-2">代码样例</h3><p><img src="/posts/Design-Pattern/bridge_6.png" alt="bridge_6"></p><p>「设备Device类」作为实现部分， 而「遥控器Remote类」则作为抽象部分。</p><p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。<br>我们可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。<br>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//&nbsp;“抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span><br><span class="line">//&nbsp;现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span><br><span class="line">class&nbsp;RemoteControl&nbsp;is</span><br><span class="line">&nbsp;&nbsp;protected&nbsp;field device:&nbsp;Device</span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;RemoteControl(device:&nbsp;Device)&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;this.device&nbsp;=&nbsp;device</span><br><span class="line">&nbsp;&nbsp;method&nbsp;togglePower()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(device.isEnabled())&nbsp;then</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device.disable()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;else</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device.enable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;volumeDown()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(device.getVolume()&nbsp;-&nbsp;10)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;volumeUp()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(device.getVolume()&nbsp;+&nbsp;10)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;channelDown()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setChannel(device.getChannel()&nbsp;-&nbsp;1)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;channelUp()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setChannel(device.getChannel()&nbsp;+&nbsp;1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;你可以独立于设备类的方式从抽象层中扩展类。</span><br><span class="line">class&nbsp;AdvancedRemoteControl&nbsp;extends&nbsp;RemoteControl&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;mute()&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;device.setVolume(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;“实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span><br><span class="line">//&nbsp;匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span><br><span class="line">//&nbsp;抽象接口则会基于这些操作定义较高层次的操作。</span><br><span class="line">interface&nbsp;Device&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;isEnabled()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;enable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;disable()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;getVolume()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;setVolume(percent)</span><br><span class="line">&nbsp;&nbsp;method&nbsp;getChannel()</span><br><span class="line">&nbsp;&nbsp;method&nbsp;setChannel(channel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&nbsp;所有设备都遵循相同的接口。</span><br><span class="line">class&nbsp;Tv&nbsp;implements&nbsp;Device&nbsp;is</span><br><span class="line">&nbsp;&nbsp;//&nbsp;...</span><br><span class="line"></span><br><span class="line">class&nbsp;Radio&nbsp;implements&nbsp;Device&nbsp;is</span><br><span class="line">// ...</span><br><span class="line">//&nbsp;客户端代码中的某个位置。</span><br><span class="line">tv&nbsp;=&nbsp;new&nbsp;Tv()</span><br><span class="line">remote&nbsp;=&nbsp;new&nbsp;RemoteControl(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio&nbsp;=&nbsp;new&nbsp;Radio()</span><br><span class="line">remote&nbsp;=&nbsp;new&nbsp;AdvancedRemoteControl(radio)</span><br></pre></td></tr></tbody></table></figure><h3 id="应用场景">应用场景</h3><ul><li><p>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p><ul><li>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</li><li>桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</li></ul></li><li><p>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p><ul><li>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</li></ul></li><li><p>如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p><ul><li>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</li></ul></li></ul><h3 id="实现方式-4">实现方式</h3><ol><li>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</li><li>了解客户端的业务需求， 并在抽象基类中定义它们。</li><li>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</li><li>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</li><li>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</li><li>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</li><li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</li></ol><h3 id="与其他模式的关系-3">与其他模式的关系</h3><ul><li>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li><li>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li><li>将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li></ul><p>假设我们有一个应用程序，它可以在不同的数据库上运行。我们的抽象部分是数据库的使用，而具体实现是对各种数据库的操作。</p><p>首先，我们定义一个数据库操作的桥接接口（<code>Database</code>）和它的一些实现（<code>MySQLDatabase</code>, <code>PostgreSQLDatabase</code>）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥接接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDatabase</span> <span class="keyword">implements</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"连接到MySQL数据库"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span> {</span><br><span class="line">        System.out.println(<span class="string">"在MySQL执行: "</span> + query);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现PostgreSQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLDatabase</span> <span class="keyword">implements</span> <span class="title class_">Database</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"连接到PostgreSQL数据库"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String query)</span> {</span><br><span class="line">        System.out.println(<span class="string">"在PostgreSQL执行: "</span> + query);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们使用抽象工厂模式来封装数据库的创建过程，以便为客户端代码隐藏复杂性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    <span class="keyword">abstract</span> Database <span class="title function_">createDatabase</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDatabaseFactory</span> <span class="keyword">extends</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    Database <span class="title function_">createDatabase</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLDatabase</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂PostgreSQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLDatabaseFactory</span> <span class="keyword">extends</span> <span class="title class_">DatabaseFactory</span> {</span><br><span class="line">    Database <span class="title function_">createDatabase</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PostgreSQLDatabase</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(DatabaseFactory factory)</span> {</span><br><span class="line">        database = factory.createDatabase();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        database.connect();</span><br><span class="line">        database.execute(<span class="string">"SELECT * FROM table"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在客户端代码中，我们不直接与具体的数据库实现打交道，而是通过抽象工厂提供的接口来创建和使用数据库。</p><ul><li>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</li></ul><p>假设我们正在构建一个报告生成系统，其中报告的内容（抽象部分）可以独立于报告的格式（具体实现部分）。</p><p>首先，我们定义一个报告的桥接接口（<code>Report</code>）和它的一些实现（<code>PDFReport</code>, <code>HTMLReport</code>）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥接接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现PDF</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDFReport</span> <span class="keyword">implements</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"生成PDF报告"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现HTML</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLReport</span> <span class="keyword">implements</span> <span class="title class_">Report</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"生成HTML报告"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们使用生成器模式来封装报告的构建过程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报告生成器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    <span class="keyword">protected</span> Report report;</span><br><span class="line"></span><br><span class="line">    ReportBuilder <span class="title function_">buildPartA</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 构建报告的一部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ReportBuilder <span class="title function_">buildPartB</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 构建报告的另一部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Report <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器PDF</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDFReportBuilder</span> <span class="keyword">extends</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    PDFReportBuilder() {</span><br><span class="line">        report = <span class="keyword">new</span> <span class="title class_">PDFReport</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Report <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> report;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器HTML</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLReportBuilder</span> <span class="keyword">extends</span> <span class="title class_">ReportBuilder</span> {</span><br><span class="line">    HTMLReportBuilder() {</span><br><span class="line">        report = <span class="keyword">new</span> <span class="title class_">HTMLReport</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Report <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> report;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主管类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReportDirector</span> {</span><br><span class="line">    <span class="keyword">private</span> ReportBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReportDirector</span><span class="params">(ReportBuilder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Report <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> builder.buildPartA().buildPartB().build();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReportBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PDFReportBuilder</span>();</span><br><span class="line">        <span class="type">ReportDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReportDirector</span>(builder);</span><br><span class="line">        <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        report.generate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>ReportBuilder</code> 是桥接模式的一个组成部分，它将报告的创建过程从具体的报告格式中抽象出来。<code>ReportDirector</code> 作为主管类，负责根据客户端的需求使用不同的生成器构建报告。这种方式允许我们独立于报告的具体实现来构建报告的内容。</p><h2 id="组合-对象树-Object-Tree-Composite">组合 - 对象树, Object Tree, Composite</h2><blockquote><p>将对象组合成树状结构，并且像独立使用对立对象一样使用</p></blockquote><h3 id="现实问题-7">现实问题</h3><p>如果应用的核心模型可以用树状结构表示，在应用中使用组合模式才有价值</p><p>主要是一些层级结构：产品和盒子，比如一个盒子可以包含多个产品或者几个较小的盒子。小盒子里又有一些其他的产品或者更小的盒子</p><p>我们现在开发一个订购系统。订单中可以包含无包装的简单产品，也可以包含装满产品的盒子。那么此时应该如何计算总价格就成了问题，一个简单的方法就是一直递归到最底层然后计算总价。</p><h3 id="解决方案-7">解决方案</h3><p>组合模式建议使用一个通用接口来 「产品」 和「盒子」进行交互，并且在该接口中declare一个计算总价的方法</p><p>具体的，设计方法时候，对于产品，我们直接返回价格。对于盒子方法就会看盒子中间的所有内容，询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p><p><img src="/posts/Design-Pattern/composite_1.png" alt="composite_1"></p><p>通过使用这种方式，我们不需要知道树里面对象的具体类。只需要使用通用接口来进行相同的处理，化繁为简。</p><p>一个其他的例子包含：</p><p>大部分国家的军队都采用层次管理，军师旅团营连排</p><h3 id="结构-7">结构</h3><p><img src="/posts/Design-Pattern/composite_2.png" alt="composite_2"></p><ol><li><p>组件 （Com­po­nent） 接口描述了树中简单项目和复杂项目所共有的操作。</p></li><li><p>叶节点 （Leaf） 是树的基本结构， 它不包含子项目。<br>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p></li><li><p>容器 （Con­tain­er）——又名 “组合 （Com­pos­ite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p><p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p></li><li><p>客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p></li></ol><p>这里的 <code>add</code> <code>remove</code> <code>getChildren</code>就是comosite作用于自身field的方法，即比如加入/去掉元素到<code>Component[]</code>或者 返回 整个<code>Component[]</code></p><h3 id="代码样例-3">代码样例</h3><p><img src="/posts/Design-Pattern/composite_3.png" alt="composite_3"></p><p>组合图形 == 容器（组合）它由多个包含容器在内的字图形构成。它们有相同的方比如「move」「draw」但是组合图形本身不完成具体工作。而是一直将请求递归传递给子项目，汇总结果</p><p>通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;组件接口会声明组合中简单和复杂对象的通用操作。</span></span><br><span class="line"><span class="keyword">interface</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象</span></span><br><span class="line"><span class="comment">//&nbsp;通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Dot</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field x,&nbsp;y</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Dot</span><span class="params">(x,&nbsp;y)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">this</span>.x&nbsp;+=&nbsp;x,&nbsp;<span class="built_in">this</span>.y&nbsp;+=&nbsp;y</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在坐标位置(X,Y)处绘制一个点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;所有组件类都可以扩展其他组件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">Circle</span>&nbsp;<span class="keyword">extends</span>&nbsp;<span class="title class_">Dot</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field radius</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;constructor&nbsp;<span class="title function_">Circle</span><span class="params">(x,&nbsp;y,&nbsp;radius)</span>&nbsp;{&nbsp;...&nbsp;}</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在坐标位置(X,Y)处绘制一个半径为&nbsp;R&nbsp;的圆。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项</span></span><br><span class="line"><span class="comment">//&nbsp;目，然后“汇总”结果。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">CompoundGraphic</span>&nbsp;<span class="keyword">implements</span>&nbsp;<span class="title class_">Graphic</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field children:&nbsp;array&nbsp;of&nbsp;Graphic</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">add</span><span class="params">(child:&nbsp;Graphic)</span>&nbsp;is</span><br><span class="line">    <span class="comment">//&nbsp;在子项目数组中添加一个子项目。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">remove</span><span class="params">(child:&nbsp;Graphic)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;从子项目数组中移除一个子项目。</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">move</span><span class="params">(x,&nbsp;y)</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="title function_">foreach</span>&nbsp;<span class="params">(child&nbsp;in&nbsp;children)</span>&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.move(x,&nbsp;y)</span><br><span class="line">  <span class="comment">//&nbsp;组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，</span></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;最后组合将会完成整个对象树的遍历工作。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">draw</span><span class="params">()</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;1.&nbsp;对于每个子部件：</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;绘制该部件。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;更新边框坐标。</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;2.&nbsp;根据边框坐标绘制一个虚线长方形。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&nbsp;客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同</span></span><br><span class="line"><span class="comment">//&nbsp;时支持简单叶节点组件和复杂组件。</span></span><br><span class="line"><span class="keyword">class</span>&nbsp;<span class="title class_">ImageEditor</span>&nbsp;is</span><br><span class="line">&nbsp;&nbsp;field all:&nbsp;CompoundGraphic</span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">load</span><span class="params">()</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">all</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CompoundGraphic</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;all.add(<span class="keyword">new</span>&nbsp;“<span class="keyword">new</span>&nbsp;<span class="title class_">Dot</span>(<span class="number">1</span>,&nbsp;<span class="number">2</span>))</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;all.add(<span class="keyword">new</span>&nbsp;<span class="title class_">Circle</span>(<span class="number">5</span>,&nbsp;<span class="number">3</span>,&nbsp;<span class="number">10</span>))</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...</span></span><br><span class="line"></span><br><span class="line">&nbsp;&nbsp;<span class="comment">//&nbsp;将所需组件组合为复杂的组合组件。</span></span><br><span class="line">&nbsp;&nbsp;method&nbsp;<span class="title function_">groupSelected</span><span class="params">(components:&nbsp;array&nbsp;of&nbsp;Graphic)</span>&nbsp;<span class="type">is</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">group</span>&nbsp;<span class="operator">=</span>&nbsp;<span class="keyword">new</span>&nbsp;<span class="title class_">CompoundGraphic</span>()</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(component&nbsp;in&nbsp;components)&nbsp;<span class="keyword">do</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.add(component)</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all.remove(component)</span><br><span class="line">    all.add(group)</span><br><span class="line">    <span class="comment">//&nbsp;所有组件都将被绘制。</span></span><br><span class="line">    all.draw()</span><br></pre></td></tr></tbody></table></figure><h3 id="应用场景-2">应用场景</h3><ul><li>树状对象结构，考虑使用组合模式<ul><li>组合模式有两种共享公共接口的基本元素类型：简单叶子结点和复杂组合容器。容器可以包含其他叶子结点或容器。从而组成树状嵌套递归对象结构</li></ul></li><li>客户端代码想要用相同方式处理简单和复杂元素，考虑使用组合模式<ul><li>所有元素公用同一个接口。在这个借口的帮助下客户端不需要在意所用的对象的具体类</li></ul></li></ul><h3 id="实现方式-5">实现方式</h3><ol><li>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</li><li>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</li><li>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</li><li>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为<strong>组合接口类型</strong>。<br>实现组件接口方法时， 记住容器应该将<strong>大部分工作交给其子元素来完成。</strong></li><li>最后， 在容器中定义添加和删除子元素的方法。<br>记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</li></ol><h3 id="优缺点">优缺点</h3><ul><li>充分利用多态和递归</li><li>开闭原则，无需更改已有代码，在应用中添加新元素，使其成为对象树的一部分</li><li>缺点：对于功能差异比较的，找公共接口会很复杂</li></ul><h3 id="和其他模式的关系">和其他模式的关系</h3><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><h4 id="Builder-Composite">Builder + Composite</h4><p>你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p><p>为了更好地体现“在创建复杂组合树时使用生成器，因为这可使其构造步骤以递归的方式运行”的思想，我们可以构建一个更为复杂的例子，比如一个公司组织结构的树形表示，其中包含多个层级的部门和员工。我们将使用组合模式来表示组织结构的层次，同时使用生成器模式来递归地构建这个结构。这个例子中，我们将特别注意在代码中添加注释，以解释关键步骤和设计选择。</p><p>组合模式部分</p><p>首先，我们定义组合模式相关的类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组织结构的组件接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点：表示一个员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String position)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(position + <span class="string">": "</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点：表示一个部门，可以包含其他部门或员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">implements</span> <span class="title class_">OrganizationComponent</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrganizationComponent&gt; members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成员，可以是部门或员工</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMember</span><span class="params">(OrganizationComponent member)</span> {</span><br><span class="line">        members.add(member);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStructure</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Department: "</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent member : members) {</span><br><span class="line">            member.printStructure();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生成器模式部分</p><p>接下来，我们定义生成器模式相关的类，以支持递归地构建组织结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组织结构的生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrganizationBuilder</span> {</span><br><span class="line">    <span class="keyword">private</span> Department root;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Department&gt; departmentStack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationBuilder</span><span class="params">(String rootName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Department</span>(rootName);</span><br><span class="line">        departmentStack.push(root); <span class="comment">// 将根部门压栈作为当前操作的部门</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个部门，新部门自动成为当前操作的部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">addDepartment</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="type">Department</span> <span class="variable">newDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(name);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">current</span> <span class="operator">=</span> departmentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) {</span><br><span class="line">            current.addMember(newDepartment);</span><br><span class="line">            departmentStack.push(newDepartment); <span class="comment">// 将新部门压栈</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个员工到当前操作的部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">addEmployee</span><span class="params">(String name, String position)</span> {</span><br><span class="line">        <span class="type">Department</span> <span class="variable">current</span> <span class="operator">=</span> departmentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) {</span><br><span class="line">            current.addMember(<span class="keyword">new</span> <span class="title class_">Employee</span>(name, position));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前部门的构建，返回上一级部门</span></span><br><span class="line">    <span class="keyword">public</span> OrganizationBuilder <span class="title function_">endDepartment</span><span class="params">()</span> {</span><br><span class="line">        departmentStack.pop(); <span class="comment">// 结束当前部门的构建，弹出栈顶部门</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最终的组织结构，返回根部门</span></span><br><span class="line">    <span class="keyword">public</span> Department <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例使用</p><p>最后，我们使用这些类来构建一个示例公司的组织结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeBuilderDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 使用生成器递归构建组织结构</span></span><br><span class="line">        <span class="type">OrganizationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrganizationBuilder</span>(<span class="string">"Head Office"</span>)</span><br><span class="line">                .addDepartment(<span class="string">"R&amp;D"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Alice"</span>, <span class="string">"Engineer"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Bob"</span>, <span class="string">"Engineer"</span>)</span><br><span class="line">                    .endDepartment()</span><br><span class="line">                .addDepartment(<span class="string">"HR"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Charlie"</span>, <span class="string">"Recruiter"</span>)</span><br><span class="line">                    .addEmployee(<span class="string">"Dana"</span>, <span class="string">"Coordinator"</span>)</span><br><span class="line">                    .endDepartment();</span><br><span class="line"></span><br><span class="line">        <span class="type">Department</span> <span class="variable">company</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        company.printStructure(); <span class="comment">// 打印整个组织结构</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，我们首先创建了一个<code>OrganizationBuilder</code>实例，指定了公司的根部门名为"Head Office"。然后，我们递归地添加了两个部门"R&amp;D"和"HR"，以及它们各自的员工。<code>addDepartment</code>方法让我们可以添加一个新的部门，并自动将其设置为当前操作的部门，这支持了递归地构建部门结构。通过调用<code>endDepartment</code>方法，我们结束当前部门的构建，并回到上一级部门。最后，我们通过调用<code>build</code>方法完成整个组织结构的构建，并打印出来。</p><p>这个例子展示了如何结合使用组合模式和生成器模式来递归地构建和管理一个复杂的树形结构，同时保持代码的清晰和可维护性。</p><p>责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p><p>你可以使用迭代器来遍历组合树。</p><p>你可以使用访问者对整个组合树执行操作。</p><p>你可以使用享元实现组合树的共享叶节点以节省内存。</p><p>组合和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。<br>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。<br>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p><p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p><h2 id="装饰-装饰者，装饰器，Decorator-Wrapper">装饰 - 装饰者，装饰器，Decorator, Wrapper</h2><blockquote><p>装饰模式允许我们通过将对象放入包含行为的特殊服装对象中来为原对象绑定新行为</p></blockquote><p><img src="/posts/Design-Pattern/decorator-2x.png" alt="decorator-2x"></p><h3 id="现实问题-8">现实问题</h3><p>假设正在开发一个提供通知功能的库，其他程序使用它向用户发送关于重要事件的通知</p><p>库最初版本基于「通知器 Notifier」类，此时只有很少几个成员变量，一个构造函数以及一个「send」方法。这个方法可以接受来自客户端的消息作为参数。并将信息发送一个订阅邮箱。邮箱列表通过构造函数传递给通知器。创建和配置通知器仅被调用一次，然后发送给对应的邮箱当重要事情发生时</p><p>为了构建一个提供通知功能的库的最初版本，我们首先定义一个简单的<code>Notifier</code>类。这个类将包含一个用于存储订阅邮箱列表的成员变量，一个构造函数来初始化这个列表，以及一个<code>send</code>方法用于将消息发送给所有订阅的邮箱。这里是一个简单的Java实现示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notifier</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; emailList; <span class="comment">// 存储订阅邮箱列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，通过它传递邮箱列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Notifier</span><span class="params">(List&lt;String&gt; emailList)</span> {</span><br><span class="line">        <span class="built_in">this</span>.emailList = emailList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到所有订阅的邮箱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">for</span> (String email : emailList) {</span><br><span class="line">            <span class="comment">// 模拟发送消息过程</span></span><br><span class="line">            System.out.println(<span class="string">"Sending message to "</span> + email + <span class="string">": "</span> + message);</span><br><span class="line">            <span class="comment">// 实际应用中，这里会有发送邮件的逻辑</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>Notifier</code>类定义了基础的通知功能。构造函数<code>Notifier(List&lt;String&gt; emailList)</code>接受一个包含邮箱地址的列表，这些邮箱是消息的目标接收者。<code>send(String message)</code>方法遍历这个列表，并为每个邮箱打印一条消息，代表发送过程。在实际应用中，这里会包含实际发送邮件的代码逻辑。</p><p>使用这个类的示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 初始化订阅邮箱列表</span></span><br><span class="line">        List&lt;String&gt; emails = Arrays.asList(<span class="string">"user1@example.com"</span>, <span class="string">"user2@example.com"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建通知器实例</span></span><br><span class="line">        <span class="type">Notifier</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notifier</span>(emails);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送通知消息</span></span><br><span class="line">        notifier.send(<span class="string">"Hello, this is an important notification message!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，我们首先创建了一个包含两个邮箱地址的列表。然后，我们使用这个列表创建了一个<code>Notifier</code>实例。通过调用<code>send</code>方法，我们向所有订阅的邮箱发送了一个消息。</p><p>这个简单的实现展示了通知库最初版本的核心功能。在这个阶段，我们没有考虑使用装饰器模式来扩展功能，而是专注于实现基本的通知发送功能。之后，可以通过装饰器模式添加额外的功能，如日志记录、消息加密、错误处理等，而不影响现有的<code>Notifier</code>类。</p><p>然后未来我们发现我们不单单需要邮箱通知，我们还希望有手机短信通知，微信通知，QQ通知等等</p><p><img src="/posts/Design-Pattern/decorator_1.png" alt="decorator_1"></p><p>这里的挑战是，客户端需要传入类型，通过类型来调用对应的发送方法。</p><p>而且如果我们需要组合一起的时候，比如腾讯用户，那么我们需要wechat 和 QQ，比如信息用户，SMS + Wechat 等等，此时就会发生子类梯度爆炸</p><p><img src="/posts/Design-Pattern/decorator_2.png" alt="decorator_2"></p><h3 id="解决方案-8">解决方案</h3><p>如果对每一个需要扩展的功能都是使用继承然后扩展一个子类那么很容易就会出现由于继承导致的子类数量爆炸的问题</p><p>我们可以使用组合：</p><p>两者的工作方式几乎一模一样： 一个对象包含指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为， 它们自己能够完成这些工作。</p><p>组合是许多设计模式背后的关键原则</p><p><img src="/posts/Design-Pattern/decorator_3.png" alt="decorator_3"></p><p>对于装饰模式，又称其为封装器模式。封装器是一个能与其他目标对象链接的对象。封装器包含与目标对象相同的一系列方法，他会<strong>把所有接收到的请求委派给目标对象</strong>。但是封装器也可以再把请求交给目标对象前后进行处理。</p><p>封装器需要实现和其封装对象相同的接口，我们可以将一个对象放入多个封装器中，并在对象中添加封装器的组合行为</p><p>在之前的例子中，我们可以将邮件通知这个default行为放在基类<code>Notifier</code>中然后把其他通知方法放在装饰器中</p><p><img src="/posts/Design-Pattern/decorator_4.png" alt="decorator_4"></p><p>对于上述问题的客户端代码来说把</p>]]></content>
      
      
      <categories>
          
          <category> 工程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股文</title>
      <link href="/posts/%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/posts/%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1>Spark vs MapReduce:</h1><p>All are used in big data processing, but Spark uses in-memory while map reduce uses disk-based processing.</p><p>For spark, it has other features including lazy evaluation, computations are not executed until like saving or counting is performed. And the data structure in Spark is RDD. Resilient Distributed datasets. These are immutable and can be processed in parallel acroos a cluster. Unlike MapReduce’s linear data flow model. Spark uses DAGs.</p><p>For MapReduce, it is a two phase processing; First map and then reduce. At the map phase, proces and transforms the input data into k-v pairs and in the reduce phase, aggregate and combiens output of the map phase to produce results.</p><p>So, Spark is faster and ease to use. And mapreduce is reliable for a linear and large-scale data processing tasks.</p><h1>Mutex vs Semaphore</h1><p>Mutex is used to provide mutual exclusion, i.e., to ensure that only one thread can access a resource (like a variable or section of code) at a time. Locking Mechanism: When a thread locks a mutex, other threads attempting to lock it are blocked until the mutex is unlocked. Ownership: A mutex has the concept of ownership. Only the thread that has acquired a mutex can release it. Use Case: Ideal for protecting shared data/resources in a scenario where only one thread should access the data at a time.</p><p>Semaphores are used to control access to a resource that has a limited number of instances. Counting Mechanism: A semaphore maintains a count, which is decremented by a thread that acquires the semaphore and incremented when a thread releases it.</p><p>No Ownership: Unlike mutexes, semaphores don’t have a specific ownership. Any thread can release a semaphore, not necessarily the one that acquired it.</p><p>Types: There are binary semaphores (which are similar to mutexes) and counting semaphores (which allow multiple accesses up to a set limit).</p><p>Use Case: Useful for limiting access to a resource pool, like database connections.</p><h1>SQL vs NoSQL</h1><p>SQL: structured schema with tables, rows and columns. Data is orgranized into well-defined structures. SQL database provide strong consistency, ensuring the data remains in a valid state at all times. ACID transcations are used to maintain data integrity.</p><p>NoSQL are non-relational and handle various data formats, like semi-structured and unstructured data. About consistency, it offers various consistency models, including eventual consistency. It use BASE (Basically Available, Soft state, Eventually consistent) semantics instead of ACID.</p><h1>Cache:</h1><p>LRU Least Recently Used</p><p>FIFO</p><p>LFU Least Frequently Used</p><h1>Malloc Free Realloc Calloc</h1><p>When call <strong>malloc</strong>, it requests a block of memory of the specified size from the heap. In a segregated free list with a better-fit algorithm, malloc will search the segregated free lists to find a block that closely matches the requested size (but is slightly larger to avoid fragmentation).</p><p><strong>free</strong> is used to deallocate memory previously allocated by malloc, realloc, or calloc. When you call free, it marks the corresponding block of memory as free in the segregated free list.</p><p>In a better-fit algorithm, free may involve coalescing (merging) adjacent free blocks to prevent memory fragmentation and to maintain the list of free blocks efficiently</p><p><strong>realloc</strong> is used to resize a previously allocated block of memory. It can be used to make a block of memory larger or smaller. When you call realloc, it may perform one of the following actions:</p><p>If the requested size is smaller than the current block’s size, it may split the block, marking part of it as free and returning a pointer to the remaining portion. If the requested size is larger than the current block’s size, it may search for a larger free block in the segregated free list. If found, it may move the data to the new block and return a pointer to it. In a better-fit algorithm, realloc will try to find the best-fit block that minimizes waste and fragmentation.</p><p><strong>calloc</strong> stands for “contiguous allocation.” It is used to allocate and initialize multiple blocks of memory, typically for arrays or data structures. When call calloc, it allocates a block of memory that can hold a specified number of elements, with each element of a specified size.</p><p><strong>First fit / next fit:</strong> search linearly starting from some location, and pick the first block that fits.</p><p>Next Fit is similar to First Fit but starts searching for free memory from the location where the previous allocation ended. This can help reduce fragmentation compared to First Fit. <strong>Best Fit</strong> searches for the smallest available block of memory that can accommodate a request. This minimizes waste but can lead to fragmentation and is less efficient than other algorithms.</p><p><strong>Segregated free list</strong> is to maintain separate lists of free memory blocks, each list containing blocks of a specific size range. This allows the allocator to quickly locate a suitable free block for a requested memory allocation size without searching through all free blocks</p><h1>Virtual Memory</h1><p>It extends the available physical RAM (Random Access Memory) by temporarily transferring data from RAM to disk storage.</p><p>each process running on a computer system believes it has a complete and dedicated address space that spans from 0 to the maximum address supported by the architecture (e.g., 2^32 addresses in a 32-bit system or 2^64 addresses in a 64-bit system). This illusion is created by the memory management unit (MMU) and the page table. In detail, when a program running on the CPU accesses memory, it uses virtual memory addresses rather than physical addresses. These virtual addresses are translated into physical addresses by the memory management unit (MMU) hardware. For page table, it is is a data structure used by the operating system to map virtual addresses to physical addresses. It keeps track of which pages are currently in RAM and which are stored on disk. It is like as a form of a cache. Page table entries (PTEs) typically store information about the mapping, including whether the page is in RAM (a cache hit in a sense) or needs to be fetched from secondary storage (similar to a cache miss).</p><h1>Stack vs Heap</h1><p>The stack is used for static memory allocation, which includes local variables and function calls.</p><p>Size and Allocation: The stack has a limited size, and memory is allocated in a last-in, first-out (LIFO) manner.</p><p>Speed: Allocation and deallocation on the stack are fast since it involves only moving the stack pointer.</p><p>Lifespan: Variables on the stack exist only within the scope of the function that created them.</p><p>Automatic Management: The compiler automatically manages the stack.</p><p>The heap is used for dynamic memory allocation, where the size and lifetime of variables or objects are not known at compile time.</p><p>Size and Allocation: The heap can typically grow dynamically, limited only by the system’s available memory.</p><p>Speed: Allocation and deallocation on the heap are slower as they require more complex bookkeeping.</p><p>Lifespan: Memory on the heap remains allocated until it’s explicitly freed, often by the programmer.</p><p>Manual Management: In languages like C and C++, programmers must manually manage heap memory, leading to complexities like memory leaks and dangling pointers.</p><h1>Microservices - why not and why</h1><p>Modularity: Microservices allow for breaking down complex applications into smaller, manageable, and independent units. This modular structure makes it easier to understand, develop, and test the application.</p><p>Scalability: Different microservices can be scaled independently, allowing for more efficient resource use. For instance, a component with high demand can be scaled separately without having to scale the entire application.</p><p>Flexibility in Technology: Each microservice can potentially be written in a different programming language or use different data storage technologies, depending on what is best suited for its purpose.</p><p>Faster Deployment and Time to Market: Since microservices can be deployed independently, new features can be brought to market more quickly and with less risk.</p><p>Resilience: A failure in one microservice does not necessarily bring down the whole application, making the application more robust and resilient.</p><p>But:</p><p>Complexity in Coordination: Microservices introduce challenges in communication and coordination between various services. Managing multiple interdependent services can be more complex than managing a monolithic architecture.</p><p>Network Latency: Inter-service communication over the network can introduce latency, which might impact performance.</p><p>Data Management Complexity: Maintaining data consistency and integrity across services can be challenging, especially with each microservice managing its own database.</p><p>Difficulty in Testing: Testing a microservices-based application can be more complex compared to a monolithic application due to the number of services and their interactions.</p><h1>Container vs Virtual Machine</h1><p>They used to create isolated environments for running applications, but they operate differently and serve different purposes in the world of computing.</p><p>VM: run on top of physical server and a hypervisor, like VMware. Each VM includes all necessary bunaries and libraries and entire guest OS. So VM is larger.</p><p>Container:share the host system’s kernel but package the application and its dependencies (libraries, binaries, etc.) into a container image. Lightweight</p><p>They coexist and leveraging the strengths of each technology</p><h1>RestAPI</h1><p>RestAPI is a web service implementation that adheres to the REST architectural constraints. And REST is a set of principles that define how Web standards.</p><p>RestAPI include: Stateless Communication: Each request from client to server must contain all the information needed to understand and process the request. And it has to have a client-server architecture, it needs to use HTTP methods like GET POST PUT DELETE. It should be defined as cacheable or not, and it uses a layered system. Other alternatives are liek GraphQL which uses multiple endpoints to retrieve different data to perform operations. And gRPC which is especially useful for microservice architecture</p><h1>Website DNS:</h1><p>First check the cache in the browser to see if it has a record of the IP address;</p><p>If not, it will do a DNS Query, it wil first go to a local DNS cache, and then reach to internet service providers DNS server, if still not get the IP address, the request will be forwarded to higher-level DNS until the IP is found.</p><p>Once got the IP, our hardware will use ARP to find the MAC address of the gateway router, And then the browser will start like TCP with, of course, handshaking. SYN, SYN-ACK, ACK; And then sending HTTP, if it is HTTPS, it will do some verification and server gives the response after processing the request with some status code as well as contents like HTML, and then the Browser render the page</p><h1>Network Layer:</h1><p>OSI Model: 7 layers: Physical, Data link, network, transport, session, presentation, application;</p><p>Physical: transmission and reception of unstructured raw data between a device and a physical transmission medium</p><p>DataLink: node-to-node data transfer</p><p>Network: Device addressing, routers operate at this layer</p><p>Transport: transfer data between hosts</p><p>Session: Manage sessions between end-user apps</p><p>Presentation: Data encryption</p><p>Application: interacts with the software application</p><p>TCP/IP:</p><p>Link layer, internet layer, transport layer, application layer</p><p>Link (physical and data link)</p><p>Internet: network</p><p>Transport: transport</p><p>Application: Session, presentation, application</p><h1>gRPC</h1><p>HTTP/2 so, it uses TCP for the transport layer, with protocol buffers at the presentation layer.</p><h1>Cloud v.s. Cloud Native</h1><p>“cloud” refers to the computational infrastructure and services available over the internet, “cloud native” refers to a methodology and design philosophy to build and run applications that harness the full potential of cloud computing.</p><p>I usually heard SAAS, PAAS, iaaS</p><p>FaaS</p><p>FaaS, or Function as a Service, is a category of cloud computing services that allows developers to execute and manage individual functions in response to events without the need to manage the infrastructure. This is a subset of serverless computing. It is event driven, like I need to have SQS + SNS + Lamba function to make the SNS trigger the function. It is stateless, short-lived and able to auto scale.</p><h1>Docker vs K8s</h1><p>Docker is a platform that allows us to build, ship, and run applications inside containers. Containers encapsulate an application and its dependencies into a single, consistent unit, making it easy to move across different environments.</p><p>Kubernetes is a container orchestration platform designed to automate the deployment, scaling, and management of containerized applications.</p><p>Docker is about creating and running individual containers.</p><p>Kubernetes is about coordinating clusters of containers, ensuring they work in harmony with one another.</p><h1>Container v.s. Virtual Machine</h1><p>Containers:</p><p>OS-level virtualization.</p><p>Lightweight and fast.</p><p>Share the host’s OS kernel.</p><p>Best for microservices and cloud-native applications.</p><p>Virtual Machines:</p><p>Hardware-level virtualization.</p><p>Heavier, with their own full OS stacks.</p><p>Stronger isolation due to separate kernels.</p><p>Best for strong isolation needs and varied OS requirements on the same host.</p><p>containers can run inside VMs, leveraging the strengths of both technologies.</p><h1>进程 vs 线程 vs 协程</h1><blockquote><p><a href="https://www.cnblogs.com/Survivalist/p/11527949.html">进程 vs 线程 vs 协程</a></p></blockquote><p>Process contains Thread contains Coroutines</p><p>Process between each other are independent, while thread in a process share the memory space, like code, data, stack, and space resources like signals</p><p>Thread and Coroutine: Thread needs locks to make the data consistent while coroutine does not, we can simply check the state in the coroutine;</p><p>包含关系如下：</p><p><img src="/posts/%E5%85%AB%E8%82%A1%E6%96%87/Thread-Process-Coroutine.png" alt="Thread-Process-Coroutine"></p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后缀分解</title>
      <link href="/posts/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"/>
      <url>/posts/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>思路</h1><p>一个prefix数组 一个 suffix 数组</p><p>在<code>idx = i</code>处可以使用<code>prefix</code> 和 <code>suffix</code>的一些性质，比如乘积，或者在<code>i</code>上左边的最小值，右边的最小值</p><p>本质是为了快速的在当前<code>i</code>上能够利用信息避免重复计算</p><h1>题目</h1><p>初见使用在了<a href="https://leetcode.cn/contest/weekly-contest-368/">leetcode 368 周赛</a> Q2:</p><h1><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/">元素和最小的山形三元组 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] rightMin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        leftMin[<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            leftMin[i] = Math.min(leftMin[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        rightMin[n - <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            rightMin[i] = Math.min(rightMin[i + <span class="number">1</span>], nums[i + <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; leftMin[i] &amp;&amp; nums[i] &gt; rightMin[i]) {</span><br><span class="line">                minSum = Math.min(minSum, nums[i] + leftMin[i] + rightMin[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minSum == Integer.MAX_VALUE ? -<span class="number">1</span> : minSum;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摩尔投票</title>
      <link href="/posts/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"/>
      <url>/posts/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247488987&amp;idx=1&amp;sn=6087b1909fea1d24f15353515eee8d93&amp;chksm=fd9cbec4caeb37d235ccad8d59724177784036a60525fa5e7b738267e9a84a572b1545528391&amp;token=1288276346&amp;lang=zh_CN#rd">三叶</a></p></blockquote><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。</span><br><span class="line"></span><br><span class="line">输入：[1,2,5,9,5,9,5,5,5]</span><br><span class="line">输出：5</span><br></pre></td></tr></tbody></table></figure><p><strong>摩尔投票 ：在集合中寻找可能存在的多数元素，这一元素在输入的序列重复出现并占到了序列元素的一半以上；在第一遍遍历之后应该再进行一个遍历以统计第一次算法遍历的结果出现次数，确定其是否为众数；如果一个序列中没有占到多数的元素，那么第一次的结果就可能是无效的随机元素。</strong></p><p><strong>换句话说，每次将两个不同的元素进行「抵消」，如果最后有元素剩余，则「可能」为元素个数大于总数一半的那个。</strong></p><p>具体的，我们定义一个变量 来保存那个可能为主要元素的值， 用来记录该值的出现次数。然后在遍历数组 过程中执行如下逻辑：</p><ul><li>如果 为 ：说明之前出现过的 已经被抵消完了，更新一下 为当前值，出现次数为 ：<code>x = nums[i], cnt = 1</code>；</li><li>如果 不为 ：说明之前统计的 还没被抵消完，这是根据 与 是否相等进行计算即可：<code>cnt += nums[i] == x ? 1 : -1</code>。</li></ul><p>当处理完 之后，我们得到了一个**「可能」**的主要元素。注意只是可能，因为我们在处理过程中只使用了 <code>x</code> 和 <code>cnt</code> 来记录，我们是无法确定最后剩下的 是经过多次抵消后剩余的主要元素，还是只是不存在主要元素的数组中的无效随机元素。</p><p>因此我们需要再进行一次遍历，检查这个**「可能」**的主要元素 的出现次数是否超过总数一半。</p><p>O(1) 找众数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) {</span><br><span class="line">                x = i;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cnt += x == i ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) <span class="keyword">if</span> (x == i) cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; n / <span class="number">2</span> ? x : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Array </tag>
            
            <tag> 摩尔投票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re:从1500分开始的竞赛生活</title>
      <link href="/posts/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/"/>
      <url>/posts/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1>序</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要在这里练习</p><p><a href="https://huxulm.github.io/lc-rating/#/zen">https://huxulm.github.io/lc-rating/#/zen</a></p></div><h1>1500 - 1600</h1><blockquote><p>学会从题干假设结论，然后尝试验证结论（写一个）或者数学证明</p></blockquote><h2 id="2507-使用质因数之和替换后可以取到的最小值-1500"><a href="https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/">2507. 使用质因数之和替换后可以取到的最小值</a> - 1500</h2><p>这道题主要是怎么分解质因数，属于数学题。</p><p>用一个外置的while 循环来判断是否结束，然后从 cur 开始分解，分解从2作为因数开始分解，然后更新 min</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestValue</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">nChange</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (nChange != count) {</span><br><span class="line">            nChange = count;</span><br><span class="line">            cur = count;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= cur; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (cur % i == <span class="number">0</span>) {</span><br><span class="line">                        cur /= i;</span><br><span class="line">                        count += i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            min = Math.min(min, count);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1525-字符串的好分割数目-1500"><a href="https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/">1525. 字符串的好分割数目</a> - 1500</h2><p>前后缀分解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSplits</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChar.length;</span><br><span class="line">        <span class="type">int</span>[] leftCount = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightCount = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        Set&lt;Character&gt; left = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; right = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxRight</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            left.add(sChar[i]);</span><br><span class="line">            leftCount[idxLeft] = left.size();</span><br><span class="line">            idxLeft++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            right.add(sChar[i]);</span><br><span class="line">            rightCount[idxRight] = right.size();</span><br><span class="line">            idxRight--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(leftCount).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="comment">// Arrays.stream(rightCount).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (leftCount[i] == rightCount[i]) count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="915-分割数组-1501"><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a> - 1501</h2><p>利用题中性质：<code>left</code> 中的每个元素都小于或等于 <code>right</code> 中的每个元素。 &lt;-&gt;  等价于找 left 最大 &lt;= right 最小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionDisjoint</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// left 每个元素都小于或等于 right 中的每个元素</span></span><br><span class="line">        <span class="comment">// 等价于找 left 最大 &lt;= right 最小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightMin = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) {</span><br><span class="line">                max = nums[i];</span><br><span class="line">            }</span><br><span class="line">            leftMax[i] = max;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) {</span><br><span class="line">                min = nums[i];</span><br><span class="line">            }</span><br><span class="line">            rightMin[i - <span class="number">1</span>] = min;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(leftMax).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="comment">// Arrays.stream(rightMin).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (leftMax[i] &lt;= rightMin[i]) {</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1090-受标签影响的最大值-1501"><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a> - 1501</h2><p>dp做法：（超时）这里忽略了memo的声明需要三重循环，即使是ptthon的@cache也会超时，记忆化在这里并不适用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] values;</span><br><span class="line">    <span class="type">int</span>[] labels;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> numWanted;</span><br><span class="line">    <span class="type">int</span> useLimit;</span><br><span class="line">    Map&lt;Integer, Integer&gt; selectedNumsCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestValsFromLabels</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span>[] labels, <span class="type">int</span> numWanted, <span class="type">int</span> useLimit)</span> {</span><br><span class="line">        <span class="built_in">this</span>.values = values;</span><br><span class="line">        <span class="built_in">this</span>.labels = labels;</span><br><span class="line">        <span class="built_in">this</span>.n = values.length;</span><br><span class="line">        <span class="built_in">this</span>.numWanted = numWanted;</span><br><span class="line">        <span class="built_in">this</span>.useLimit = useLimit;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span> {</span><br><span class="line">        <span class="comment">// System.out.println("ini: " + idx + " " + sum + " " + numWanted + " " + useLimit);</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= n) {</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (memo[idx] != -666) return memo[idx];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resNot</span> <span class="operator">=</span> dp(idx + <span class="number">1</span>, sum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println("not select: " + idx + " " + resNot);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[idx];</span><br><span class="line">        <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> labels[idx];</span><br><span class="line">        <span class="keyword">if</span> (numWanted == <span class="number">0</span>) <span class="keyword">return</span> resNot;</span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.getOrDefault(label, -<span class="number">1</span>) == useLimit) <span class="keyword">return</span> resNot; </span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.containsKey(label)){</span><br><span class="line">            selectedNumsCount.put(label, selectedNumsCount.get(label) + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            selectedNumsCount.put(label, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        numWanted--;</span><br><span class="line">        sum = sum + value;</span><br><span class="line">        <span class="comment">// System.out.println("pre: " + sum + " " + resNot);</span></span><br><span class="line">        <span class="comment">// System.out.println(selectedNumsCount);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resSelected</span> <span class="operator">=</span> dp(idx + <span class="number">1</span>, sum);</span><br><span class="line">        <span class="comment">// System.out.println("after: " + sum + " " + resSelected);</span></span><br><span class="line">        sum = sum - value;</span><br><span class="line">        numWanted++;</span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.get(label) &gt; <span class="number">1</span>) {</span><br><span class="line">            selectedNumsCount.put(label, selectedNumsCount.get(label) - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            selectedNumsCount.remove(label);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// System.out.println(idx + " " + resNot + " " + resSelected);</span></span><br><span class="line">        <span class="comment">// memo[idx] = Math.max(resNot, resSelected);</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(resNot, resSelected);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正确做法：排序 + 计数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestValsFromLabels</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span>[] labels, <span class="type">int</span> numWanted, <span class="type">int</span> useLimit)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span>[][] pairs = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            pairs[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]{values[i], labels[i]};</span><br><span class="line">        }</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (numWanted &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> pairs[i][<span class="number">0</span>], l = pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(l, <span class="number">0</span>) &lt; useLimit) {</span><br><span class="line">                cnt.merge(l, <span class="number">1</span>, Integer::sum);</span><br><span class="line">                numWanted--;</span><br><span class="line">                ans += v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1750-删除字符串两端相同字符后的最短长度-1502"><a href="https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/">1750. 删除字符串两端相同字符后的最短长度</a> - 1502</h2><p>双指针直接模拟：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLength</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (cArr[left] == cArr[right]) {</span><br><span class="line">                <span class="type">char</span> <span class="variable">curDup</span> <span class="operator">=</span> cArr[left];</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right &amp;&amp; cArr[left] == curDup) {</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; left &lt;= right &amp;&amp; cArr[right] == curDup) {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// System.out.println(left + " " + right);</span></span><br><span class="line">                min = Math.min(min, right - left + <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2730-找到最长的半重复子字符串-1502"><a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/">2730. 找到最长的半重复子字符串</a> - 1502</h2><p>滑动窗口:</p><p>当出现重复次数 &gt; 1时，缩短窗口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSemiRepetitiveSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sameCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; n; right++) {</span><br><span class="line">            <span class="keyword">if</span> (cArr[right] == cArr[right - <span class="number">1</span>]) {</span><br><span class="line">                sameCount++;</span><br><span class="line">                <span class="keyword">if</span> (sameCount &gt; <span class="number">1</span>) {</span><br><span class="line">                    left += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; cArr[left] != cArr[left - <span class="number">1</span>]) {</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                    sameCount--;</span><br><span class="line">                }</span><br><span class="line">            } </span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2708-一个小组的最大实力值-1502"><a href="https://leetcode.cn/problems/maximum-strength-of-a-group/">2708. 一个小组的最大实力值</a> - 1502</h2><p>由于数据规模比较小，可以直接爆搜：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">10</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; ls = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxStrength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 选或不选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (ls.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">curMax</span> <span class="operator">=</span> ls.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ls.size(); i++) {</span><br><span class="line">                curMax *= ls.get(i);</span><br><span class="line">            }</span><br><span class="line">            max = Math.max(max, curMax);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前数</span></span><br><span class="line">        dfs(idx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        ls.add(nums[idx]);</span><br><span class="line">        dfs(idx + <span class="number">1</span>);</span><br><span class="line">        ls.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>O(n)</em>: 每一次都取当前的最大和最小，最小的可能是负数，负数和负数相乘能得到一个正数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxStrength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> max;</span><br><span class="line">            max = Math.max(max, Math.max(nums[i], Math.max(min * nums[i], max * nums[i])));</span><br><span class="line">            min = Math.min(min, Math.min(nums[i], Math.min(min * nums[i], temp * nums[i])));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2358-分组的最大数量-1503"><a href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">2358. 分组的最大数量</a> - 1503</h2><p>这是一道数学题：</p><p>排序之后分组</p><p>第一组一个数，第二组两个数，第三组三个数…</p><p>那么一定满足要求：</p><ul><li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li><li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）</li></ul><p>这是因为</p><p>假设 <code>排序后</code>分组：</p><p>a | b, c | d, e, f | …</p><p>a &lt; b &lt; c &lt; d &lt; e &lt; f</p><p>则有</p><p>b + c &lt;= d + e</p><p>因此两个条件都可以满足</p><p>是用数学公式：</p><p>1 + 2 + 3 + … + x &lt;= n</p><p>(1 + x) * x / 2 &lt;= n</p><p>x + x^2 - 2n &lt;= 0</p><p>解一元二次方程</p><p>x^2 + x - 2n &lt;= 0</p><p>(-b + sqrt(b^2 - 4ac)) / 2</p><p>向下取整 因此 x 为：</p><p><code>(-1 + (int) Math.sqrt((double) (1 + 8 * grades.length))) / 2</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGroups</span><span class="params">(<span class="type">int</span>[] grades)</span> {</span><br><span class="line">        <span class="comment">// 数学证明 + 贪心</span></span><br><span class="line">        <span class="keyword">return</span> (-<span class="number">1</span> + (<span class="type">int</span>) Math.sqrt((<span class="type">double</span>) (<span class="number">1</span> + <span class="number">8</span> * grades.length))) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2661-找出叠涂元素-1503"><a href="https://leetcode.cn/problems/first-completely-painted-row-or-column/">2661. 找出叠涂元素</a> - 1503</h2><p>预处理行列，将每一个数代表的位置存储在哈希表中，在遍历<code>arr</code>的过程中快速找到对应行列从而使用<code>行列计算数组</code>「rowCnt」「Colnt」更新来快速找到重叠的元素，第一次碰到的元素一定是下标最小的， 注意m和n <code>rowCnt[x] &gt;= n || colCnt[y] &gt;= m</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstCompleteIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[][] mat)</span> {</span><br><span class="line">        Map&lt;Integer, <span class="type">int</span>[]&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                hm.put(mat[i][j], <span class="keyword">new</span> <span class="title class_">int</span>[]{i, j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] rowCnt = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] colCnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="type">int</span>[] xy = hm.get(arr[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> xy[<span class="number">0</span>], y = xy[<span class="number">1</span>];</span><br><span class="line">            rowCnt[x]++;</span><br><span class="line">            colCnt[y]++;</span><br><span class="line">            <span class="comment">// System.out.println(x + " " + y + " " + rowCnt[x] + " " + colCnt[y]);</span></span><br><span class="line">            <span class="keyword">if</span> (rowCnt[x] &gt;= n || colCnt[y] &gt;= m) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1461-检查一个字符串是否包含所有长度为-K-的二进制子串-1504"><a href="https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/">1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</a> - 1504</h2><ul><li><p>核心在于：</p><ul><li>如何快速查找子串<ul><li>哈希表</li></ul></li><li>以及长度为k可以形成的二进制字符串<ul><li>出现在哈希表中的个数 == (1 &lt;&lt; k) aka 2^k</li></ul></li></ul></li><li><p>滑动窗口优化：</p></li></ul><p><img src="/posts/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/1461%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BC%98%E5%8C%96.png" alt="1461滑动窗口优化"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAllCodes</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; (<span class="number">1</span> &lt;&lt; k) + k - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        Set&lt;Integer&gt; appeared = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(s.substring(<span class="number">0</span>, k), <span class="number">2</span>);</span><br><span class="line">        appeared.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + k &lt;= s.length(); i++) {</span><br><span class="line">            num = (num - ((s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;&lt; (k - <span class="number">1</span>))) * <span class="number">2</span> + s.charAt(i + k - <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">            appeared.add(num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> appeared.size() == (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2104-子数组范围和-1504"><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a> - 1504</h2><p>暴力做法为 枚举左右端点，扫描区间，拿出来最大值最小值，计算，O(n^3) TLE 所以需要预处理：</p><h3 id="区间DP：">区间DP：</h3><p>使用 <code>dp[l][r][1]</code>表示区间 [l, r] 的最大值，<code>dp[l][r][0]</code>表示区间[l,r]的最小值</p><p>初始化，<code>dp[i][i][0] </code>= <code>dp[i][i][1]</code> = <code>nums[i]</code>;</p><p>那么 <code>dp[l][r][1]</code> 为 <code>dp[l][r-1][1]</code> 和 当前 <code>nums[r]</code> 比较得到<code>较大值</code></p><p>那么 <code>dp[l][r][0]</code> 为 <code>dp[l][r-1][0]</code> 和 当前 <code>nums[r]</code> 比较得到<code>较小值</code></p><p>计算汇总答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">subArrayRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][i][<span class="number">0</span>] = dp[i][i][<span class="number">1</span>] = nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; n) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l + len &lt; n) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len;</span><br><span class="line">                dp[l][r][<span class="number">0</span>] = Math.min(dp[l][r - <span class="number">1</span>][<span class="number">0</span>], nums[r]);</span><br><span class="line">                dp[l][r][<span class="number">1</span>] = Math.max(dp[l][r - <span class="number">1</span>][<span class="number">1</span>], nums[r]);</span><br><span class="line">                len++;</span><br><span class="line">            }</span><br><span class="line">            l++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                ans += dp[i][j][<span class="number">1</span>] - dp[i][j][<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空间优化：">空间优化：</h3><h3 id="单调栈：">单调栈：</h3><h2 id="2527-查询数组-Xor-美丽值-1550"><a href="https://leetcode.cn/problems/find-xor-beauty-of-array/">2527. 查询数组 Xor 美丽值</a> - 1550</h2><p>位运算题目，涉及到详细的数学证明：</p><blockquote><p>参考<br>作者：我爱志方小姐<br>链接：<a href="https://leetcode.cn/problems/find-xor-beauty-of-array/">https://leetcode.cn/problems/find-xor-beauty-of-array/</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(a | a) &amp; a     (b | a) &amp; a     (c | a) &amp; a</span><br><span class="line">(a | a) &amp; b     (b | a) &amp; b     (c | a) &amp; b</span><br><span class="line">(a | a) &amp; c     (b | a) &amp; c     (c | a) &amp; c</span><br><span class="line"></span><br><span class="line">(a | b) &amp; a     (b | b) &amp; a     (c | b) &amp; a</span><br><span class="line">(a | b) &amp; b     (b | b) &amp; b     (c | b) &amp; b</span><br><span class="line">(a | b) &amp; c     (b | b) &amp; c     (c | b) &amp; c</span><br><span class="line"></span><br><span class="line">(a | c) &amp; a     (b | c) &amp; a     (c | c) &amp; a</span><br><span class="line">(a | c) &amp; b     (b | c) &amp; b     (c | c) &amp; b</span><br><span class="line">(a | c) &amp; c     (b | c) &amp; c     (c | c) &amp; c</span><br></pre></td></tr></tbody></table></figure><p>根据 按位或 的 对称性，即 x | y = y | x，我们不难发现上面的分块矩阵是一个 对称矩阵，也就是说所有元素的 异或 等于对角线元素的 异或，我们保留 对角线元素(块)，得到如下 3 x 3 矩阵：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a | a) &amp; a     (b | b) &amp; a     (c | c) &amp; a</span><br><span class="line">(a | a) &amp; b     (b | b) &amp; b     (c | c) &amp; b</span><br><span class="line">(a | a) &amp; c     (b | b) &amp; c     (c | c) &amp; c</span><br></pre></td></tr></tbody></table></figure><p>由于 <code>a | a = a</code>, <code>a &amp; a = a</code>，我们将上面的矩阵再化简一下，有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a       b &amp; a     c &amp; a</span><br><span class="line">a &amp; b       b       c &amp; b</span><br><span class="line">a &amp; c     b &amp; c       c</span><br></pre></td></tr></tbody></table></figure><p>再根据 <code>按位与</code> 运算的 <code>对称性</code>，即 <code>x &amp; y = y &amp; x</code>，我们不难发现，这又是一个 <code>对称矩阵</code>，所有元素的 <code>异或</code> 等于对角线元素的 <code>异或</code>，即：</p><p><code>a ^ b ^ c</code></p><p>因此，我们有如下结论：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums 的 <span class="keyword">xor</span> 美丽值即为 nums 所有元素的异或值。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">xorBeauty</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Arrays.stream(nums).reduce(<span class="number">0</span>, (sub, cur) -&gt; sub ^ cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2780-合法分割的最小下标-1550"><a href="https://leetcode.cn/problems/minimum-index-of-a-valid-split/">2780. 合法分割的最小下标</a> - 1550</h2><p>方法1：两个哈希表</p><p>一个哈希表记录每一个元素的总数，一个哈希表记录当前遍历过程中出现的元素次数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumIndex</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        Map&lt;Integer, Integer&gt; hmAll = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            hmAll.put(num, hmAll.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        Map&lt;Integer, Integer&gt; hmCur = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.get(i);</span><br><span class="line">            hmCur.put(num, hmCur.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (hmCur.get(num) * <span class="number">2</span> &gt; i + <span class="number">1</span> &amp;&amp; (hmAll.get(num) - hmCur.get(num)) * <span class="number">2</span> &gt; nums.size() - i - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法2：数学推理 + 摩尔投票</p><p><strong>证明</strong>：分割出的两个数组的支配元素就是原数组的支配元素。</p><p>分割出的两个数组的支配元素就是原数组的支配元素。</p><p>设这两个数组的支配元素为 y（题目要求支配元素相同），那么对于第一个数组有</p><p><code>freq_1(y) * 2 &gt; i+1</code></p><p>对于第二个数组有</p><p><code>freq_2(y) * 2 &gt; n - i - 1</code></p><p>由于这两个数组合并之后就是原数组，所以</p><p><code>freq(y) * 2 = freq_1(y) * 2 + freq_2(y) * 2 &gt; (i+1) + (n-i-1) = n</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumIndex</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> mooreVote(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">modeTot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (num == mode) modeTot++; </span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">modeCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.get(i);</span><br><span class="line">            <span class="keyword">if</span> (num == mode) modeCnt++;</span><br><span class="line">            <span class="keyword">if</span> (modeCnt * <span class="number">2</span> &gt; i + <span class="number">1</span> &amp;&amp; (modeTot - modeCnt) * <span class="number">2</span> &gt; n - <span class="number">1</span> - i) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mooreVote</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums.get(<span class="number">0</span>), cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (x != nums.get(i)) {</span><br><span class="line">                cnt -= <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) {</span><br><span class="line">                x = nums.get(i);</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">countX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (num == x) {</span><br><span class="line">                countX++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (countX &gt; nums.size() / <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>1600 - 1900</h1><h2 id="2316-统计无向图中无法互相到达点对数-1604"><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a> - 1604</h2><p>自我认为一道非常好的题，可以使用DFS，并查集来解题：</p><p>一开始尝试使用了DFS枚举然后去除，暴力超时</p><p>后采用并查集，通过计算乘法原理 O(N^2)</p><p>进行数学优化，直接相乘除二即可，O(N + M)</p><blockquote><a href="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;LinkedList&lt;Integer&gt;&gt; go = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span>[] size;</span><br><span class="line">        UF(<span class="type">int</span> n) {</span><br><span class="line">            <span class="built_in">this</span>.count = n;</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ]; <span class="comment">// 相当于把 rooQ 的parent指定为rootP, 所以rootP的size需要加上rootQ的size</span></span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[cur] != cur) {</span><br><span class="line">                parent[cur] = find(parent[cur]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[cur];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countPairs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            go.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], to = edges[i][<span class="number">1</span>];</span><br><span class="line">            uf.union(from, to);</span><br><span class="line">        }</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> uf.find(i);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(p)) list.add(uf.size[p]);</span><br><span class="line">            set.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ele : list) {</span><br><span class="line">            res += (<span class="type">long</span>) ele * (n - ele);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>1900 - 2100</h1><h2 id="2919-使数组变美的最小增量运算数-2031"><a href="https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/">2919. 使数组变美的最小增量运算数</a> - 2031</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">long</span>[][] memo;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minIncrementOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// int n = nums.length;</span></span><br><span class="line">        <span class="comment">// this.k = k;</span></span><br><span class="line">        <span class="comment">// memo = new long[n][3];</span></span><br><span class="line">        <span class="comment">// this.nums = nums;</span></span><br><span class="line">        <span class="comment">// for (long[] m : memo) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(m, -1);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp(n - 1, 0);</span></span><br><span class="line">        <span class="comment">// 1:1 翻译成 递推</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">select</span> <span class="operator">=</span> dp[i][<span class="number">0</span>] + Math.max(k - nums[i], <span class="number">0</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">notSelect</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">2</span>) {</span><br><span class="line">                    notSelect = dp[i][j + <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = Math.min(select, notSelect);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> left)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][left] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][left];</span><br><span class="line">        <span class="comment">// 选</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> dp(idx - <span class="number">1</span>, <span class="number">0</span>) + Math.max(k - nums[idx], <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 不选</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">2</span>) {</span><br><span class="line">            res = Math.min(res, dp(idx - <span class="number">1</span>, left + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        memo[idx][left] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周赛 </tag>
            
            <tag> 难度练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>对于两个字符串求子序列的问题，都是用两个指针 <code>i</code> 和 <code>j</code> 分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--93b6b/">labuladong-最长公共子序列</a></p></blockquote><h1>相关题目</h1><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><p><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a></p><h1>思路</h1><p>定义<code>dp(s1, i, s2, j)</code>为<code>s1[i...]</code> 和 <code>s2[j...]</code>的最长公共子序列长度</p><p>goal: <code>dp(s1, 0, s2, 0)</code> 从零开始的最长公共子序列长度</p><p>base case: <code>i == len(s1)</code> 或 <code>j == len(s2)</code> 由于相当于没有string，所以最长公共子序列长度为0</p><p>状态转移：</p><p>在选的情况下，即charAt[i] == charAt[j]时，状态转移：</p><p><img src="/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E9%80%89.jpeg" alt="状态转移_选"></p><p>在不选的情况下可以从三种情况转移：</p><p><img src="/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E4%B8%8D%E9%80%89.jpeg" alt="状态转移"></p><p><strong>但是其实只有情况一和情况二，因为情况三被情况一cover了</strong></p><h1><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>模板题</p><p>代码：</p><p>自顶向下的递归解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String text1, text2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> {</span><br><span class="line">        m = text1.length();</span><br><span class="line">        n = text2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.text1 = text1;</span><br><span class="line">        <span class="built_in">this</span>.text2 = text2;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上的迭代解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span></span><br><span class="line">        <span class="comment">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span></span><br><span class="line">        <span class="comment">// base case: dp[0][..] = dp[..][0] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 现在 i 和 j 从 1 开始，所以要减一</span></span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><p>变换一下思路，我们要的就是让他们成为他们的公共子序列，问的是需要到达公共子序列所需要的步数:</p><p>即 <code>word1.length - LCS.length + word2.length - LCS.length</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String word1, word2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        m = word1.length();</span><br><span class="line">        n = word2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.word1 = word1;</span><br><span class="line">        <span class="built_in">this</span>.word2 = word2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lcsLength</span> <span class="operator">=</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (m - lcsLength) + (n - lcsLength);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> LCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/posts/%E6%8E%92%E5%BA%8F/"/>
      <url>/posts/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/two-city-scheduling/">1029. 两地调度</a></h1><p>解题思路：贪心 + 排序</p><p>怎么贪：</p><p>培养一个思维：我们不是单独拿一个城市，而是假设所有面试者都去B，那么挑出来去A的应该是代价最小的即按照 <code>cost[i][0] - cost[i][1]</code> 排升序</p><p>也就是 <code>cost[a][0] - cost[a][1] - (cost[b][0] - cost[b][1]) </code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> {</span><br><span class="line">        Arrays.sort(costs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o1[<span class="number">1</span>] - (o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> costs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">splitN</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">aSum</span> <span class="operator">=</span> <span class="number">0</span>, bSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; splitN; i++) {</span><br><span class="line">            aSum += costs[i][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; i++) {</span><br><span class="line">            bSum += costs[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> aSum + bSum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Array </tag>
            
            <tag> Sort </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic-Calculator-Topics</title>
      <link href="/posts/Basic-Calculator-Topics/"/>
      <url>/posts/Basic-Calculator-Topics/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-shi--24fe4/">Labuladong-实现基础计算器</a></p></blockquote><table><thead><tr><th><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></td></tr><tr><td><a href="https://leetcode.cn/problems/basic-calculator-iii/">772. 基本计算器 III</a></td></tr></tbody></table><p>主要借助栈（加减乘除） + 递归（括号）</p><p>加一个<code>preSign '+'</code></p><p>即：</p><p><code>+</code> <code>-</code> 数 直接入栈</p><p><code>* /</code> 借用栈的性质，将计算结果入栈</p><p><code>(</code> <code>)</code> 使用递归先计算括号内的数，将结果入栈</p><p><img src="/posts/Basic-Calculator-Topics/Basic-Calculator-push-stack-1.jpeg" alt="Basic-Calculator-push-stack-1"></p><h1><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (cArr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">'+'</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cArr.length;) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cArr[i])) {</span><br><span class="line">                num = num * <span class="number">10</span> + (cArr[i] - <span class="string">'0'</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ((!Character.isDigit(cArr[i]) &amp;&amp; cArr[i] != <span class="string">' '</span>) || i == cArr.length - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) {</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) {</span><br><span class="line">                    stack.push(-<span class="number">1</span> * num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek * num);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek / num);</span><br><span class="line">                }</span><br><span class="line">                sign = cArr[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            sum += stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算器 </tag>
            
            <tag> Basic-Calculator </tag>
            
            <tag> Stack </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/posts/%E6%95%B0%E7%BB%84/"/>
      <url>/posts/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>数组 - Array</h1><blockquote><ul><li><a href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></li><li><a href="/posts/%E6%8E%92%E5%BA%8F/" title="排序">排序</a></li><li><a href="/posts/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/" title="摩尔投票">摩尔投票</a></li><li><a href="/posts/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/" title="前后缀分解">前后缀分解</a></li></ul></blockquote><h1><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></h1><p>非常有意思的情况划分题：</p><blockquote><p>参考：<br><a href="https://leetcode.cn/problems/insert-interval/solutions/472435/shou-hua-tu-jie-57-cha-ru-qu-jian-fen-cheng-3ge-ji/">笨猪爆破组</a></p></blockquote><p>核心在于：</p><ol><li>推入前段不重叠部分</li><li>更新重叠部分再推入</li><li>推入后段不重叠部分</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) {</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; retList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLeft</span> <span class="operator">=</span> newInterval[<span class="number">0</span>], newRight = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 加入左边不重叠的</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (right &lt; newLeft) {</span><br><span class="line">                retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{left, right});</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新重叠范围</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &gt; newRight) <span class="keyword">break</span>;</span><br><span class="line">            newLeft = Math.min(left, newLeft);</span><br><span class="line">            newRight = Math.max(right, newRight);</span><br><span class="line">        }</span><br><span class="line">        retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{newLeft, newRight});</span><br><span class="line">        <span class="comment">// 加入右边不重叠部分</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left, right});</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[retList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.length; i++) {</span><br><span class="line">            ret[i] = retList.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/rank-teams-by-votes/">1366. 通过投票对团队排名</a></h1><p>直接排序即可，主要检查对于Comparator的应用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rankTeams</span><span class="params">(String[] votes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> votes.length, m = votes[<span class="number">0</span>].length();</span><br><span class="line">        Map&lt;Character, <span class="type">int</span>[]&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String vote : votes) {</span><br><span class="line">            <span class="type">char</span>[] cArr = vote.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">                <span class="type">int</span>[] cur = hm.getOrDefault(cArr[i], <span class="keyword">new</span> <span class="title class_">int</span>[cArr.length]);</span><br><span class="line">                cur[i]++;</span><br><span class="line">                hm.put(cArr[i], cur);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        List&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hm.entrySet());</span><br><span class="line">        Collections.sort(ls, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e1, Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e2)</span> {</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e1Key</span> <span class="operator">=</span> e1.getKey();</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e2Key</span> <span class="operator">=</span> e2.getKey();</span><br><span class="line">                <span class="type">int</span>[] e1Value = e1.getValue();</span><br><span class="line">                <span class="type">int</span>[] e2Value = e2.getValue();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> e1Value.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> e1Value[i], second = e2Value[i];</span><br><span class="line">                    <span class="keyword">if</span> (first == second) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> second - first;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> e1Key - e2Key;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, <span class="type">int</span>[]&gt; ele : ls) {</span><br><span class="line">            sb.append(ele.getKey());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBricks</title>
      <link href="/posts/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/posts/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>本篇文章援引：</p><blockquote><p>一亩三分地 - <a href="https://www.1point3acres.com/bbs/space-uid-764814.html">newgpu</a></p><p><a href="https://www.1point3acres.com/bbs/thread-851795-1-1.html"> 谈谈Databricks和云计算</a></p><p><a href="https://www.1point3acres.com/bbs/thread-855806-1-1.html"> 谈谈Databricks和云计算（二）</a></p><p><a href="https://cloud.tencent.com/developer/article/2191426">腾讯数据湖与湖仓一体架构实践</a></p></blockquote></div><h1>Data Warehouse</h1><p>Running on cluster.</p><p>A place to store structured data.</p><p>Source: offline ETL pipline to insert by batch</p><p>goal is to make data scientist to run SQL query</p><p>特点：</p><ol><li>It is a distributed database hence it has a lot features that database own</li><li>Structured data</li></ol><h2 id="snowflake">snowflake</h2><p>managed cloud data warehouse</p><p>data warehouse on cloud</p><h1>databricks and data lakehouse</h1><p>datalake -&gt; data lakehouse</p><p>No need for schema: friendly to semi-structured and non structured data</p><h1>产品</h1><h2 id="delta-lake">delta lake</h2><p>stores data itself and its metadata.</p><p>metadata is for ACID transactions and support for a schema with a supporting write-ahead log for data rolling back when necessary</p><p>Data can be stored on the top of S3, like object storage. Delta Lake imports metadata for ACID transactions and schema. These ACID transactions and schema are necessary for SQL workload</p><h2 id="Databricks-SQL">Databricks SQL</h2><p>Photon execution engine.</p><h2 id="Databricks-Runtime">Databricks Runtime</h2><p>Create machine -&gt; a tuned spark cluster, and spark is ready to go</p><h2 id="Notebook">Notebook</h2><p>Connect to a cluster that the user have access to. Use scala, python, sql or R to run the spark command and do the manipulation with the data on top of S3</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树 - Minimum Spanning Tree - MST</title>
      <link href="/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>最小生成树算法主要有：</p><ul><li>Kruskal 算法</li><li>Prim 算法</li></ul><h1>什么是最小生成树 MST</h1><p><strong>先说「树」和「图」的根本区别：树不会包含环，图可以包含环</strong>。</p><p>什么是图的「生成树」呢，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。</p><p><img src="/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/MST_0.png" alt="MST_0"></p><p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。</p><p><strong>最小生成树: 所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」</strong>。</p><h1>Kruskal</h1><p>MST 要保证边：</p><p>1、包含图中的所有节点。</p><p>2、形成的结构是树结构（即不存在环）。</p><p>3、权重和最小。</p><p>其中 1， 2可以用并查集来做：</p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><blockquote><p>详见：<a href="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a> 习题261</p></blockquote><p>对于3:</p><p>用到了贪心思路：</p><p>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 <code>mst</code> 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 <code>mst</code> 集合；否则，这条边不是最小生成树的一部分，不要把它加入 <code>mst</code> 集合。</p><h3 id="例题">例题</h3><p>To be write…</p><p>1135</p><p>1584</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> UnionFind </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> minimum spanning tree </tag>
            
            <tag> Kruscal </tag>
            
            <tag> Prim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>并查集 - 解决的问题</h1><ol><li><p>快速的支持以下的操作：（近乎 O(1)）</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol></li><li><p>基本原理: 每一个集合都用一颗树来表示。树根的标号就是整个集合的编号。每个节点存储他的父节点， p[x] 表示x的父节点</p><ol><li><p>用树（不一定是二叉树）的形式来维护集合：</p></li><li><p>集合的根结点为集合编号</p></li><li><p><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E9%9B%86%E5%90%88.png" alt="uf_集合"></p></li></ol></li><li><p>问题1：</p><ol><li>如何判断树根：<ul><li><code>if (p[x] == x)</code> 根节点的parent是他自己</li></ul></li></ol></li><li><p>问题2:</p><ol><li>如何求x的集合编号：<ul><li><code>while (p[x] ≠ x) x = p[x]</code></li></ul></li></ol></li><li><p>问题3:</p><ol><li>如何合并两个集合：<ul><li>把其中一个集合当成另一个集合的儿子；</li><li>p[x] = y (px 是 x的集合编号， py是y的集合编号）</li><li><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88.png" alt="uf_合并集合"></li></ul></li></ol></li></ol><p>思考：插入需要树的高度的复杂度 → 并查集的优化：路经压缩</p><p>当第一次x节点后，当前路径上经过的所有点都直接指向根节点，因此近乎 O(1)</p><p><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9.png" alt="uf_路经压缩"></p><p>并且同时维护节点数量：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    {</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"C"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (a != b)</span><br><span class="line">            {</span><br><span class="line">                p[a] = b;</span><br><span class="line">                cnt[b] += cnt[a];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q1"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            cout &lt;&lt; cnt[<span class="built_in">find</span>(a)] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>java 代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">            parent[x] = find(parent[x]); <span class="comment">// 这里是用了路经压缩</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里的可以增加一个size数组，用来表示每一个联通块的大小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    UF(<span class="type">int</span> n) {</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ]; <span class="comment">// 相当于把 rooQ 的parent指定为rootP, 所以rootP的size需要加上rootQ的size</span></span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parent[cur] != cur) {</span><br><span class="line">            parent[cur] = find(parent[cur]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> parent[cur];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>函数方法</h1><p>union很好理解，找到两个根，将其中一个根的parent设置成另一个根的儿子</p><p>主要是find，这里使用了路经压缩：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">        parent[x] = find(parent[x]); <span class="comment">// 这里用了路经压缩, find返回了最上面的根，然后当前栈层就会接上这个根</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 2 -&gt; 3 3 -&gt; 3</span><br><span class="line">4 -&gt; 4</span><br><span class="line">5 -&gt; 6 6 -&gt; 6</span><br><span class="line"></span><br><span class="line">所以是 1-&gt;2-&gt;3; 4-&gt;4; 6-&gt;6; 三个集合</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>那么用 <code>1-&gt;2-&gt;3</code>举例子：1的父节点是2，2的父节点是3，而3是其自己的父节点。</p><p>如果我们调用<code>find(1)</code>：</p><ol><li><code>parent[1]</code> 是 2，不等于1，所以我们要递归地找<code>find(2)</code>。</li><li><code>parent[2]</code> 是 3，不等于2，所以我们要递归地找<code>find(3)</code>。</li><li><code>parent[3]</code> 是 3，等于3，所以返回3。</li></ol><p>在这个过程中，我们还会更新<code>parent[1]</code>和<code>parent[2]</code>都为3，因为3是1和2的代表。这就是路径压缩的优化，确保每个节点都直接指向其代表，从而使得后续的查找操作更快。</p><p>等于说：</p><p><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9_2.jpeg" alt="uf_路经压缩_2"></p><h1>例题</h1><h2 id="200-岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/description/#">200. 岛屿数量</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n * m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                        parent[i * m + j] = i * m + j;</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + dx[dir], newY = j + dy[dir];</span><br><span class="line">                        <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp; grid[newX][newY] == <span class="string">'1'</span>) {</span><br><span class="line">                            uf.union(</span><br><span class="line">                                i * m + j, newX * m + newY</span><br><span class="line">                            );</span><br><span class="line">                        };</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="721-账户合并"><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        UnionFind(List&lt;List&lt;String&gt;&gt; accounts) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> accounts.size();</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="keyword">if</span> (rootQ == rootP) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(accounts);</span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="keyword">if</span> (!emailToId.containsKey(curEmail)) {</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    uf.union(i, emailToId.get(curEmail));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> uf.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id, emails);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet()){</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));</span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="323-无向图中连通分量的数目"><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/description/">323.无向图中连通分量的数目</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            count = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count--;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="261-以图判树"><a href="https://leetcode.cn/problems/graph-valid-tree/description/">261.以图判树</a></h2><h3 id="并查集">并查集:</h3><blockquote><p>树满足两个性质：</p><ol><li>n 个节点 n - 1条边</li><li>无环</li></ol></blockquote><p>如果一个联通块下相连了两个节点，那么成环：</p><p><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_1.png" alt="lc_261_1"></p><p>这种无环：</p><p><img src="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_2.png" alt="lc_261_2"></p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="comment">// 如果一个联通块下相连了两个节点，那么成环</span></span><br><span class="line">        <span class="comment">// 树满足两个性质：1. n 个节点 n - 1条边 2. 无环</span></span><br><span class="line">        <span class="comment">// 1. n 个节点 n - 1条边</span></span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有无环就是判断两个联通块是否又被尝试链接，如果是，那么就有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!uf.isConnected(p, q)) {</span><br><span class="line">                uf.union(p, q);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS-Visited">DFS + Visited</h3><p>比较困难的地方在于如何能够判断环即如何使用visited数组，由于这是个无向图，那么比如 <code>0 &lt;-&gt; 1</code> 节点0在遍历邻居1后，邻居1还会遍历它的邻居0，所以会被visited阻止，解决办法是传入一个parent变量，从而可以追踪目前的父节点。当当前节点的邻居和父节点为同一节点时跳过。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        buildGraph(n);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], b = edges[i][<span class="number">1</span>];</span><br><span class="line">            add(a, b);</span><br><span class="line">            add(b, a);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>, -<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">boolean</span> v : visited) { <span class="comment">// Checks if all nodes are visited</span></span><br><span class="line">            <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">        graph.get(from).add(to);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        List&lt;Integer&gt; neighbours = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neig : neighbours) {</span><br><span class="line">            <span class="keyword">if</span> (neig == parent) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(neig, cur)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> UnionFind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/posts/Dijkstra/"/>
      <url>/posts/Dijkstra/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式前向星-LinkedForwardStar</title>
      <link href="/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
      <url>/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
      
        <content type="html"><![CDATA[<h1>链式前向星 - (Linked) Forward Star</h1><p>它是一种存图的方式，是优化过的<strong>邻接表</strong>的表达方式</p><h2 id="定义">定义</h2><p><strong>为了方便，我们约定 k 为点数，m 为边数。</strong></p><p>邻接矩阵：适用于边数较多的**「稠密图」<strong>使用，当边数量接近点的数量的平方，即 <strong>「m ≈ n^2」</strong> 时，可定义为</strong>「稠密图」**。</p><p>邻接表：适用于边数较少的**「稀疏图」<strong>使用，当边数量接近点的数量，即 <strong>「m ≈ n」</strong> 时，可定义为</strong>「稀疏图」**。</p><h2 id="代码">代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> {</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>idx</code> 是用来对边进行编号的，然后对存图用到的几个数组作简单解释：</p><ul><li><code>he</code> 数组：存储是某个节点所对应的边的集合（链表）的头结点；</li><li><code>e</code> 数组：由于访问某一条边指向的节点；</li><li><code>ne</code> 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边；</li><li><code>w</code> 数组：用于记录某条边的权重为多少。</li></ul><p>因此当我们想要遍历所有由 <code>a</code> 点发出的边时，可以使用如下方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i]) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i], c = w[i]; <span class="comment">// 存在由 a 指向 b 的边，权重为 c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自己整理的java版本：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedForwardStar</span> {</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>[] edge = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    LinkedForwardStar() {</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span> {</span><br><span class="line">        edge[tot] = b; <span class="comment">// 设置边的终点</span></span><br><span class="line">        next[tot] = head[a]; <span class="comment">// 设置该边的下一条边</span></span><br><span class="line">        weight[tot] = w; <span class="comment">// 设置该边的权重</span></span><br><span class="line">        head[a] = tot; <span class="comment">// 更新节点 u 的出边起始位置</span></span><br><span class="line">        tot++; <span class="comment">// 增加边数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseFrom</span><span class="params">(<span class="type">int</span> a)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Traversing from node "</span> + a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[a]; i != -<span class="number">1</span>; i = next[i]) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weight[i];</span><br><span class="line">            System.out.println(a + <span class="string">" -&gt; "</span> + v + <span class="string">" weight: "</span> + w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LinkedForwardStar</span> <span class="variable">lfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedForwardStar</span>();</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 遍历从各个节点出去的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            lfs.traverseFrom(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Appendix">Appendix</h2><p><a href="https://mp.weixin.qq.com/s/2Ba8-NI7lQh2_MvMpg-CZg">图论 - 存图方式 - 三叶</a></p><p>非链式前向星的建图方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) {</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从二叉树到回溯到DP</title>
      <link href="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/"/>
      <url>/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/</url>
      
        <content type="html"><![CDATA[<h1>二叉树</h1><p>暂略，已经练习很多了</p><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a> 中包含所有二叉树</p><h1>回溯</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：<br><a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵茶山艾府 - 回溯 - [14 - 16]</a></p><p>自己之前也收集过：见 <a href="/posts/%E5%9B%9E%E6%BA%AF/" title="回溯">回溯</a></p></div><blockquote><p>回溯有一个增量构造答案的过程，这个过程通常使用递归来实现。选 “a”, “b”, “c” 选 “ad” …</p></blockquote><blockquote><p>递归： 考虑好边界条件以及和非边界条件写对即可。剩下交给数学归纳法</p></blockquote><p>回溯/动归三问：-&gt; 主要是为了写对 <strong>边界条件以及和非边界条件</strong></p><ul><li><p>当前操作是什么？</p></li><li><p>子问题是什么？</p></li><li><p>下一个子问题是什么？</p></li></ul><h2 id="子集型">子集型</h2><h3 id="思路">思路</h3><p>可以有两种思路：</p><p>站在输入的角度：</p><p>枚举第 i 个元素 你是<strong>选/不选</strong></p><blockquote><p>ps: 01背包与此相似</p></blockquote><p>每个数都可以在子集中，也可以不在子集中</p><p>此时：<strong>叶子结点是答案</strong></p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E8%BE%93%E5%85%A5%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_输入角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作<ol><li>枚举第 i 个数<strong>选/不选</strong></li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= i + 1的数字中构造子集</li></ol></li></ol><p>站在<strong>答案</strong>角度：</p><p>枚举第一个数选择谁，第二个数选择谁，</p><p>此时：<strong>每个节点都是答案</strong></p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E7%AD%94%E6%A1%88%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_答案角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作<ol><li>枚举答案的第一个数选什么第二个数选什么…</li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= j + 1的数字中构造子集</li></ol></li></ol><h2 id="组合型">组合型</h2><h3 id="思路-2">思路</h3><p>子集 + 剪枝 = 组合型问题</p><p>下图（左选两个数，右选三个数）</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E7%BB%84%E5%90%88%E5%9E%8B%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D1.png" alt="组合型回溯-剪枝1"></p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/77_%E6%80%9D%E8%B7%AF.png" alt="77_思路"></p><blockquote><p>为什么从大到小枚举呢？</p></blockquote><p>假设我们需要选 3 个数，现在已经选了1个了，即 k = 3, m = 1; 我们还需要选择 d = k - m -&gt; 3 - 1 = 2 个数</p><p>由于是从大到小枚举，那么我们如果 i &lt; d; 即要选的数为[1,1] 也就是1的话那么是无论如何都没办法选出来两个数 k = 2 的（这是因为题目的范围是[1,n]）所以从大到小会比较容易剪枝</p><blockquote><p>正序枚举怎么做呢？</p></blockquote><p><code>k - path.size()</code> 是 我们还需要几个</p><p>我们要判断的就是还需要的能否被正确的提供，当前我们剩余的个数是 <code>n - i + 1</code></p><p>因此如果需要的不能被满足，直接提前截止即可 <code> if (k - path.size() &gt; n - cur + 1) return;</code></p><h2 id="总结">总结</h2><p>对于组合型和子集型回溯有两种思考路径：</p><ul><li>选或不选 - 输入视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></li></ul></li><li>枚举选哪个 - 输出视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">分割回文串</a></li></ul></li></ul><h2 id="排列型">排列型</h2><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%8E%92%E5%88%97%E5%9E%8B%E5%9B%9E%E6%BA%AF.png" alt="排列型回溯"></p><p>和组合的区别就在于<code>[2, 1]</code> 和 <code>[1, 2]</code>在组合中被认定为一种，但是排列中则是两种不同的</p><h1>DP</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：</p><p>灵茶山艾府：</p><p><a href="https://www.bilibili.com/video/BV1Xj411K7oF/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">从记忆化搜索到<strong>递推</strong></a></p><p><a href="https://www.bilibili.com/video/BV1AM4y1x7r4/?spm_id_from=333.999.0.0">选或不选 vs 枚举选哪个</a></p></div><p>主要还是<br>状态定义 + 状态转移</p><p>可以借用子集型回溯中的</p><p>选或不选 / 选哪个</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E5%90%AF%E5%8F%91.png" alt="dp_启发"></p><h2 id="从上至下-记忆化搜索">从上至下 - 记忆化搜索</h2><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.png" alt="dp_记忆化搜索"></p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2_2.png" alt="dp_记忆化搜索_2"></p><h2 id="从下而上-递推">从下而上 - 递推</h2><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E9%80%92%E5%BD%92%E5%88%B0%E9%80%92%E6%8E%A8.png" alt="dp_递归到递推"></p><h1>回溯例题</h1><h2 id="子集型-2">子集型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17. 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</span><br><span class="line">78. 子集 https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/</span><br><span class="line">131. 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</span><br><span class="line">784. 字母大小写全排列 https://leetcode.cn/problems/letter-case-permutation/</span><br><span class="line">1601. 最多可达成的换楼请求数目 https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/</span><br><span class="line">2397. 被列覆盖的最多行数 https://leetcode.cn/problems/maximum-rows-covered-by-columns/</span><br><span class="line">306. 累加数 https://leetcode.cn/problems/additive-number/ </span><br><span class="line">2698. 求一个整数的惩罚数 https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/</span><br></pre></td></tr></tbody></table></figure><h2 id="组合型-2">组合型</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">77. 组合 https://leetcode.cn/problems/combinations/solutions/2071017/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-65lh/</span><br><span class="line">216. 组合总和 III https://leetcode.cn/problems/combination-sum-iii/solutions/2071013/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-feme/</span><br><span class="line">22. 括号生成 https://leetcode.cn/problems/generate-parentheses/solutions/2071015/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-wcdw/</span><br><span class="line">301. 删除无效的括号 https://leetcode.cn/problems/remove-invalid-parentheses/</span><br></pre></td></tr></tbody></table></figure><h2 id="排列型-2">排列型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">46. 全排列 https://leetcode.cn/problems/permutations/solutions/2079585/hui-su-bu-hui-xie-tao-lu-zai-ci-jing-que-6hrh/</span><br><span class="line">51. N 皇后 https://leetcode.cn/problems/n-queens/solutions/2079586/hui-su-tao-lu-miao-sha-nhuang-hou-shi-pi-mljv/</span><br><span class="line">52. N 皇后 II（直接用 51 题代码搞定）https://leetcode.cn/problems/n-queens-ii/solution/hui-su-miao-sha-nhuang-hou-yi-ge-shi-pin-l41</span><br></pre></td></tr></tbody></table></figure><h1>子集型：</h1><h1><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String[] hm = <span class="keyword">new</span> <span class="title class_">String</span>[] {</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">"abc"</span>,</span><br><span class="line">        <span class="string">"def"</span>,</span><br><span class="line">        <span class="string">"ghi"</span>,</span><br><span class="line">        <span class="string">"jkl"</span>,</span><br><span class="line">        <span class="string">"mno"</span>,</span><br><span class="line">        <span class="string">"pqrs"</span>,</span><br><span class="line">        <span class="string">"tuv"</span>,</span><br><span class="line">        <span class="string">"wxyz"</span></span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>[] digitCharArr;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">        digitCharArr = digits.toCharArray();</span><br><span class="line">        n = digitCharArr.length;</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">innerRes</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (innerRes.length() != <span class="number">0</span>) res.add(innerRes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> digitCharArr[curIdx] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hm[idx].length(); i++) {</span><br><span class="line">            sb.append(hm[idx].charAt(i));</span><br><span class="line">            backtrack(curIdx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E6%80%9D%E8%B7%AF.jpeg" alt="78_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>);</span><br><span class="line">        backtrackChooseFromEnumeration(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 选或不选</span></span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        path.addLast(nums[curIdx]);</span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// not select</span></span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackChooseFromEnumeration</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 枚举选哪个</span></span><br><span class="line">        paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">innerIdx</span> <span class="operator">=</span> curIdx; innerIdx &lt; n; innerIdx++) {</span><br><span class="line">            path.addLast(nums[innerIdx]);</span><br><span class="line">            backtrackChooseFromEnumeration(innerIdx + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选或不选：</p><p>每一次抉择（backtrackSelectOrNot function中）都只有两种选择，选或者不选，并且这种情况下只有叶子结点为答案，因此需要判断是否为叶子结点，如果是的话才加入答案中</p><p>枚举选哪个：</p><p>每一次枚举（backtrackChooseFromEnumeration中）都可以选择curIdx之后的数，且所有的节点都为答案，因此无需判断直接加入，只需要做好递归的边界即可</p><h1><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/131_%E6%80%9D%E8%B7%AF.jpeg" alt="131_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] sCharArr;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        sCharArr = s.toCharArray();</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="comment">// backtrackEnumerate(0);</span></span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选择这个逗号 （最后一个char (i - 1) 一定要选）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            backtrackSelectOrNot(start, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择这个逗号</span></span><br><span class="line">        <span class="comment">// 检查是否回文</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtrackSelectOrNot(i + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumerate</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="comment">// 枚举子串的终点</span></span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">                path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                backtrackEnumerate(i + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (sCharArr[left] == sCharArr[right]) {</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><p>两个难点：</p><ol><li>决策树如何画</li><li>如何将char 小写变大写，大写变小写</li></ol><p>问题1:</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/784_%E6%80%9D%E8%B7%AF.png" alt="784_思路"></p><p>问题2:</p><a href="/posts/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/" title="Java碎碎念">Java碎碎念</a><p><code>char[idx] ^= 1 &lt;&lt; 5</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 回溯</span></span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题其实可以不用恢复现场，因为我们需要的是叶子结点；但是我们需要先处理 <code>不转换当前char</code>再处理<code>转换当前char</code>由于回溯发生在不转换，即没有变化，那也就不需要回溯现场了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数</a></h1><p>这道题关键在于枚举列然后计算覆盖的行然后统计最大即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] matrix, matrixCopy;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRows</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        matrixCopy = <span class="keyword">new</span> <span class="title class_">int</span>[m][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            matrixCopy[i] = matrix[i].clone();</span><br><span class="line">        }</span><br><span class="line">        backtrack(<span class="number">0</span>, numSelect);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - startIdx &lt; numSelect) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (numSelect == <span class="number">0</span>) {</span><br><span class="line">            max = Math.max(max, countCovers());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            backtrack(i + <span class="number">1</span>, numSelect - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = matrixCopy[r][i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countCovers</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (count == n) ret++; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/additive-number/">306. 累加数</a></h1><p>这道题自己的做法是枚举切割的起始点，能做但是比较复杂；</p><p>如果回溯返回boolean想要记录结果的话：</p><p><code>if (backtrack()) return true</code></p><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">numSelected</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    LinkedList&lt;BigInteger&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> backtrack(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cutIdx)</span> {</span><br><span class="line">        <span class="comment">// System.out.println(path + " " + cutIdx);</span></span><br><span class="line">        <span class="keyword">if</span> (cutIdx == n) {</span><br><span class="line">            <span class="keyword">return</span> path.size() &gt;= <span class="number">3</span> &amp;&amp; check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num.charAt(cutIdx) == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (check(path.get(path.size() - <span class="number">2</span>), </span><br><span class="line">                path.get(path.size() - <span class="number">1</span>), BigInteger.ZERO)) {</span><br><span class="line">                    path.addLast(BigInteger.ZERO);</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    path.removeLast();   </span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                path.addLast(BigInteger.ZERO);</span><br><span class="line">                <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();  </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cutIdx; i &lt; n; i++) {</span><br><span class="line">                <span class="type">BigInteger</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(num.substring(cutIdx, i + <span class="number">1</span>));</span><br><span class="line">                path.addLast(current);</span><br><span class="line">                <span class="keyword">if</span> (path.size() &gt;= <span class="number">3</span> &amp;&amp; !check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), current)) {</span><br><span class="line">                    path.removeLast();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (backtrack(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(BigInteger a, BigInteger b, BigInteger c)</span> {</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        <span class="keyword">return</span> sum.equals(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://leetcode.cn/problems/additive-number/solutions/1201929/gong-shui-san-xie-hui-su-gao-jing-du-jia-6o6b/">三叶的解法</a>是枚举结束点</p><p>并且这里教了如何使用高精度加法：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String _num)</span> {</span><br><span class="line">        num = _num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">return</span> m &gt;= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num.charAt(u) == <span class="string">'0'</span> ? u + <span class="number">1</span> : n;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> u; i &lt; max; i++) {</span><br><span class="line">            cur.add(<span class="number">0</span>, num.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">2</span> || check(list.get(m - <span class="number">2</span>), list.get(m - <span class="number">1</span>), cur)) {</span><br><span class="line">                list.add(cur);</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(List&lt;Integer&gt; a, List&lt;Integer&gt; b, List&lt;Integer&gt; c)</span> {</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size() || i &lt; b.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.size()) t += a.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; b.size()) t += b.get(i);</span><br><span class="line">            ans.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) ans.add(t);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> c.size() == ans.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.size() &amp;&amp; ok; i++) {</span><br><span class="line">            <span class="keyword">if</span> (c.get(i) != ans.get(i)) ok = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">作者：宫水三叶</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/additive-number/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">2698. 求一个整数的惩罚数</a></h1><p>这道题非常有意思，可以用两个指针来做到选或不选的思路：</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.jpeg" alt="2698_选或不选"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 选或不选</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, <span class="number">0</span>, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (end == square.length) {</span><br><span class="line">            <span class="keyword">return</span> i == sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; square.length - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, start, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sum += sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(square, end + <span class="number">1</span>, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        sum -= sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sumUp</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++){</span><br><span class="line">            x = x * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从答案的视角枚举</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E6%9E%9A%E4%B8%BE.jpeg" alt="2698_枚举"></p><p>其实就是枚举逗号位置</p><p>在start = 0 时候 i尝试 0, 1, 2, 3 也就是[0,0],[0, 1], [0,2],[0,3] 即temp = 1, 12, 129, 1296 sum = <code>此时的 temp</code></p><p>在start = 1 时候 i尝试 1, 2, 3 也就是[1, 1], [1,2],[1,3] 即temp = 2, 29, 296; sum = <code>start = 0 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 2 时候 i尝试 2, 3 也就是[2,2],[2,3] 即temp = 9, 96; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 3 时候 i尝试 3 也就是[3,3] 即temp = 6; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code>  + <code>start = 2 时候的temp</code>+ <code>此时的 temp</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == square.length) <span class="keyword">return</span> target == sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 开始枚举</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; square.length; i++) {</span><br><span class="line">            temp = temp * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">            sum = sum + temp;</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, i + <span class="number">1</span>, target)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            sum = sum - temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>子集型总结</h1><p>一般可以从选和不选以及枚举选哪个来做；</p><p>碰到需要选择切点的，类似于306, 以及2698题，我们可以先通过把一个数变成一个string或者char[]来进行枚举。</p><p>另外枚举状态下的回溯就是无非是当前层然后深入下一层然后碰到递归终点返回之后会继续尝试</p><p>其达成的效果就是当前层穷举，下一层穷举…</p><p>所以这就是所谓的递归不要管他是如何深入的。只要知道做了什么事，怎么出去，完成当前scope下的任务即可</p><h1>组合型</h1><h1><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><p>无优化剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从大到小枚举剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(n);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - path.size()) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i - <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从小到大枚举</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k - path.size() &gt; n - cur + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrackEnumeration(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">9</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() != k) <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选</span></span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选</span></span><br><span class="line">        path.addLast(cur);</span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h1><p>依旧是使用了选和不选的操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Character&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        m = <span class="number">2</span> * n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> parenthesisSum, <span class="type">int</span> leftParenthesisCount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum == m) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : path) {</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            paths.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 选左括号</span></span><br><span class="line">        <span class="keyword">if</span> (leftParenthesisCount &lt; n) {</span><br><span class="line">            path.addLast(<span class="string">'('</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选左括号（选右括号）</span></span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum - leftParenthesisCount &lt; leftParenthesisCount) {</span><br><span class="line">            path.addLast(<span class="string">')'</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是这个树的构成是要计算左右可选的括号数量而不是盲目的选或者不选。</p><p>比如：我们一开始会选择左括号，当不选择左括号的时候（左括号数量满足数量），我们会去选择有括号，这时候是不选左括号的下分情况的选择右括号的情况：（右括号的数量 &lt; 左括号的数量）</p><h1><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h1><p>暴力的穷举每一个括号看是选择还是不选择</p><p>答案加入到数组里后从中选择最长的就是满足要求的，将最长的加入答案</p><p>另外判断一个字符串的括号是否合法的函数也很有意思，可以多学习一下, 思路是用代表左括号的指针移动，碰到左括号右移，右括号左移，如果left == 0证明合法，否则比如左括号的idx &lt; 0则代表右括号&gt;左括号数量，不合法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        n = s.length();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> filterResult();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">filterResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 筛选出最长的有效括号字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            maxLen = Math.max(maxLen, str.length());</span><br><span class="line">        }</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            <span class="keyword">if</span> (str.length() == maxLen) {</span><br><span class="line">                set.add(str);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb.toString())) {</span><br><span class="line">                paths.add(sb.toString());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>) {</span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 选择当前的括号</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不选择当前的括号</span></span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String sb)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sb.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 右括号比左括号多，肯定无效</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果左括号的数量等于右括号的数量，才是一个有效的括号字符串</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>排列型</h1><h1><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">boolean</span>[] numAppeared;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        numAppeared = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        System.out.println(idx + <span class="string">" "</span> + path);</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!numAppeared[i]) {</span><br><span class="line">                numAppeared[i] = <span class="literal">true</span>;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                backtrack(idx + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                numAppeared[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意的有两个点：</p><ol><li>backtrack中的for loop 是 <code>i: [0, n)</code> 因为我们每一次都要看从 0 开始的然后通过boolean[] 来判断是否加入答案</li><li>注意递归时候是 <code>(idx + 1)</code> 而不是 <code>(i + 1)</code><ol><li><code>idx</code>应该表示的是当前的排列中已经放置了多少数字，或者说正在为哪个位置选择数字。然后选择的是 <code>[0, n]</code></li></ol></li></ol><h1>N皇后问题</h1><p>这道题有两种思维方式，首先是 <a href="https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-c26da/">labuladong</a>的比较好理解的，其次是<a href="https://www.bilibili.com/video/BV1mY411D7f6/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵神</a>的通过抽屉原理证明的全排列</p><p>其方法核心大差不差，主要是在构造上</p><p>核心：枚举每一行上的皇后的全排列，在不冲突的前提下进行构造</p><h2 id="51-N-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><p>labuladong版本：</p><p>整体比较长，每一次都需要判断左上和右上角是否冲突</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chessRow : chessBoard) {</span><br><span class="line">            Arrays.fill(chessRow, <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backtracking(chessBoard, curRow, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curRow == n) {</span><br><span class="line">            <span class="comment">// 到叶子结点，将此时的棋盘加入答案</span></span><br><span class="line">            res.add(array2List(chessBoard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">curCol</span> <span class="operator">=</span> <span class="number">0</span>; curCol &lt; n; curCol++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(chessBoard, curRow, curCol)) {</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'Q'</span>;</span><br><span class="line">                backtracking(chessBoard, curRow + <span class="number">1</span>, n);</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> curCol)</span> {</span><br><span class="line">        <span class="comment">// 检查同一列是不是已经有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; curRow; r++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][curCol] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 \ 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol - <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; r--, c--) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 / 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; chessBoard[<span class="number">0</span>].length; r--, c++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span> {</span><br><span class="line">        List&lt;String&gt; transformedArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> chessBoard.length, c = chessBoard[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessBoard) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">                sb.append(chars[j]);</span><br><span class="line">            }</span><br><span class="line">            transformedArray.add(sb.toString());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transformedArray;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>灵神的第一个版本也需要判断：</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A7%A3%E6%B3%951.png" alt="N皇后_灵神_解法1"></p><p>但是加入了一点数学证明：即右上方的 r + c == 当前的 r + c 左上方的 r - c == 当前的 r - c:</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A1%8C%E5%88%97.png" alt="N皇后_灵神_行列"></p><p>从而发现我们可以通过开辟两个<code>boolean[]</code>来看r + c是否之前出现过如果出现过就说明当前位置无法放置皇后因为会冲突</p><p>修改过后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            List&lt;String&gt; board = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c : col) {</span><br><span class="line">                <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">                Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">                row[c] = <span class="string">'Q'</span>;</span><br><span class="line">                board.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">            }</span><br><span class="line">            paths.add(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="52-N-皇后-II"><a href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h2><p>只需要稍微更改下逻辑即可：这里我们返回计数而不是构造了一个答案</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>DP例题</h1><h1>DP</h1><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">198. 打家劫舍 https://leetcode.cn/problems/house-robber/solutions/2102725/ru-he-xiang-chu-zhuang-tai-ding-yi-he-zh-1wt1/</span><br><span class="line">70. 爬楼梯 https://leetcode.cn/problems/climbing-stairs/</span><br><span class="line">746. 使用最小花费爬楼梯 https://leetcode.cn/problems/min-cost-climbing-stairs/</span><br><span class="line">2466. 统计构造好字符串的方案数 https://leetcode.cn/problems/count-ways-to-build-good-strings/</span><br><span class="line">213. 打家劫舍 II https://leetcode.cn/problems/house-robber-ii/</span><br><span class="line">213. 打家劫舍 II 题解 https://leetcode.cn/problems/house-robber-ii/solution/jian-ji-xie-fa-zhi-jie-diao-yong-198-ti-qhvri/</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><p>按照思路一步步来：</p><ol><li>回溯怎么写：<ol><li>当前操作：选或者不选当前这家偷</li><li>子问题和下一个子问题：<ol><li>如果之前偷了，那就是从 n - 2开始</li><li>如果之前不偷，那就是从 n - 1开始</li></ol></li></ol></li></ol><p>回溯代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里的回溯定义，返回了从 n - 1开始之前的打家劫舍的最大值</p><p>加入记忆化搜索：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] cache;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cache[i] != -<span class="number">1</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        cache[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改造为递推</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        dp[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i + <span class="number">2</span>] = Math.max(dp[i + <span class="number">1</span>], dp[i] + nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空间优化（由于 i + 2 只和i + 1 以及 i 有关）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>由于现在是环形那么我们就是在原版的198中增加了一些条件限制：</p><ul><li>如果选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>2</code>开始；因为是环形，偷了第<code>i = 0</code>个意味着不能偷<code>i = n - 1</code>，也就是 偷<code>n - 2</code><ul><li>因此问题变成从<code>nums[2]</code> 到 <code>nums[n−2]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li><li>如果<code>不</code>选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>1</code>开始；因为是环形，偷了第 <code>i = 1</code>个意味着不能偷<code>i = n - 2</code>，也就是 偷<code>n - 1</code><ul><li>因此问题变成从<code>nums[1]</code> 到 <code>nums[n−1]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robFromLC198(nums, <span class="number">2</span>, n - <span class="number">2</span>) + nums[<span class="number">0</span>], robFromLC198(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robFromLC198</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h1><p>这是一道树形DP：</p><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%A0%91%E5%BD%A2DP_%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93.png" alt="树形DP_思路总结"></p><blockquote><p>这个考点叫树上最大独立集</p><p>最大独立集：从图中选出尽量多的点，是的这些点互不相邻；它的变形是最大化点权之和</p></blockquote><p><img src="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%A0%91%E5%BD%A2DP_%E4%B8%80%E8%88%AC%E6%A0%91_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3.png" alt="树形DP_一般树_打家劫舍3"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 应该就是将遍历方式转变为了tree的traversal</span></span><br><span class="line">    <span class="comment">// 就是 treeDFS + DP</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="type">int</span>[] res = dfs2(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(node)) {</span><br><span class="line">            <span class="keyword">return</span> memo.get(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 偷：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rob_result</span> <span class="operator">=</span> node.val </span><br><span class="line">        + (node.left == <span class="literal">null</span> ? <span class="number">0</span> : rob(node.left.left) + rob(node.left.right))</span><br><span class="line">        + (node.right == <span class="literal">null</span> ? <span class="number">0</span> : rob(node.right.left) + rob(node.right.right));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不偷，那就是由孩子们决定：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">not_rob_result</span> <span class="operator">=</span> rob(node.left) + rob(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.max(rob_result, not_rob_result);</span><br><span class="line">        memo.put(node, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点进行决策偷和不偷能获得的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dfs2(TreeNode node) {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] leftResult = dfs2(node.left);</span><br><span class="line">        <span class="type">int</span>[] rightResult = dfs2(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷：</span></span><br><span class="line">        <span class="comment">// 就不能偷下家</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resRob</span> <span class="operator">=</span> leftResult[<span class="number">0</span>] + rightResult[<span class="number">0</span>] + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不偷</span></span><br><span class="line">        <span class="comment">// 可以选择偷不偷下家其结果是由左子树的最大值（偷或不偷能获得的最大金额）和右子树的最大值决定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resNotRob</span> <span class="operator">=</span> Math.max(leftResult[<span class="number">0</span>], leftResult[<span class="number">1</span>]) + Math.max(rightResult[<span class="number">0</span>], rightResult[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {resNotRob, resRob};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p><ul><li>爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶</li><li>爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</li></ul><p>所以我们得到公式 dp[n]=dp[n−1]+dp[n−2]<br>同时需要初始化 dp[0]=1 和 dp[1]=1<br>时间复杂度：O(n)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 来表示到第i层的最低开销 dp[cost.length] 就是 到最顶</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        Arrays.stream(dp).forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后是基于dp数组的空间优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> <span class="number">0</span>, dpi2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) {</span><br><span class="line">            minCost = Math.min(dpi1 + cost[i - <span class="number">1</span>], dpi2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = minCost;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后是这次写出来的版本：根本区别是我定义是到达这个位置的最小成本（初始化f0 = cost[0] f1 = cost[1]）而之前的是初始化为0</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> cost[<span class="number">0</span>], f1 = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> Math.min(f0, f1) + cost[i];</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.min(f0, f1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h1><ol><li>题目中：请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。<ol><li>范围比较大，就是大概率dp问题</li></ol></li><li>这道题和 70 题类似思路是：<ol><li>dp定义：dp[i] 是当前长度为i的字符串数目<ol><li>所以答案是 dp[row] + … + dp[high]</li></ol></li><li>状态转移：和 70 题类似：<ol><li>70 是要么一次爬一级楼梯要么爬两级所以转移从 i - 1 以及 i - 2 得到</li><li>这道题是 转移从 zero 或者 one 得到<ol><li>i - zero 为末尾加了 zero 个 零</li><li>i - one 为 末尾 加了 one 个 一</li></ol></li></ol></li><li>初始化 技巧：涉及到方案数我们可以列举Corner Case e.g.: 如果是空串，那么就是 <code>f[0] = 1</code>空串的字符串个数为1</li><li>取MOD</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= high; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) dp[i] = (dp[i] + dp[i - zero]) % MOD ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) dp[i] = (dp[i] + dp[i - one]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) {</span><br><span class="line">            ans = (ans + dp[i]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">输出：8</span><br></pre></td></tr></tbody></table></figure><p>我们有dp数组：1 2 4 8</p><ul><li><code>dp[1]</code> = 2 (可以由1个1组成 或者 由1个0)</li><li><code>dp[2]</code> = 4 (<code>1</code>0， <code>1</code>1，<code>0</code>1，<code>0</code>0）</li><li><code>dp[3]</code> = 8 (<code>10</code>0，<code>10</code>1，<code>11</code>0，<code>11</code>1，<code>01</code>0，<code>01</code>1，<code>00</code>0，<code>00</code>1)</li></ul><p>所以就是每一次都将<code>添加1或0后的形成的方案数</code>+ <code>之前的结果转移</code>得到</p><h1>背包问题</h1><h2 id="0-1背包-和-完全背包">0-1背包 和 完全背包</h2><h2 id="494-目标和-01背包"><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a> - 01背包</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = <span class="built_in">this</span>.nums.length;</span><br><span class="line">        <span class="comment">// p &lt;- + 所能够组成的和</span></span><br><span class="line">        <span class="comment">// s &lt;- sum of the nums</span></span><br><span class="line">        <span class="comment">// s - p &lt;- - 所能组成的集合 </span></span><br><span class="line">        <span class="comment">// p - (s - p) = t</span></span><br><span class="line">        <span class="comment">// p - s + p = t</span></span><br><span class="line">        <span class="comment">// t = 2p - s</span></span><br><span class="line">        <span class="comment">// p = (t + s) // 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> target + s;</span><br><span class="line">        <span class="keyword">if</span> (p % <span class="number">2</span> != <span class="number">0</span> || s &lt; target || p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 递推</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[n + 1][p + 1];</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= p; j++) {</span></span><br><span class="line">        <span class="comment">//         if (j &lt; nums[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][j] = dp[i][j];</span></span><br><span class="line">        <span class="comment">//         } else {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][j] = dp[i][j] + dp[i][j - nums[i]];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n][p];</span></span><br><span class="line">        <span class="comment">// 递推优化I:</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[2][p + 1];</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= p; j++) {</span></span><br><span class="line">        <span class="comment">//         if (j &lt; nums[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[(i + 1) % 2][j] = dp[i % 2][j];</span></span><br><span class="line">        <span class="comment">//         } else {</span></span><br><span class="line">        <span class="comment">//             dp[(i + 1) % 2][j] = dp[i % 2][j] + dp[i % 2][j - nums[i]];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n % 2][p];</span></span><br><span class="line">        <span class="comment">// 递推优化II：</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[p + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> p; j &gt;= num; j--) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - num];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[p];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> target == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][target] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][target];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[idx]) {</span><br><span class="line">            <span class="comment">// 容量不够了 </span></span><br><span class="line">            memo[idx][target] = dp(idx - <span class="number">1</span>, target); </span><br><span class="line">            <span class="keyword">return</span> memo[idx][target];</span><br><span class="line">        } </span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> dp(idx - <span class="number">1</span>, target) + dp(idx - <span class="number">1</span>, target - nums[idx]);</span><br><span class="line">        memo[idx][target] = tot;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="322-零钱兑换-完全背包"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a> - 完全背包</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] coins;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = coins.length;</span><br><span class="line">        <span class="built_in">this</span>.coins = coins;</span><br><span class="line">        <span class="comment">// this.memo = new int[n + 1][amount + 1];</span></span><br><span class="line">        <span class="comment">// for (int[] m : memo) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(m, -1);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// int result = dp(0, amount);</span></span><br><span class="line">        <span class="comment">// return result &gt;= Integer.MAX_VALUE / 2 ? -1 : result;</span></span><br><span class="line">        <span class="comment">// 递推I - 无优化</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[n + 1][amount + 1];</span></span><br><span class="line">        <span class="comment">// for (int[] d : dp) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(d, Integer.MAX_VALUE / 2);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int capacity = 0; capacity &lt;= amount; capacity++) {</span></span><br><span class="line">        <span class="comment">//         if (capacity &lt; coins[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][capacity] = dp[i][capacity];</span></span><br><span class="line">        <span class="comment">//             continue;</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">      <span class="comment">// 这里指的是如果不选那么直接从上一个转移过来，如果选当前 i + 1 那么就从去掉当前 coint的地方转移而来</span></span><br><span class="line">        <span class="comment">//         dp[i + 1][capacity] = Math.min(dp[i][capacity], dp[i + 1][capacity - coins[i]] + 1);</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n][amount] &lt; Integer.MAX_VALUE / 2 ? dp[n][amount] : -1;</span></span><br><span class="line">        <span class="comment">// 递推II - 一维数组</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> coin; capacity &lt;= amount; capacity++) {</span><br><span class="line">                dp[capacity] = Math.min(dp[capacity], dp[capacity - coin] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dp[amount];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">return</span> amount == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>; <span class="comment">// 由于是取min, 所以这里返回0指有合法方案；</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][amount] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][amount];</span><br><span class="line">        <span class="keyword">if</span> (coins[idx] &gt; amount) {</span><br><span class="line">            memo[idx][amount] = dp(idx + <span class="number">1</span>, amount);</span><br><span class="line">            <span class="keyword">return</span> memo[idx][amount];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(dp(idx + <span class="number">1</span>, amount), dp(idx, amount - coins[idx]) + <span class="number">1</span>); <span class="comment">// 对于选择了硬币之后产生的方案数，我们对硬币数目+1</span></span><br><span class="line">        memo[idx][amount] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 回溯 </tag>
            
            <tag> backtrack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛记录</title>
      <link href="/posts/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/posts/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>🐛🦆！（飘了）</p></div><h1>第 359 场周赛</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经验集合</title>
      <link href="/posts/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/"/>
      <url>/posts/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1>腾讯</h1><h2 id="Java">Java</h2><p>集合类</p><ol><li>collection list set queue<br>LinkedList arraylist 区别<br>LinkedBlockingQueue</li><li>Map hashmap linkedhashmap sortMap<br>cuccrenthashmap</li></ol><p>多线程</p><ol><li>用到那些多线程框架<br>newCachedThreadPool newFixedThreadPool newSingleThreadExecutor newScheduleThreadPool</li></ol><p>锁</p><ol><li>synchronized ReentrantLock 区别<br>lock</li><li>公平锁/非公平锁</li><li>可重入锁 synchronized</li><li>独享锁/共享锁</li><li>互斥锁/读写锁 ReentrantLock</li><li>乐观锁/悲观锁 区别？ CAS算法</li><li>分段锁 ConcurrentHashMap</li></ol><p>tpc三次握手和四次挥手</p><p>epoll和select区别</p><p>设计模式<br>主要用到那些<br>Singleton 工厂 代理模式</p><p>spring 中用到的动态代理<br>动态代理实现和种类，区别</p><p>jvm回收，java的类加载机制</p><p>微服务，服务注册发现</p><p>docker k8s</p><p>数据库<br>介绍下sql优化经验<br>数据库有哪些常用的引擎，主要区别，索引的实现原理<br>b数，b+数的区别</p><p>动态内容<br>HA+Nginx<br>mybatis 动态分页组件<br>zookeeper 应用场景，一致性hash运用<br>对java 高并发的rpc框架<br>本地缓存+分布式缓存</p><p>1、关于spring的aop的实现方法<br>2、关于分布式消息队列，分布式缓存<br>3、关于rpc方面<br>4、关于hashmap源码实现<br>5、关于Java异常的续承层次结构，讲述异常的续承关系<br>6、关于https握手过程<br>7、关于java数据库问题定位和性能调优<br>8、关于设计模式，uml，jvm 内存回收机制问题<br>9、java中重载和重写有什么区别？分别用什么关键字？<br>10、java线程如何启动？<br>11、java中加锁的方式有哪些，怎么个写法？<br>12、乐观锁和悲观锁解释一下<br>13、ORACLE中的SQL如何进行优化，都有哪些方式？<br>14、java中类的加载机制<br>15、介绍一下自己最近做的一个典型的项目<br>16、在项目中遇到了哪些问题，自己是如何解决的<br>17、说一下有哪些常用的设计模式<br>18、事务有哪些特性，在ORACLE中隔离有哪些级别<br>19、使用memcached是一个什么样的原理<br>20、如何存放数据到memcached集群中，介绍一下这个过程。跟进的问题，讲一下一致性哈希算法的实现原理。<br>21、JVM中堆是如何管理的，JVM的内存回收机制，介绍一下<br>22、数据库慢查询优化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//笔试题目: 无</span></span><br><span class="line"><span class="comment">// 一、基础</span></span><br><span class="line"><span class="comment">//1.面向对象的特征</span></span><br><span class="line"><span class="comment">//2.重载和重写的区别</span></span><br><span class="line"><span class="comment">//3.抽象类和接口的区别</span></span><br><span class="line"><span class="comment">//4.List和Set区别（Arraylist、LinkedList）</span></span><br><span class="line"><span class="comment">//5.HashMap（原理及实现）</span></span><br><span class="line"><span class="comment">//6.线程池的原理及实现（ThreadLocal）</span></span><br><span class="line"><span class="comment">//7.JVM运行时内存区域(内存溢出OOM问题)</span></span><br><span class="line"><span class="comment">//8.常见的设计模式？简单介绍1~2个</span></span><br><span class="line"><span class="comment">//9.MySQL个人简单总结（索引优化）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 二、代码</span></span><br><span class="line"><span class="comment">//1.饿汉式、懒汉式的单例模式Java代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>Databricks 数据🧱</h1><a href="/posts/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="DataBricks">DataBricks</a>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>背包问题</h1><p>背包问题包含以下这些：<br><img src="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E8%83%8C%E5%8C%85%E6%A6%82%E8%BF%B0.png" alt="背包概述"></p><p>主要需要掌握的是01背包以及完全背包</p><p>完全背包是01背包的演化，完全背包的物品数量无限</p><h2 id="01背包">01背包</h2><p>定义：</p><p>有 <code>n</code> 件物品和一个最多能背重量为<code>w</code>的背包。</p><p>第 <code>i</code>件物品的重量是<code>weight[i]</code>，可以得到的价值是<code>value[i]</code>。每件物品只能用一次</p><p>将哪些物品放入背包里物品价值总和最大。</p><p>暴力解法：对于每一个物品我们有两个选择，选或者不选，所以可以采用回溯法来搜索所有的情况时间复杂度为 O(2^n) n是物品数量</p><p>所以需要优化 穷举 + 求最值 -&gt; 动态规划</p><h3 id="题目假设">题目假设</h3><p>背包最大重量为4，有如下的物品：</p><table><thead><tr><th>重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>目前最大价值为 4 * 15 = 60</p><h4 id="二维dp来解决01背包问题">二维dp来解决01背包问题</h4><ol><li><p>分析dp数组含义</p><p><code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p></li><li><p>递推公式</p><p><code>dp[i][j]</code>能被转移过来的情况分成两种</p><p>如果不放物品，就是从<code>dp[i - 1][j]</code>转移而来，由于不放入新的重量所以其实重量就还是<code>dp[i - 1][j]</code> 可能的场景是：当物品i的重量超过了背包能够承载的容积，新的物品i无法放入其中</p><p>如果放物品，考虑<code>dp[i - 1][j - weight[i]]</code>含义为背包容量为 <code>j - weight[i]</code>时候的不放入i所能获得的最大价值，贪心一点，我们必须要腾出这部分的空间才行因为我们要保证背包是一直饱和的状态是当时的最优解。</p><p>在0-1背包问题中，<code>dp[i][j]</code>通常表示前i个物品填满背包容量为j的最大价值。<code>dp[i - 1][j - weight[i]]</code>表示的是在背包容量为<code>j-weight[i]</code>的时候，前<code>i-1</code>个物品的最大价值。之所以使用这个状态转移方程，是因为我们在考虑是否将第i个物品放入背包时，需要先确定在还没有放入第i个物品，并且背包容量为<code>j-weight[i]</code>时的最大价值。</p><p>这里的“j - weight[i]”是为了腾出第i个物品所需的空间，以便我们能够将其放入背包。之后，我们将该物品的价值<code>value[i]</code>加上<code>dp[i - 1][j - weight[i]]</code>，这样就能得到在将第i个物品放入背包的情况下，能够得到的最大价值。</p><p>简单来说，<code>dp[i - 1][j - weight[i]] + value[i]</code>就表示：在考虑放入第i个物品（即在已经腾出了第i个物品所需的空间后），我们能够得到的最大价值。如果不把这个空间腾出来，那我们就没有地方放这个物品。</p></li><li><p>初始化</p><p>我们首先要对一个二维的数组来进行初始化因此需要搞清楚 [i] 和 [j] 的含义</p><p>回想定义：<code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p><p>那么 <code>dp[i][0]</code>指的是如果背包容量j为0，表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为0的背包，价值总和最大为多少，那么明显是0</p><p>其次由于我们需要使用 <code>dp[i - 1][j]</code> 来作为其中一项来推导<code>dp[i][j]</code>因此我们需要初始化<code>dp[0][j]</code>即，存放编号0的各种容量的背包中能获得的最大价值那么会有两种情况：</p><p>当 <code>j &lt; weight[0]</code>的时候，<code>dp[0][j]</code> 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code> 应该是value[0]，因为背包容量放足够放编号0物品。</p></li></ol><p>​综上，对于上面的例子我们有：</p><p><img src="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E5%88%9D%E5%A7%8B%E5%8C%961.png" alt="01背包初始化1"></p><p>对于其他的，由于都会被转化并且被覆盖新值，因此无论初始化成什么都可以</p><ol start="4"><li><p>确定遍历顺序</p><p>我们需要遍历是应该从物品[i]还是背包容积[j]开始</p><p>由于<code>dp[i][j]</code>所需要的数据就是左上角</p></li></ol><p><img src="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F.png" alt="01背包遍历顺序"></p><p>所以无论从哪里开始都可以得到结果</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E7%BB%93%E6%9E%9C.jpeg" alt="01背包结果"></p><h4 id="滚动数组优化">滚动数组优化</h4><p>由于<code>dp[i][j]</code>仅依赖于前一个物品的值（<code>dp[i - 1][j]</code> 和 <code>dp[i - 1][j - weight[i]]</code>），所以实际上我们并不需要维护一个二维数组，只需要一个一维数组就足够了。这个问题的特殊之处在于，<code>dp[i][j]</code>的值只依赖于<code>dp[i-1][*]</code>，即只依赖于前一个物品的状态。这给我们提供了一个优化空间，那就是我们其实不需要存储所有的i，也就是不需要存储所有物品的状态，只需要存储前一个物品的状态就足够了。这就是为什么我们可以省去一个维度的原因。我们使用一维数组dp[j]来替代二维数组<code>dp[i][j]</code>。在每一次的迭代中，dp[j]表示的都是在考虑当前物品，并且在背包容量为j的情况下，我们能获得的最大价值。换句话说，我们的一维数组dp[j]在每次迭代过程中，都相当于原来二维数组的<code>dp[i][j]</code>。</p><ol><li>dp数组含义：</li></ol><p>此时的含义就变为:</p><p>我们有容量为j的背包从前i个物品取能取到的最大价值</p><ol start="2"><li>转移方程递推公式：</li></ol><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>即：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>初始化：</li></ol><p>最初dp[0]容量为0的背包，那么最大价值一定为0</p><ol start="4"><li>遍历顺序</li></ol><p><strong>重点</strong>：在这个优化策略中，我们必须从大到小遍历j，这是因为dp[j - weight[i]]必须在dp[j]之前更新。原因是我们在每次迭代中都在复用上一轮迭代中的结果。为了确保这次迭代的结果不会影响到下一次迭代，我们需要从大到小遍历j。</p><p>具体地说，如果我们从小到大遍历j，考虑在计算dp[j]时，由于dp[j - weight[i]]可能在这个迭代过程中已经被更新过（因为j - weight[i] &lt; j），我们就会使用到这个物品i在多次的情况，这明显违反了我们的原始假设（每个物品只能用一次）。为了避免这个问题，我们选择从大到小遍历j，在计算dp[j]时，dp[j - weight[i]]对应的就是上一轮迭代的结果，也就是没有使用过物品i的情况。</p><p>例如，假设我们有物品的重量和价值分别为2和3，背包的容量为4，初始化dp数组为0。如果从小到大遍历j，计算过程如下：</p><ul><li>当j=2时，dp[2] = max(dp[2], dp[2-2] + 3) = 3</li><li>当j=3时，dp[3] = max(dp[3], dp[3-2] + 3) = 3</li><li>当j=4时，dp[4] = max(dp[4], dp[4-2] + 3) = 6</li></ul><p>在这个例子中，dp[4]的值为6，明显不对，因为我们的物品只有一个，但我们却计算得到了两个物品的价值，这就是因为在计算dp[4]时，dp[2]已经使用过当前物品，被更新为3了。</p><p>结论：从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><h1>例题</h1><h1><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></h1><p>第一个难点是如何转化为01背包问题：</p><p>这道题首先我们要等和，所以一个背包的容积就是 sum / 2</p><p>那么我们就是看是不是<strong>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p><blockquote><p>注意不能直接看除2是否能除尽，因为除2不代表有对应的子集比如[1,2,5]</p></blockquote><p><code>dp</code> 数组的定义：<code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</p><p>根据 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case:</span></span><br><span class="line">        <span class="comment">// 意思是当没有物品时背包永远不可能被装满</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= col; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 意思是当背包容量为0时，直接就是满的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= row; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= col; j++) {</span><br><span class="line">                <span class="comment">// 背包容量不够的情形：</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 没有办法再放入当前的物品, 结果就是如果之前的能刚好放进去，那么现在不放也可以刚好放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果我 i 刚好能放进去，那么我放入nums[i]也刚好能放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt;= row; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= col; j++) {</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " ");</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化：</p><p>相当于i直接就是每一层搞一次，但我们不用存储 i - 1的结果了，直接覆盖就可以了</p><p>Eg: [1,2,5]</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>t</td><td>f</td><td>f</td><td>f</td><td>f</td></tr><tr><td>1</td><td>t</td><td>t</td><td>f</td><td>f</td><td>f</td></tr><tr><td>2</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr><tr><td>3</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[col + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col; j &gt;= <span class="number">1</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];  </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// StringBuilder result = new StringBuilder();</span></span><br><span class="line">            <span class="comment">// for (boolean element : dp) {</span></span><br><span class="line">            <span class="comment">//     result.append(element).append(" ");</span></span><br><span class="line">            <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// // Remove the trailing space before printing</span></span><br><span class="line">            <span class="comment">// System.out.println(result.toString().trim());</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量 II</a></h1><p>和416类似，重点是要知道如何转换为01背包问题</p><p>对于石头问题，我们想要的是尽量让两边相等然后看差值。</p><p>那么就是有个容量为 sum/2的背包，里面能够装的最大的重量，就是尽可能让两边相等的解法。</p><p>所以就是：</p><p>对于容积为sum/2的背包，我们有 stones[i] 价值的，重量为stones[i]的石头，怎么放，价值最大：</p><p>常规的二维dp：</p><blockquote><p>注意labuladong和代码随想录不一样，labuladong的i从1开始然后 i - 1是对应的价值。而代码随想录从0开始，i就是对应的价值了</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[stones.length + <span class="number">1</span>][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sum / <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &gt; j) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 打印dp数组 </span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; stones.length; i++) { </span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= sum / 2; j++) { </span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " "); </span></span><br><span class="line">        <span class="comment">//     } </span></span><br><span class="line">        <span class="comment">//     System.out.println(); </span></span><br><span class="line">        <span class="comment">// } </span></span><br><span class="line">        <span class="keyword">return</span> sum - dp[stones.length][sum / <span class="number">2</span>] - dp[stones.length][sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化，注意遍历顺序，（虽然道理已经明白了，可是还是不太懂这个到底是怎么优化的。。。）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum / <span class="number">2</span>; j &gt;= stones[i - <span class="number">1</span>]; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] - dp[sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h1><p>本题的关键难点在于如何做好问题转化，即怎么把这个问题转换为01背包问题：</p><p>这是一个经典的子集和问题（subset sum problem）转化。原始问题是从数组 <code>nums</code> 中选取若干数，可以加上+或-号，使得它们的总和为 <code>target</code>。问题被转化为找出 <code>nums</code> 中有多少个子集 <code>A</code> 使得这个子集的和等于 <code>(target + sum(nums)) / 2</code>。</p><p>为什么要这样转化呢？我们来详细理解下。</p><p>原始方程是：<br>[ sum(A) - sum(B) = target ]</p><p>其中，<code>A</code> 是被加上 <code>+</code> 号的子集，<code>B</code> 是被加上 <code>-</code> 号的子集。</p><p>再加上以下方程：<br>[ sum(A) + sum(B) = sum(nums) ]</p><p>两边都加上 <code>sum(A)</code>：<br>[ 2 \times sum(A) = target + sum(nums) ]</p><p>从这个方程，我们得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]</p><p>这就将原始问题转化为一个子集和问题，即从 <code>nums</code> 中找到所有子集 <code>A</code>，其和为 <code>(target + sum(nums)) / 2</code>。这是一个经典的动态规划问题，通常使用一个二维数组 <code>dp</code> 来解决。<code>dp[i][j]</code> 表示使用前 <code>i</code> 个数字，能否组成和为 <code>j</code> 的子集。</p><p>那么为什么是<code>(target + sum(nums)) / 2</code> 而不是 target呢？</p><p>假设<code>nums: [1,2,3,4]</code> 和 <code>target:4</code> 。</p><p>首先，我们看转化的方法：</p><ol><li><p>从 <code>nums</code> 中选择数字，有的加上 <code>+</code> 号，有的加上 <code>-</code> 号，使其总和为 <code>target</code>。</p></li><li><p>使用转化方法，我们得到以下方程：<br>[ sum(A) - sum(B) = target ]<br>[ sum(A) + sum(B) = sum(nums) ]<br>代入第一个方程得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]<br>[ sum(A) = (4 + 10) / 2 = 7 ]</p></li></ol><p>所以，我们需要找到 <code>nums</code> 中子集和为7的所有情况。</p><p>以下是子集和为7的组合：</p><ol><li>[1,2,4]</li><li>[3,4]</li></ol><p>这些组合可以得到如下的表示达到 target 4：</p><ol><li>+1+2+4-3</li><li>+3+4-1-2</li></ol><p>现在，如果我们直接找出 <code>nums</code> 中的子集和为 <code>target=4</code> 的组合，我们得到：</p><ol><li>[1,3]</li><li>[4]</li></ol><p>这些组合表示了如何通过简单组合 <code>nums</code> 中的数字得到4，但没有表示如何通过加法和减法操作得到4。这就是为什么直接使用 <code>target</code> 作为背包容量是不准确的，因为你只能得到部分答案，而不能表示如何通过整个 <code>nums</code> 数组的加减操作得到目标值 <code>target</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>][subSetTotal + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 注意一下这里的初始化，dp[i][0]因为现在有可能性什么都不装即有一种装法，即从dp[0][0]转移而来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length + <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subSetTotal + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>二维变一维：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[subSetTotal + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> subSetTotal; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>📚 此文档包含以下几个部分：</p><ul><li><a href="/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/" title="最长公共子序列">最长公共子序列</a></li><li><a href="/posts/%E9%97%AB%E6%B0%8FDP%E5%88%86%E6%9E%90%E6%B3%95/" title="闫氏DP分析法">闫氏DP分析法</a> - Acwing</li></ul></div><h1>一般形式</h1><p>动态规划问题的一般形式就是<strong>求最值</strong>。核心问题是 <strong>穷举</strong>。</p><p>比如最长递增子序列，最小编辑距离这种问题</p><p>列出正确的状态转移方程，</p><p>判读是否具备最优子结构（即是否可以通过自问题的最值的道原问题的最值）</p><p>是否可以使用数据结构来优化穷举过程以避免不必要的计算。</p><p>一般包含以下三要素：</p><p>重叠子问题，最优子结构，状态转移方程</p><p>对于状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><h1>框架</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自顶向下递归的动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">状态<span class="number">1</span>, 状态<span class="number">2</span>, ...</span>):</span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 所有可能的选择:</span><br><span class="line">        <span class="comment"># 此时的状态已经因为做了选择而改变</span></span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></tbody></table></figure><h1>解题步骤</h1><ol><li>dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h1>自顶向下和自底向上</h1><p>以<a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a>为例：</p><h2 id="自顶向下">自顶向下</h2><p>自顶向下就像是DFS/递归，把大问题逐渐分解规模，直到base case。从上到下，然后逐层返回答案。（注意图中含有剪枝操作，好处是可以讲原本 O(2^n)的算法简化为 O(n)</p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B1.jpeg" alt="自顶向下1"></p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B2.jpeg" alt="自顶向下2"></p><h2 id="自底向上">自底向上</h2><p>就是从问题规模最小的问题（base case）往上推直到得到问题的答案</p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A1.jpeg" alt="自底向上1"></p><h1>状态转移方程</h1><p>依旧用509斐波那契数举例子：</p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-fib.png" alt="状态转移方程-fib"></p><p><code>f(n)</code> 的函数参数会不断变化，所以你把参数 <code>n</code> 想做一个状态，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 转移（相加）而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式</p><h1>最优子结构</h1><p>子问题间必须相互独立 -&gt; 最优子结构</p><p>例子：比如我想考第一名那么每一科目都考第一就能总成绩第一，但是一般数学高的话语文就会低，这就违背了子问题间相互独立</p><h1>如何写状态转移方程</h1><p>自己总结的：</p><p>感觉题目基本就给了dp函数的定义，可以尝试一下能否写出来base case，当前状态，以及怎么做选择</p><ol><li>明确 状态 + 选择</li></ol><p>​状态：过程中会变化的</p><p>​选择：导致状态发生改变的</p><ol start="2"><li>明确 dp数组 定义</li><li>带入定义搞清楚 base case 以及 目标/终点 或者 查看定义是否正确 即能否转移来，子问题是什么？</li></ol><h1>如何定位重叠子问题</h1><p>首先理解为什么会重叠？</p><p>这是因为在状态转移的过程中，同一个状态有多个转移过去的方式，从而导致了重复的计算。</p><p>步骤：</p><ol><li><strong>抽出来dp过程中递归部分中，递归出现次数多的部分</strong></li><li><strong>定位为了到达目标，是否有同一个状态有多种转移过去的方式</strong></li></ol><h1>如何确定dp数组的遍历顺序</h1><p>确定base case 就是起点从哪里开始，终点就是想要的结果，方向就是起点到终点</p><p>basecase 可以转移到哪里，基本就确定了转移方向</p><p>下图：我们可以从 basecase: (0, 0) (0, 1) (1, 0) 从而得到 (1, 1) 之后又可以用 (0, 1) (1, 1) (0, 2) 从而得到 (1, 2) 以此类推</p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F_1.png" alt="确定遍历顺序_1"></p><p>再比如：</p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F_2.png" alt="确定遍历顺序_2"></p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F_3.png" alt="确定遍历顺序_3"></p><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F_4.png" alt="确定遍历顺序_4"></p><h1>状态压缩</h1><p>使用一个二进制数表示当前哪些数已被选，哪些数未被选，目的是为了可以使用位运算进行加速。</p><p>Eg: 二进制：(000… 0101) 表示1和3被visited过了</p><p>当我们需要检查值为 <em>k</em> 的数是否被使用时 <code>a = (state &gt;&gt; k) &amp; 1</code>查看第k位为1（被使用）或0（未被使用）</p><h1>问题分析</h1><h2 id="以322-零钱兑换为样例：">以<a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>为样例：</h2><p>按照：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><ol><li>明确 base case:<ol><li>剩余钱为0时即不需要任何其他的硬币，达到结果</li></ol></li><li>明确「状态」</li><li>状态：原问题和子问题中会变化的变量：amount</li><li>由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</li><li>明确「选择」<ol><li>每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li></ol></li><li>dp<ol><li>函数：<ol><li>自顶向下<ol><li>函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。</li><li>就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</li><li><strong><code>dp(n)</code> 表示，输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 所需的最少硬币数量</strong>。</li></ol></li></ol></li><li>数组：<ol><li>自底向上<ol><li><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</li></ol></li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  <span class="type">int</span>[] memo;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      memo = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">      Arrays.fill(memo, -<span class="number">999</span>);</span><br><span class="line">      <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (memo[amount] != -<span class="number">999</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">subAmount</span> <span class="operator">=</span> dp(coins, amount - coin);</span><br><span class="line">          <span class="keyword">if</span> (subAmount &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">          res = Math.min(res, subAmount + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">      memo[amount] = (res == Integer.MAX_VALUE) ? -<span class="number">1</span> : res;</span><br><span class="line">      <span class="keyword">return</span> memo[amount];</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 自底向上：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">      Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) {</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">              <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">              dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="72-编辑距离"><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length(), n = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 状态：dp[i][j] 表示word1[0, i] 转换成 word2[0, j] 所使用的最小操作数</span></span><br><span class="line">        <span class="comment">// 选择：相等时 什么都不做，不相等时可以 插入，删除，替换，</span></span><br><span class="line">        <span class="comment">// 函数定义：表示word1[0, i] 转换成 word2[0, j] 所使用的最小操作数</span></span><br><span class="line">        <span class="comment">// 状态转移：相等时 什么都不做; Min(插入，删除，替换) </span></span><br><span class="line">        <span class="comment">// dp[i][j] = Math.min(</span></span><br><span class="line">        <span class="comment">//     dp[i - 1][j]; // 删除</span></span><br><span class="line">        <span class="comment">//     dp[i][j - 1]; // 插入</span></span><br><span class="line">        <span class="comment">//     dp[i - 1][j - 1]; // 替换</span></span><br><span class="line">        <span class="comment">// )</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case:</span></span><br><span class="line">        <span class="comment">// word1 为 空字符串, 转换为 word2[0, j] 需要 j 种方法 （直接增加）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// word2 为 空字符串, 转换为 word1[0, i] 需要 i 种方法 （直接增加）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 都为空串:</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.min(</span><br><span class="line">                        dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                        Math.min(</span><br><span class="line">                            dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                            dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                        )</span><br><span class="line">                    );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>如何debug</h1><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong> 然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><h1><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>其实就是斐波那契数</p><p>f[x] = f[x - 1] + f[x - 2]</p><p>自顶向下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n +<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">        <span class="keyword">if</span> (floor == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (floor &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[floor] != <span class="number">0</span>) <span class="keyword">return</span> memo[floor];</span><br><span class="line">        memo[floor] = dp(floor - <span class="number">2</span>) + dp(floor - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[floor];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(System.out::println);</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(System.out::println);</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 来表示到第i层的最低开销 dp[cost.length] 就是 到最顶</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空间优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> <span class="number">0</span>, dpi2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) {</span><br><span class="line">            minCost = Math.min(dpi1 + cost[i - <span class="number">1</span>], dpi2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = minCost;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><ol><li>确定 dp 函数的含义：<ol><li><code>dp[i][j]</code> 代表 从 起点出发， 到 <code>(i,j)</code> 的路径方案总数</li></ol></li><li>确定递推公式<ol><li>由于方向只能从 <code>上面</code> 以及 <code>左面</code> 所以 <code>dp[i][j]</code> 会由 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>转移而来。</li><li><code>dp[i - 1][j]</code> 是从(0, 0)的位置到(i - 1, j)有几条路径，<code>dp[i][j - 1]</code>同理。</li></ol></li><li>初始化<ol><li><code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。</li></ol></li><li>确定遍历顺序<ol><li>我们要保证转移的顺序，因此 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 必须先由<code>dp[i][j]</code>计算完成</li><li>发现顺序遍历就可以达到这个效果，因此顺序遍历</li></ol></li><li>举例推导dp数组</li></ol><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc62_%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BC.png" alt="lc62_举例推导"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自顶向下：（但是memo其实就是dp table了）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> dp(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 代表 (0, 0) 到 (0, 0) 有一条路径</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        memo[i][j] = dp(i - <span class="number">1</span>, j) + dp(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h1><p>总体和 62 差别不大，但是在初始化时以及转移方程需要特别处理一下：</p><ol><li>确定dp数组（dp table）以及下标的含义<ol><li><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</li></ol></li><li>确定递推公式<ol><li>递推公式和62.不同路径一样，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li><li>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）</li></ol></li><li>初始化<ol><li>这里的区分比较大，主要是由于在第一行和第一列如果有了障碍，那么这个障碍之后的全部都应为0</li></ol></li></ol><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc63_1.png" alt="lc63_1"></p><ol start="4"><li>确定遍历顺序<ol><li>一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，<code>dp[i - 1][j] 和 dp[i][j - 1]</code>一定是有数值。</li></ol></li><li>举例推导dp数组</li></ol><p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc63_%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BC.png" alt="lc63_举例推导"></p><p>自底向上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自顶向下 （记忆化搜索）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="type">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        grid = obstacleGrid;</span><br><span class="line">        <span class="keyword">return</span> dp(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        memo[i][j] = dp(i - <span class="number">1</span>, j) + dp(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h1><p>这道题主要难在怎么分：</p><p>一开始思维方式是dfs，求出来所有组合，然后每一个组合都要相乘，比较最大值，但是显然这样我们需要非常大的空间来存储。</p><p>用<code>dp[n]</code>来表示整数为n时，我们能够得到的最大乘积。</p><p>转移方程比较难想：</p><p>比方说 <code>n = 4</code>，我们可以把 4 拆分成 <code>1 + 3, 2 + 2</code>，对应的乘积就是 <code>1 * 3, 2 * 2</code>。但此时我们直接比较 <code>1 * 3, 2 * 2</code> 的大小还不够，因为 <code>3, 2</code> 它们可能还会被分解成 <code>1 * 2, 1 * 1</code>，也就是说把 <code>n = 4</code> 进一步分解成 <code>1 * (1 * 2), 2 * (1 * 1)</code>，这两种可能也要纳入考虑。</p><p>到底需不需要进一步分解呢？不知道，所以我们都穷举一遍取最大值就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  integerBreak(<span class="number">4</span>)</span><br><span class="line">= max(<span class="number">1</span> * <span class="number">3</span>, <span class="number">1</span> * integerBreak(<span class="number">3</span>), <span class="number">2</span> * <span class="number">2</span>, <span class="number">2</span> * integerBreak(<span class="number">2</span>))</span><br><span class="line">= max(</span><br><span class="line">    <span class="number">1</span> * max(<span class="number">3</span>, integerBreak(<span class="number">3</span>)),</span><br><span class="line">    <span class="number">2</span> * max(<span class="number">2</span>, integerBreak(<span class="number">2</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>其实就是拿着刚分解完的结果以及未来要分解的结果求最大值。</p><p>再加上 memo 来消除重叠子问题：</p><p>自顶向下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[n] 为 把n拆分后的乘积最大的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            result = Math.max(</span><br><span class="line">                result, </span><br><span class="line">                i * Math.max(dp(n - i), n - i)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        memo[n] = result;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上：</p><p>整体思路是差不多的，都是考虑了两种情况：</p><p><code>dp[i]</code>要么从 <code>dp[i - j] * j</code> 转移而来 要么从 <code>(i - j) * j</code> 转移而来，</p><p>由于<code>dp[i]</code>之前已经被赋值，因此我们仍需要加入最大值判断</p><p>比较特殊的点在于初始化：</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1。</p><p>以及遍历顺序：</p><p><code>dp[i]</code> 是依靠 <code>dp[i - j]</code>的状态，所以遍历i一定是从前向后遍历，先有<code>dp[i - j]</code>再有<code>dp[i]</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 表示 i 拆分后能够获得的最大乘积</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) {</span><br><span class="line">                dp[i] = Math.max(</span><br><span class="line">                    dp[i],</span><br><span class="line">                    Math.max(</span><br><span class="line">                        dp[i - j] * j, (i - j) * j</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>背包问题</h1><p>见 <a href="/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" title="背包问题">背包问题</a> 中包含背包问题的思路</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/posts/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/posts/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>引用：</p><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考  <a href="https://cloud.tencent.com/developer/article/1684188">什么是计数排序？</a> 感谢支持！</p></div><h1>概念：</h1><p>计数排序（Counting Sort）是一种针对于<strong>特定范围</strong>之间的整数进行排序的算法。它通过统计给定数组中不同元素的数量（类似于哈希映射），然后对映射后的数组进行排序输出即可。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/posts/%E8%B4%AA%E5%BF%83/"/>
      <url>/posts/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1>贪心思想</h1><p>核心：从局部最优到全局最优</p><h2 id="解题步骤">解题步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>找出局部的最优解，从而推出全局最优解</p><h1><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h1><p>两个贪心思路：</p><p>大饼干喂大胃口 或者 小饼干喂小胃口</p><p>自己的解法：贪心 + 排序 + 双指针</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length;) {</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt;= g[i]) {</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他解法：贪心 + 排序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 思路1：优先考虑饼干，小饼干先喂饱小胃口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length &amp;&amp; start &lt; g.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= g[start]) {</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 思路2：优先考虑胃口，先喂饱大胃口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> g.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">            <span class="keyword">if</span>(start &gt;= <span class="number">0</span> &amp;&amp; g[index] &lt;= s[start]) {</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h1><p>贪心思想：（假装）删除单调坡度上的节点从而使得局部峰值++</p><p>需要分三种情况：</p><ul><li>上下坡中有平坡<ul><li>[1,2,2,2,1], 此时应返回3</li></ul></li><li>数组首尾两端</li><li>单调坡中有平坡</li></ul><h2 id="上下坡中有平坡">上下坡中有平坡</h2><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc376%E4%B8%8A%E4%B8%8B%E5%9D%A1%E4%B8%AD%E6%9C%89%E5%B9%B3%E5%9D%A1.png" alt="lc376上下坡中有平坡"></p><p>添加 <code>preDiff = 0</code> 即可解决问题</p><h2 id="数组首尾两端">数组首尾两端</h2><p>题目要求如果只有两个元素，且两个元素不想等，此时长度为2。</p><p>解决方法：补全开头的元素 -&gt; preDiff 初始值为0</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc376%E6%95%B0%E7%BB%84%E9%A6%96%E5%B0%BE%E4%B8%A4%E7%AB%AF.png" alt="lc376数组首尾两端"></p><h2 id="单调坡中有平坡">单调坡中有平坡</h2><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc376%E5%8D%95%E8%B0%83%E5%9D%A1%E4%B8%AD%E6%9C%89%E5%B9%B3%E5%9D%A1.png" alt="lc376单调坡中有平坡"></p><p>此时结果应为2不为3，如果我们按照以下的代码更新 <code>preDiff</code>就会出现问题，因为此时preDiff直接，实时地更新为curDiff：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) {</span><br><span class="line">                result++;</span><br><span class="line">            }</span><br><span class="line">            preDiff = curDiff; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解决方法：preDiff当且仅当摆动时才更新</p><h2 id="结论">结论</h2><p>综上我们有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 解决情况二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (checkWiggle(preDiff, curDiff)) {</span><br><span class="line">                result++;</span><br><span class="line">                <span class="comment">// preDiff 只在有摆动的时候更新，主要解决情况三：单调有平坡</span></span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkWiggle</span><span class="params">(<span class="type">int</span> preDiff, <span class="type">int</span> curDiff)</span> {</span><br><span class="line">      <span class="comment">// 解决情况1</span></span><br><span class="line">        <span class="keyword">if</span> (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span> || preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PS:本题也可以使用动态规划：（当前仅了解，tbc…）</p><ul><li>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</li><li>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</li></ul><p>转移方程为：</p><ul><li><code>dp[i][0] = max(dp[i][0], dp[j][1] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &lt; nums[i]</code>，表示将 nums[i]接到前面某个山谷后面，作为山峰。</li><li><code>dp[i][1] = max(dp[i][1], dp[j][0] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &gt; nums[i]</code>，表示将 nums[i]接到前面某个山峰后面，作为山谷。</li></ul><h1><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="lc53最大子序和"></p><h2 id="贪心">贪心</h2><p>连续和 + 当前数，如果连续和 &lt; 0 那么直接取当前数作为新的开始。因为连续和&lt;0必定会拖累当前数的值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            count += curNum;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) result = count; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>本题的贪心用法在于一个数学思想：</p><p>比如我们需要计算第三天卖出第零天买入能够产生的利润，那么就是 <code>profit[3] - profit[0]</code>. 巧妙的利用下数学性质：</p><p><code>profit[3] - profit[0] = proft[3] - profit[2] + profit[2] - profit[1] + profit[1] - profit[0]</code></p><p>也就是每一天的利润差额。</p><p>因此：</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc122_greedy.png" alt="lc122_greedy"></p><p>因此我们只需要收集两天股票差额为正数的利润就可以拿到最终全局的一个最大利润，即局部最优到全局最优。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">           <span class="type">int</span> <span class="variable">curProfit</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span> (curProfit &gt; <span class="number">0</span>) sum += curProfit;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><p>首先我们不需要实际的知道要跳到哪里，我们只需要知道覆盖范围即可，因为在这个最大范围中，不管怎么跳都可以跳到。</p><p>因此检查覆盖范围是否包含终点就是我们要的结果。</p><p>贪心思想：<strong>每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 每一次都选能走的最大的步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) {</span><br><span class="line">            cover = Math.max(cover, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>和上一道题的区别在于，此题需要计算能够到终点的步数。因此在继承了上一步的 <strong>覆盖范围</strong> 的思路上我们需要知道什么时候把返回值增加。</p><p>覆盖范围不变，当index到了当前能覆盖的最远距离时，返回值增加。因为当前覆盖的范围是无论如何都能达到的。</p><p>贪心思想：覆盖范围最大，使用的步数最少。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>, nextCover = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            nextCover = Math.max(nextCover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curCover) {</span><br><span class="line">                count++;</span><br><span class="line">                curCover = nextCover;</span><br><span class="line">                <span class="keyword">if</span> (nextCover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h1><p>贪心 + 分情况讨论</p><p><code>取反一个负数会使得结果变大，取反正数会使结果变小，取反 0 值对结果没有影响</code></p><p>如果想要把 nums[i] 替换为 -nums[i] 并且想要得到可能的最大和。那么我们应该尽量：</p><ol><li>更改负数，将负数变为正数</li><li>将正数的值小的数变为负数从而减少影响。</li></ol><p>因此需要按照绝对值的大小来进行降序排序。然后优先更改负数。如果k&lt;负数个数的情况直接返回结果，但如果 <em>K</em> 的值较大，那么我们不得不去修改非负数（即正数或者 0）了：</p><ul><li>如果数组中存在 0，那么我们可以对它进行多次修改，直到把剩余的修改次数用完；</li><li>如果数组中不存在 0 并且剩余的修改次数是偶数，由于对同一个数修改两次等价于不进行修改，因此我们也可以在不减小数组的和的前提下，把修改次数用完；</li><li>如果数组中不存在 0 并且剩余的修改次数是奇数，那么我们必然需要使用单独的一次修改将一个正数变为负数（剩余的修改次数为偶数，就不会减小数组的和）。为了使得数组的和尽可能大，我们就选择那个最小的正数。</li></ul><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>这道题可以用<a href="/posts/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/" title="计数排序">计数排序</a>来优化（June 9th： 还在学习计数排序）</p></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        Integer[] numsInt = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.sort(numsInt, (a, b) -&gt; Math.abs(b) - Math.abs(a));</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; numsInt.length &amp;&amp; k &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (numsInt[idx] &lt; <span class="number">0</span>) {</span><br><span class="line">                numsInt[idx] = -numsInt[idx]; </span><br><span class="line">                k--;</span><br><span class="line">            } </span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) numsInt[numsInt.length - <span class="number">1</span>] = -numsInt[numsInt.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : numsInt) result += a;        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h1><p>这道题的思路有点像跳跃游戏，同样需要看覆盖范围。</p><ol><li>若总油量 &gt; 总消耗，那么一定有办法绕一圈</li><li>记录一个curSum来跟踪当前油量和，如果curSum &lt; 0那么说明<strong>之前无论怎么走都无法达到当前的点i，因此从下一个点开始找，并且重置curSum</strong></li></ol><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc_%E5%8A%A0%E6%B2%B9%E7%AB%99.png" alt="lc_加油站"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h1><p>左右扫描两次 + 贪心</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc135_%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.png" alt="lc135_分发糖果"></p><p>单从左向右扫描就会导致单调递减的情况下出错，因此我们需要再从右向左扫描一遍。</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C2.png" alt="分发糖果2"></p><p>贪心：</p><p>取最大值从而满足当前的孩子的糖比左和右都大，从而满足题目条件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> {</span><br><span class="line">        <span class="type">int</span>[] candies = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">// Arrays.fill(candies, 1);</span></span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) {</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) {</span><br><span class="line">                candies[i - <span class="number">1</span>] = Math.max(candies[i - <span class="number">1</span>], candies[i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            ret += candies[i];</span><br><span class="line">        }</span><br><span class="line">        ret += candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h1><p>分类讨论 + 贪心</p><p>顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票面值只可能是 5 美元，10 美元和 20 美元三种</p><p>所以会有以下的情况：</p><ul><li>5 美元，由于柠檬水的价格也为 5 美元，因此我们直接收下即可。</li><li>10 美元，我们需要找回 5 美元，如果没有 5 美元面值的钞票，则无法正确找零。</li><li>20 美元，我们需要找回 15 美元，此时有两种组合方式，一种是一张 10 美元和 5 美元的钞票，一种是 3 张 5 美元的钞票，如果两种组合方式都没有，则无法正确找零。当可以正确找零时，两种找零的方式中我们更倾向于第一种，即如果存在 5 美元和 10 美元，我们就按第一种方式找零，否则按第二种方式找零，因为需要使用 5 美元的找零场景会比需要使用 10 美元的找零场景多，我们需要尽可能保留 5 美元的钞票。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) {</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) {</span><br><span class="line">                <span class="comment">// 此时只能找5块的</span></span><br><span class="line">                count[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 贪心：优先用10元，没10元的再用两个5元</span></span><br><span class="line">                <span class="keyword">if</span> (count[<span class="number">1</span>] &gt; <span class="number">0</span>) {</span><br><span class="line">                    count[<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    count[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    count[<span class="number">0</span>] -= <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                count[<span class="number">2</span>]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><ol><li>这道题类似于分糖果（135），有两个纬度需要考虑，但是一样的，我们一次只考虑一个。</li><li>若考虑K维度：<ol><li>按照k从小到大，当相等时h从小到大<ol><li>排序的结果一条都不满足，一个纬度都确定不下来</li></ol></li></ol></li><li>若考虑H维度：<ol><li>按照H从高到低，当相等时K从低到高，这样的身高相对顺序是被确定了的</li></ol></li></ol><p>因此我们考虑确定H维度：</p><p><strong>优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong>这是因为按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/LC_406.jpg" alt="LC_406"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) {</span><br><span class="line">        <span class="comment">// 确定一个维度再处理另一个纬度</span></span><br><span class="line">        <span class="comment">// 确定身高纬度：（因为如果确定的是K的维度，那么比如k按照升序排列，当相等时h按照升序排列，会发现没有按照k的要求得到一个排序的队列）</span></span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] person1, <span class="type">int</span>[] person2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">0</span>] - person1[<span class="number">0</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">1</span>] - person2[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) {</span><br><span class="line">            <span class="type">int</span>[] person = people[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> person[<span class="number">1</span>];</span><br><span class="line">            ret.add(position, person);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1>区间调度，重叠类问题</h1><h2 id="什么是区间调度问题">什么是区间调度问题</h2><p>"区间调度"是一类常见的计算机科学问题，其主要目标是在给定一组区间时，找出最多的不相交区间。在这个问题中，区间通常以一对数字表示，例如 [a, b)，表示一个区间从 a 开始，到 b 结束。</p><p>具体的问题定义如下：</p><p>给定一个区间的集合，每个区间包括一个开始时间和一个结束时间。编写一个算法，找到最大的不相交区间的集合，即在这个集合中，任何两个区间都不会重叠。</p><p>例如，假设我们有以下区间：[1, 2], [2, 3], [3, 4], [1, 3]。最大的不相交区间的集合是 [1, 2], [2, 3], [3, 4]，因为我们可以安排这些区间，使得没有任何两个区间是重叠的。</p><p>注意，在解决这类问题时，一个常用的策略是贪心算法。我们首先将所有区间按照结束时间排序，然后每次选择结束时间最早的区间，并且这个区间不与已选择的区间重叠。这种方法能够确保我们总是选择最多的不相交区间。</p><h2 id="具体思路">具体思路</h2><p>对于区间调度问题，我们考虑如下的贪心思路：</p><ol><li>每次选择可选区间中开始最早的那个</li><li>每次选择可选区间中最短的那个</li><li>选择出现冲突最少的那个区间</li></ol><p>但是这些都不对，以下是反例：</p><ol><li><p>每次选择可选区间中开始最早的：</p><p>对于区间集合 = [[1,9], [2,5], [6,8]]</p><p>应该返回的结果是2，因为可以选中两个区间，即[2,5]和[6,8]。</p><p>但如果使用这种策略，实际返回的结果是1，因为它首先选择了开始最早的区间[1,9]，而错过了后面的两个区间。</p></li><li><p>每次选择最短的区间：</p><p>对于区间集合 = [[1,3], [2,4], [5,7], [6,9]]</p><p>应该返回的结果是2，因为可以选择两个不相交的区间，例如[1,3]和[5,7]或者[2,4]和[6,9]。</p><p>但如果使用这种策略，实际返回的结果是3，它选中了[1,3]，[2,4]和[6,9]，但其中[1,3]和[2,4]是冲突的。</p></li><li><p>每次选择出现冲突最少的区间：</p><p>对于区间集合 = [[1,4], [2,3], [5,6]]</p><p>应该返回的结果是2，因为可以选择两个不相交的区间，即[1,4]和[5,6]。</p><p>但如果使用这种策略，实际返回的结果是2，选中的区间是[2,3]和[5,6]，虽然结果数量是对的，但选中的区间并不是最优的，因为选择[1,4]和[5,6]可以覆盖更大的区域。</p></li></ol><p>所以，上述的三种贪心策略都不能保证得到最优答案。正确的贪心策略应该是：每次选择结尾最早的，且与当前已选区间不冲突的区间。</p><p>实现上可以分为以下三步：</p><ol><li>从排序好的（按照结束时间升序排列）选择区间右节点<code>xEnd</code></li><li>把与xEnd相交的区间删除（skip）</li><li>重复直至结束</li></ol><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc_%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6.gif" alt="lc_区间调度"></p><p>为什么选择区间右端点？</p><p><strong>由于我们事先排了序</strong>，不难发现所有与 <code>x</code> 相交的区间必然会与 <code>x</code> 的 <code>end</code> 相交；如果一个区间不想与 <code>x</code> 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）<code>x</code> 的 <code>end</code>：</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc_%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A62.jpeg" alt="lc_区间调度2"></p><h2 id="452-用最少数量的箭引爆气球"><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h2><p>核心在于：</p><ol><li><p>如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间</p></li><li><p>两个边界挨着的时候也可以使气球引爆</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] point1, <span class="type">int</span>[] point2)</span> {</span><br><span class="line">                <span class="comment">// return point1[1] - point2[1]; 为了应对 [[-2147483646,-2147483645],[2147483646,2147483647]] 不能这么写</span></span><br><span class="line">                <span class="keyword">if</span> (point1[<span class="number">1</span>] &gt; point2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">1</span>] &lt; point2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> findIntervals(points);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findIntervals</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">xEnd</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point : points) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> point[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt; xEnd) {</span><br><span class="line">                count++;</span><br><span class="line">                xEnd = point[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="435-无重叠区间"><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>找到最多不会重复的区间，原长度剪去就是剩下的至少需要去除的区间</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (interval1[<span class="number">1</span>] &gt; interval2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (interval1[<span class="number">1</span>] &lt; interval2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">noOverlappingCount</span> <span class="operator">=</span> findNotOverlaps(intervals);</span><br><span class="line">        <span class="keyword">return</span> intervals.length - noOverlappingCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findNotOverlaps</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= end) {</span><br><span class="line">                end = interval[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="763-划分字母区间"><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h2><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc763.png" alt="lc763"></p><p><strong>找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span>[] charPositions = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">27</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            charPositions[s.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            right = Math.max(charPositions[c - <span class="string">'a'</span>], right); <span class="comment">// 找到重叠区间的最右端点</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) {</span><br><span class="line">                res.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="56-合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>按照右端点排序非常的麻烦，因为会出现：</p><p><code>[[2,3],[4,5],[6,7],[8,9],[1,10]]</code></p><p>这个样例需要返回 <code>[1,10]</code>，如果使用正常的正序遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">1</span>] &gt; arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">1</span>] == arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ret.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevLeft</span> <span class="operator">=</span> intervals[i - <span class="number">1</span>][<span class="number">0</span>], prevRight = intervals[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= prevRight) {</span><br><span class="line">                <span class="comment">// need to update interval;</span></span><br><span class="line">                <span class="type">int</span>[] removed = ret.remove(ret.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prevLeft &gt; left) {</span><br><span class="line">                    ret.add(intervals[i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    removed[<span class="number">1</span>] = right;</span><br><span class="line">                    ret.add(removed);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ret.add(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] retArr = <span class="keyword">new</span> <span class="title class_">int</span>[ret.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.size(); i++) {</span><br><span class="line">            retArr[i] = ret.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么会返回结果:</p><p><code>[[2,3],[4,5],[6,7],[1,10]]</code></p><p>所以我们需要倒序遍历，并将需要加入的不能合并的区间加入链表头，每一次取表头来和当前区间比较是否需要合并，递归处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">1</span>] &gt; arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">1</span>] == arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the end to sort will make this part harder: </span></span><br><span class="line">        <span class="comment">// eg test case: [[2,3],[4,5],[6,7],[8,9],[1,10]],</span></span><br><span class="line">        <span class="comment">// to solve this problem, we need to loop from the end:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> intervals.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) {</span><br><span class="line">            <span class="keyword">if</span> (ret.isEmpty()) {</span><br><span class="line">                ret.addFirst(intervals[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] last = ret.getFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevLeft</span> <span class="operator">=</span> last[<span class="number">0</span>], prevRight = last[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= prevLeft) {</span><br><span class="line">                <span class="comment">// need to update interval;</span></span><br><span class="line">                last[<span class="number">0</span>] = Math.min(prevLeft, left);</span><br><span class="line">                last[<span class="number">1</span>] = Math.max(prevRight, right);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ret.addFirst(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] retArr = <span class="keyword">new</span> <span class="title class_">int</span>[ret.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.size(); i++) {</span><br><span class="line">            retArr[i] = ret.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1288-删除被覆盖区间"><a href="https://leetcode.cn/problems/remove-covered-intervals/">1288. 删除被覆盖区间</a></h2><p>按照左端点升序排列后右端点按照降序排列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeCoveredIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">0</span>] &gt; arr2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">0</span>] &lt; arr2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curLeft</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], curRight = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= curLeft &amp;&amp; right &gt;= curRight) {</span><br><span class="line">                <span class="comment">// 判断是否覆盖：</span></span><br><span class="line">                count++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= curLeft &amp;&amp; right &lt; curRight) {</span><br><span class="line">                <span class="comment">// 相交情况下，扩展当前区间</span></span><br><span class="line">                right = curRight;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (curLeft &gt; left &amp;&amp; curRight &gt; right) {</span><br><span class="line">              <span class="comment">// 完全不相交，更新left，right</span></span><br><span class="line">                left = curLeft;</span><br><span class="line">                right = curRight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="986-区间列表的交集"><a href="https://leetcode.cn/problems/interval-list-intersections/">986. 区间列表的交集</a></h2><p>分情况分析讨论题</p><p>这道题按照区间的重合可以区分为以下四种情况：</p><p>设两个列表的每个区间为 <code>[an, an+1]</code> <code>[bn, bn+1]</code>，那么如果这两个区间有交集，需满足 <code>b2 &gt;= a1 &amp;&amp; a2 &gt;= b1</code>，分下面四种情况：</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc986_%E6%83%85%E5%86%B5.jpeg" alt="lc986_情况"></p><p>如果有交集<code>[c1,c2]</code>那么我们有 <code>c1 = max(a1, b1), c2 = min(a2, b2)</code></p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc986_%E4%BA%A4%E9%9B%86.jpeg" alt="lc986_交集"></p><p>那么剩下的就是双指针问题了，当一个区间被作为交集使用过后，即，他是左边的区间时，指针移动</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] intervalIntersection(<span class="type">int</span>[][] firstList, <span class="type">int</span>[][] secondList) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstIdx</span> <span class="operator">=</span> <span class="number">0</span>, secondIdx = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (firstIdx &lt; firstList.length &amp;&amp; secondIdx &lt; secondList.length) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> firstList[firstIdx][<span class="number">0</span>], a2 = firstList[firstIdx][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> secondList[secondIdx][<span class="number">0</span>], b2 = secondList[secondIdx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (b1 &lt;= a2 &amp;&amp; b2 &gt;= a1) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> Math.max(a1, b1), c2 = Math.min(a2, b2);</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{c1, c2});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a2 &lt; b2) {</span><br><span class="line">                firstIdx++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                secondIdx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>总结</h1><p>对于区间调度问题，按照右端点排序的贪心思路解决。对于区间合并问题，按照左端点排序</p><p>按照左端点排序的目的是为了保证左端点的前后关系，这样我们就能保证一个区间的左端点一定不会大于其后面区间的左端点。这在处理一些需要关注<strong>区间的覆盖，或者合并等问题时会比较有用。</strong></p><p>按照右端点排序的目的则是为了保证右端点的前后关系，使得一个区间的右端点不会大于其后面区间的右端点。这在处理一些需要关注<strong>区间的交叉，或者选择不重叠区间</strong>的问题时会比较有用。</p><h1><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h1><p>这道题与其说是一道贪心题，它更像是一道按照规则的模拟题。贪心思想题现在了按照规则构造时候的模拟题</p><ol><li>先把数字转化成一个char[]</li></ol><p>我们对每一位进行贪心地修改：</p><p>由于我们想要数尽可能的大，所以我们要尽可能填充9，而填充9的位置就是第一个单调递减的位置：</p><p>12321 -&gt; 12999</p><p>3就是第一个需要变化的位置</p><p>但是会有一种情况：</p><p>1233321 -&gt; 那么这个时候我们就不能只简单的看n 和 n+1我们需要一个额外的变量来跟踪第一个max index：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[] nToChar = (n + <span class="string">""</span>).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>, idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nToChar.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (max &lt; nToChar[i]) {</span><br><span class="line">                max = nToChar[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nToChar[i] &gt; nToChar[i + <span class="number">1</span>]) {</span><br><span class="line">                nToChar[idx] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> idx + <span class="number">1</span>; j &lt; nToChar.length; j++) {</span><br><span class="line">                    nToChar[j] = <span class="string">'9'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(nToChar));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></h1><p>这是一道带有贪心思想的脑筋急转弯题，需要画图以及理解任务的调度：</p><p>贪心体现在：尽可能安排出现次数多的任务，然后将其他任务填充在次数多的任务的冷却期中。</p><p>假设我们有桶子：</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc621_%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0_1.png" alt="lc621_贪心构造_1"></p><p>我们需要执行4个任务，那么由于除了最后一个以外都有冷冻期，那么就会有：</p><p>(n + 1) * (m - 1) + 1</p><p>假设任务重复次数最多为max，若有tot个任务数量为 max 的任务：</p><blockquote><p>当任务总数不超过 (n+1)×(max⁡−1)+tot时，我们总能将其他任务插到空闲时间中去，不会引入额外的冻结时间（下左图）；而当任务数超过该值时，我们可以在将其横向添加每个 n+1 块的后面，同时不会引入额外的冻结时间（下右图）：</p><p>作者：宫水三叶<br>链接：<a href="https://leetcode.cn/problems/task-scheduler/description/">https://leetcode.cn/problems/task-scheduler/description/</a></p></blockquote><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc621_%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0_2.png" alt="lc621_贪心构造_2"></p><p>综上：</p><p>结果为<code> return Math.max(len, (n + 1) * (max - 1) + tot);</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tasks.length;</span><br><span class="line">        <span class="type">int</span>[] hm = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            hm[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">            max = Math.max(hm[i], max);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (hm[i] == max) tot++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(len, (n + <span class="number">1</span>) * (max - <span class="number">1</span>) + tot);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/video-stitching/">1024. 视频拼接</a></h1><p>类区间调度的贪心题：</p><blockquote><p><strong>区间问题肯定按照区间的起点或者终点进行排序</strong></p><p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/jian-shi-p-4302c/">labuladong-剪视频</a></p></blockquote><p>将 <code>clips</code> 按照起点升序排序，起点相同的按照终点降序排序</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc1024_%E6%8E%92%E5%BA%8F_1.jpeg" alt="lc1024_排序_1"></p><p>然后比较所有起点小于 <code>clips[0][1]</code> 的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频</p><p><img src="/posts/%E8%B4%AA%E5%BF%83/lc1024_%E6%8E%92%E5%BA%8F_2.gif" alt="lc1024_排序_2"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> time)</span> {</span><br><span class="line">        Arrays.sort(clips, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] clip1, <span class="type">int</span>[] clip2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (clip1[<span class="number">0</span>] == clip2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> clip2[<span class="number">1</span>] - clip1[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> clip1[<span class="number">0</span>] - clip2[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRight</span> <span class="operator">=</span> <span class="number">0</span>, rightMost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curRight) {</span><br><span class="line">            <span class="type">int</span>[] clip = clips[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                curRight = clip[<span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">if</span> (curRight &gt;= time) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// System.out.println(curRight + " " + rightMost);</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curRight) {</span><br><span class="line">                rightMost = Math.max(rightMost, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// System.out.println(rightMost);</span></span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (rightMost &gt;= time) <span class="keyword">return</span> res;</span><br><span class="line">            curRight = rightMost;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯之棋盘问题</title>
      <link href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h1><ol><li>构造树：</li></ol><p>一个 3 * 3 的棋盘，将搜索过程抽象为一棵树</p><p>二维矩阵中矩阵的<strong>高</strong>就是这棵树的<strong>高度</strong>，矩阵的<strong>宽</strong>就是树形结构中每一个节点的<strong>宽度</strong>。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong></p><ol start="2"><li>皇后的位置：<ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol></li></ol><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/51_NQueen_tree.jpeg" alt="51_NQueen_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span>[] chessRow : chessBoard) {</span><br><span class="line">          Arrays.fill(chessRow, <span class="string">'.'</span>);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      backtracking(chessBoard, curRow, n);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="keyword">if</span> (curRow == n) {</span><br><span class="line">          <span class="comment">// 到叶子结点，将此时的棋盘加入答案</span></span><br><span class="line">          res.add(array2List(chessBoard));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">curCol</span> <span class="operator">=</span> <span class="number">0</span>; curCol &lt; n; curCol++) {</span><br><span class="line">          <span class="keyword">if</span> (isValid(chessBoard, curRow, curCol)) {</span><br><span class="line">              chessBoard[curRow][curCol] = <span class="string">'Q'</span>;</span><br><span class="line">              backtracking(chessBoard, curRow + <span class="number">1</span>, n);</span><br><span class="line">              chessBoard[curRow][curCol] = <span class="string">'.'</span>;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> curCol)</span> {</span><br><span class="line">      <span class="comment">// 检查同一列是不是已经有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; curRow; r++) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][curCol] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 \ 是否有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol - <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; r--, c--) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 / 是否有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; chessBoard[<span class="number">0</span>].length; r--, c++) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span> {</span><br><span class="line">      List&lt;String&gt; transformedArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> chessBoard.length, c = chessBoard[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessBoard) {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">              sb.append(chars[j]);</span><br><span class="line">          }</span><br><span class="line">          transformedArray.add(sb.toString());</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> transformedArray;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h1><p>和N皇后不同的是，N皇后一旦确定某行中的位置，那么他就唯一确定了但是数独中数字会取决于之前的数字，会存在依赖关系，因此需要枚举每一个格子。</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/lc37_tree.png" alt="lc37_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">boardRow</span> <span class="operator">=</span> <span class="number">9</span>, boardCol = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        backtracking(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> r, <span class="type">int</span> c)</span> {</span><br><span class="line">        <span class="keyword">if</span> (c == boardCol) {</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == boardRow) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[r][c] != <span class="string">'.'</span>) {</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, r, c + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">'1'</span>; num &lt;= <span class="string">'9'</span>; num++) {</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, r, c, num)) <span class="keyword">continue</span>;</span><br><span class="line">            board[r][c] = num;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(board, r, c + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">char</span> num)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="comment">// 判断行是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][i] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 判断列是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][c] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 判断 3 x 3 方框是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[(r/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(c/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++碎碎念</title>
      <link href="/posts/C-%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/posts/C-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>本文档用来记录一些C++知识，从而更好地应对就业寒冬 (就比如 “XX已死”)</p><p>卷不死就往死里卷 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></div><h1>C++</h1><h2 id="Coding-Style">Coding Style</h2><p>对于类和结构，通常使用 CamelCase；对于函数和变量，通常使用 snake_case。全局常量和宏常常全部大写，并用下划线分隔。</p><h2 id="文件结构">文件结构</h2><ol><li><p>头文件区：<code>#include &lt;&gt;</code></p></li><li><p>命名空间：<code>using namespace std;</code></p><ol><li>保证不同命名空间中变量不冲突</li></ol></li><li><p>程序执行入口</p><ol><li><code>int main()</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Programming-Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯之切割问题</title>
      <link href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>综述</h1><h2 id="131-分割回文串"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><p>枚举切割的点来得到分割方案</p><p>只有树枝上的子串是回文串时才能继续往下走，最后如果能够走到空串节点，就说明整个 <code>s</code> 完成了切分，也就是得到了一个合法的答案。</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87_lc131_tree.jpg" alt="分割回文_lc131_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx &gt;= s.length()) {</span><br><span class="line">            <span class="comment">// base case，走到叶子节点</span></span><br><span class="line">            <span class="comment">// 即整个 s 被成功分割为若干个回文子串，记下答案</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> s.substring(startIdx, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(cur)) {</span><br><span class="line">                <span class="comment">// s[start..i] 是一个回文串，可以进行分割</span></span><br><span class="line">                <span class="comment">// 做选择，把 s[start..i] 放入路径列表中</span></span><br><span class="line">                path.add(cur);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>, e = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e) {</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(s) != str.charAt(e)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            s++;</span><br><span class="line">            e--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="93-复原-IP-地址"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p>两个难点：</p><ol><li>将问题转化为切割问题从而用回溯法来解决<ol><li>如何造树</li></ol></li><li>边界的处理<ol><li>base case</li><li>判断子字符串是否合法</li></ol></li></ol><p>对于第一个问题：</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/lc_93_%E5%A4%8D%E5%8E%9FIP_tres.png" alt="lc_93_复原IP_tres"></p><p>对于第二个问题:</p><ol><li>base case<ol><li>通过变量pointNum，记录添加逗点的数量。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointCount == <span class="number">3</span>) {  <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">  <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> (isValid(s, startIdx, s.length() - <span class="number">1</span>)) {</span><br><span class="line">        res.add(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>切割出来的子字符串是否合法<ol><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>综上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> {</span><br><span class="line">        backtracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIdx, <span class="type">int</span> pointCount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (pointCount == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIdx, s.length() - <span class="number">1</span>)) {</span><br><span class="line">                res.add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIdx, i)) {</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">"."</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointCount++;</span><br><span class="line">              <span class="comment">// 注意这里是 i + 2 由于加了一个 "."</span></span><br><span class="line">                backtracking(s, i + <span class="number">2</span>, pointCount);</span><br><span class="line">                pointCount--;</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/posts/%E5%9B%BE%E8%AE%BA/"/>
      <url>/posts/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://www.programmercarl.com/other/tulunshuoming.html">代码随想录-图论篇</a> 以及 <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/">labuladong - 图论</a><br>感谢支持！</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-rocket"></i><ul><li><a href="/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/" title="链式前向星-LinkedForwardStar">链式前向星-LinkedForwardStar</a></li><li><a href="/posts/Dijkstra/" title="Dijkstra">Dijkstra</a></li><li><a href="/posts/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/" title="拓扑序列">拓扑序列</a></li><li><a href="/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a></li><li><a href="/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树 - Minimum Spanning Tree - MST">最小生成树 - Minimum Spanning Tree - MST</a></li></ul></div><h1>基础</h1><p>图就是多叉树的延伸，</p><p>多叉树 &amp; 图：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图节点的逻辑结构 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1>建图 和 建表</h1><p><img src="/posts/%E5%9B%BE%E8%AE%BA/%E9%82%BB%E6%8E%A5%E8%A1%A8_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5_0.jpeg" alt="邻接表_邻接矩阵_0"></p><p><img src="/posts/%E5%9B%BE%E8%AE%BA/%E9%82%BB%E6%8E%A5%E8%A1%A8_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpeg" alt="邻接表_邻接矩阵"></p><p>邻接表：我把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</p><p>邻接矩阵：一个二维布尔数组，我们权且称为 <code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code> 的邻居，去扫一圈 <code>matrix[x][..]</code> 就行了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有一条指向 y 的边</span></span><br><span class="line"><span class="type">boolean</span>[][] matrix;</span><br></pre></td></tr></tbody></table></figure><p>建图建表的优劣：</p><p>邻接表：占用空间少，但是无法<strong>快速</strong>判断两个节点是否相邻</p><p>邻接矩阵：空间占用高，但是可以快速查找相邻节点</p><p>比如判断节点 <code>1</code> 是否和节点 <code>3</code> 相邻，我要去邻接表里 <code>1</code> 对应的邻居列表里查找 <code>3</code> 是否存在。但对于邻接矩阵就简单了，只要看看 <code>matrix[1][3]</code> 就知道了，效率高。</p><p>除链式前向星外：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">    graph.get(from).add(to);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>度</h1><h2 id="入度-和-出度">入度 和 出度</h2><p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为<strong>入度</strong>（indegree）和<strong>出度</strong>（outdegree）</p><p>上图中的3的入度为3出度为1</p><h1>加权</h1><p>邻接表：</p><p>存储不单单邻居节点还存储权重</p><p>邻接矩阵：</p><p><code>matrix[x][y]</code> 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点以及对应的权重</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻</span></span><br><span class="line"><span class="type">int</span>[][] matrix;</span><br></pre></td></tr></tbody></table></figure><h1>无向</h1><p>无向图 == 双向</p><p>邻接表：</p><p>在 <code>x</code> 的邻居列表里添加 <code>y</code>，同时在 <code>y</code> 的邻居列表里添加 <code>x</code></p><p>邻接矩阵：</p><p>把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 <code>true</code> ；</p><h1>遍历</h1><p>遍历（多叉）树结构时，我们有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) {</span><br><span class="line">        traverse(child);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于图可能包含环，所以为了避免无限遍历我们需要一个<code>visited</code>数组来表示已经遍历过：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) {</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，<code>visited</code>数组不需要撤销操作，这是因为我们需要始终记录已经遍历过的节点；而<code>onPath</code> 数组需要撤销操作从而保证遍历了每一个节点，但是注意的是回溯中撤销的是枝干，因此在for循环里面，但是这里的dfs关注的是节点，因此在for循环外面</p><p><img src="/posts/%E5%9B%BE%E8%AE%BA/onpath_viisted.gif" alt="onpath_viisted"></p><p>visited 中用灰色标记已经遍历过的节点，用onPath来表示正在遍历的节点</p><h1>Dijkstra</h1><a href="/posts/Dijkstra/" title="Dijkstra">Dijkstra</a><h1>例题</h1><h2 id="310-最小高度树"><a href="https://leetcode.cn/problems/minimum-height-trees/description/#">310.最小高度树</a></h2><p>这道题比较有意思的点在于其涉及到一个技巧：</p><p>从叶子结点BFS，越往深处，节点连接的点越多，最里面的点即为最小高度</p><p>举一反三：</p><blockquote><p>这种套路题，找最近叶子节点就从根开始 BFS，找根节点的话就从叶子开始 BFS，记住这种处理方式就好了，一般不会有什么变体。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] outDegree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        outDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">        graph.get(from).add(to);</span><br><span class="line">        outDegree[from]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从叶子结点BFS，越往深处，节点连接的点越多，最里面的点即为最小高度</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        buildGraph(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            add(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">            add(edges[i][<span class="number">1</span>], edges[i][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子结点即为出度为1的点, 因为是无向图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; outDegree.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (outDegree[i] == <span class="number">1</span>) dq.addLast(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                res.add(cur);</span><br><span class="line">                List&lt;Integer&gt; neighbors = graph.get(cur);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> neighbor : neighbors) {</span><br><span class="line">                    outDegree[neighbor]--;</span><br><span class="line">                    <span class="keyword">if</span> (outDegree[neighbor] == <span class="number">1</span>) dq.addLast(neighbor);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建表：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">    graph.get(from).add(to);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="417-太平洋大西洋水流问题"><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/">417.太平洋大西洋水流问题</a></h2><p>从边出发，水往高处流</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="type">int</span>[][] graph;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] heights)</span> {</span><br><span class="line">        graph = heights;</span><br><span class="line">        m = heights.length;</span><br><span class="line">        n = heights[<span class="number">0</span>].length;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dqPacific = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dqAtlantic = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[][] flushSucceedPacific = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">boolean</span>[][] flushSucceedAtlantic = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                    dqPacific.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, j});</span><br><span class="line">                    flushSucceedPacific[i][j] = <span class="literal">true</span>;    </span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span> || j == n - <span class="number">1</span>) {</span><br><span class="line">                    dqAtlantic.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {i, j});</span><br><span class="line">                    flushSucceedAtlantic[i][j] = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        bfs(dqPacific, flushSucceedPacific);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        bfs(dqAtlantic, flushSucceedAtlantic);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (flushSucceedPacific[i][j] &amp;&amp; flushSucceedAtlantic[i][j]) {</span><br><span class="line">                    List&lt;Integer&gt; dir = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    dir.add(i);</span><br><span class="line">                    dir.add(j);</span><br><span class="line">                    ret.add(dir);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Deque&lt;<span class="type">int</span>[]&gt; dq, <span class="type">boolean</span>[][] res)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="type">int</span>[] cur = dq.pollFirst();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>], y = cur[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">curHeight</span> <span class="operator">=</span> graph[x][y];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dx[dir], newY = y + dy[dir];</span><br><span class="line">                    <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visited[newX][newY]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newHeight</span> <span class="operator">=</span> graph[newX][newY];</span><br><span class="line">                    <span class="keyword">if</span> (curHeight &gt; newHeight) <span class="keyword">continue</span>;</span><br><span class="line">                    dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[] {newX, newY});</span><br><span class="line">                    visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">                    res[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1197-进击的骑士"><a href="https://leetcode.cn/problems/minimum-knight-moves/description/">1197.进击的骑士</a></h2><p>这是一道数学取巧题：</p><p>由于范围：<br><code>0 &lt;= |x| + |y| &lt;= 300</code></p><p>因此我们得知：</p><p><img src="/posts/%E5%9B%BE%E8%AE%BA/1197_%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B41.png" alt="1197_数据范围1"></p><p>转换一下使得其适合从0开始的索引：<br><img src="/posts/%E5%9B%BE%E8%AE%BA/1197_%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B42.png" alt="1197_数据范围2"></p><p>同时，为了避免目标(x,y)刚好在边界，我们往外再扩大成最右上角为 (666,666) 这是由于 我们 要的是 <code>移动次数</code> 所以不需要想坐标转换</p><p>直接贴一个别人的做法：</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-knight-moves/solutions/388183/1197-jin-ji-de-qi-shi-by-klb/">K.L.B 解法</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">        <span class="comment">// 八个方向</span></span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]{</span><br><span class="line">            {<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">2</span>, <span class="number">1</span>}, {<span class="number">2</span>, -<span class="number">1</span>}, {<span class="number">1</span>, -<span class="number">2</span>}, {-<span class="number">1</span>, -<span class="number">2</span>}, {-<span class="number">2</span>, -<span class="number">1</span>}, {-<span class="number">2</span>, <span class="number">1</span>}, {-<span class="number">1</span>, <span class="number">2</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minKnightMoves</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> getMhdDist(<span class="number">0</span>, <span class="number">0</span>, x, y);   <span class="comment">// (0,0)到(x,y)的距离（横坐标之差加纵坐标之差）</span></span><br><span class="line">        <span class="comment">// 目标最远不超过 |x| + |y| &lt;= 300</span></span><br><span class="line">        <span class="comment">// 666 表示把 [-333, 333] 映射为 [0, 666]</span></span><br><span class="line">        <span class="type">boolean</span>[][] mark = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">666</span>][<span class="number">666</span>];   <span class="comment">// 用于标记已走过的位置</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// 起点，已走步数为 0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        mark[<span class="number">333</span>][<span class="number">333</span>] = <span class="literal">true</span>;  <span class="comment">// 映射后的 (0,0)坐标</span></span><br><span class="line">        queue.add(curNode);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            curNode = queue.remove();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> curNode.x;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curY</span> <span class="operator">=</span> curNode.y;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curDist</span> <span class="operator">=</span> curNode.dist; <span class="comment">// 从 (0,0) 到 (curX,curY) 的已走步数</span></span><br><span class="line">            <span class="keyword">if</span> (curX == x &amp;&amp; curY == y) {</span><br><span class="line">                <span class="comment">// 当前点已在终点，返回已走步数</span></span><br><span class="line">                <span class="keyword">return</span> curDist;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">mhdist</span> <span class="operator">=</span> getMhdDist(curX, curY, x, y);  <span class="comment">// 剩余距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) {    <span class="comment">// 往八个方向走</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> curX + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> curY + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextDist</span> <span class="operator">=</span> curDist + <span class="number">1</span>; <span class="comment">// 新的步数等于已走步数加一</span></span><br><span class="line">                <span class="keyword">if</span> (mark[newX + <span class="number">333</span>][newY + <span class="number">333</span>]) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 下一步走的方向一定是往目的地靠近</span></span><br><span class="line">                <span class="comment">// 即 getMhdDist(newX, newY, x, y) &lt; (curX, curY, x, y)</span></span><br><span class="line">                <span class="comment">// 而不是八个方向都走一遍</span></span><br><span class="line">                <span class="keyword">if</span> (mhdist &gt; getMhdDist(newX, newY, x, y) || abs &lt; <span class="number">4</span>) {</span><br><span class="line">                    newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(newX, newY, nextDist);</span><br><span class="line">                    queue.add(newNode);</span><br><span class="line">                    mark[newX + <span class="number">333</span>][newY + <span class="number">333</span>] = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMhdDist</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.abs(i - x) + Math.abs(j - y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> dist;    <span class="comment">// (0,0)走到(x,y)的最少移动次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dist)</span> {</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.dist = dist;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">作者：K.L.B</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/minimum-knight-moves/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="1293-网格中的最短路径"><a href="https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></h2><p>这道题复杂在需要开一个额外的维度来储存当前剩余的可以清空障碍的操作数量。不过剩下的就都是BFS了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]{-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> {</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">0</span>, k});</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="comment">// 这里的边界</span></span><br><span class="line">        <span class="keyword">if</span> ((m == <span class="number">1</span>) &amp;&amp; (n == <span class="number">1</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        k = Math.min(k, m + n - <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 额外记录k的剩余情况的维度</span></span><br><span class="line">        <span class="type">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n][k + <span class="number">1</span>];</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>][k] = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= m + n - <span class="number">3</span>){</span><br><span class="line">            <span class="keyword">return</span> m + n - <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span>[] cur = dq.pollFirst();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>], y = cur[<span class="number">1</span>], kleft = cur[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) {</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY][kleft]) {</span><br><span class="line">                        <span class="keyword">if</span> (grid[newX][newY] == <span class="number">1</span> &amp;&amp; kleft &gt; <span class="number">0</span>) {</span><br><span class="line">                            <span class="comment">// obstacle</span></span><br><span class="line">                            visited[newX][newY][kleft - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                            dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{newX, newY, kleft - <span class="number">1</span>});</span><br><span class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (grid[newX][newY] == <span class="number">0</span>){</span><br><span class="line">                            visited[newX][newY][kleft] = <span class="literal">true</span>;</span><br><span class="line">                            dq.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{newX, newY, kleft});</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑序列</title>
      <link href="/posts/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
      <url>/posts/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://raelum.blog.csdn.net/article/details/129650604?ydreferer=aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS8%3D">还不会拓扑排序？看这一篇就够了</a> 以及 <a href="https://www.acwing.com/video/280/">acwing 算法基础课 848</a></p></div> <h1>拓扑序列</h1><ol><li>一定得是有向图才（可能）会有拓扑序列</li><li>必须是由起点指向终点不能从后指向前</li><li>有向无环图一定存在拓扑序列<ol><li>DAG也被称为拓扑图</li></ol></li><li>度数：<ol><li>入度和出度<ol><li>入度：有多少条边指向自己</li><li>出度：有多少条边出去</li><li><img src="/posts/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6.png" alt="入度和出度"></li></ol></li></ol></li></ol><h2 id="如何求拓扑序列">如何求拓扑序列</h2><ol><li>任何入度为0的都可以作为起点（当前最前面的位置）</li><li>BFS</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队 queue.add(入度为0的点)</span></span><br><span class="line">Queue.add(所有入度为<span class="number">0</span>的点)</span><br><span class="line"><span class="keyword">while</span> !queue.isEmpty() {</span><br><span class="line">  <span class="comment">// 拿出队头 t</span></span><br><span class="line">  <span class="comment">// 枚举对头 t 的所有出边 t -&gt; j</span></span><br><span class="line">  <span class="comment">// 删掉 t -&gt; j, j的入度 减1</span></span><br><span class="line">  <span class="comment">// if d[j] == 0; 此时j为新的入度为0的点，j 入队</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果图中有环，那么一定会有点无法入队；反之，所有点都会在queue中</p><h2 id="例子">例子</h2><p>拓扑排序其是一种有向无环图 (DAG) 的顶点排序方法，它将一个有向无环图的所有顶点排成一个线性序列，使得<strong>图中任意一条有向边的起点排在终点的前面</strong></p><table><thead><tr><th>课程编号</th><th>课程名称</th><th>先修课程</th></tr></thead><tbody><tr><td>1</td><td>高等数学</td><td>−</td></tr><tr><td>2</td><td>程序设计基础</td><td>−</td></tr><tr><td>3</td><td>离散数学</td><td>1, 2</td></tr><tr><td>4</td><td>数据结构</td><td>2, 3</td></tr><tr><td>5</td><td>高级语言程序设计</td><td>2</td></tr><tr><td>6</td><td>编译方法</td><td>4,5</td></tr><tr><td>7</td><td>操作系统</td><td>4,9</td></tr><tr><td>8</td><td>普通物理</td><td>1</td></tr><tr><td>9</td><td>计算机原理</td><td>8</td></tr></tbody></table><h1><a href="https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/">2115. 从给定原材料中找到所有可以做出的菜</a></h1><p>这里使用了map建表</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;String, LinkedList&lt;String&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; inDegree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAllRecipes</span><span class="params">(String[] recipes, List&lt;List&lt;String&gt;&gt; ingredients, String[] supplies)</span> {</span><br><span class="line">        <span class="comment">// 本质上是一个拓扑序问题，因为你要有原材料才能做东西</span></span><br><span class="line">        <span class="comment">// 建一条有向边从材料到菜</span></span><br><span class="line">        n = recipes.length;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">recipe</span> <span class="operator">=</span> recipes[i];</span><br><span class="line">            <span class="keyword">for</span> (String ingredient : ingredients.get(i)) {</span><br><span class="line">                add(ingredient, recipe);</span><br><span class="line">                <span class="keyword">if</span> (!inDegree.containsKey(ingredient)) {</span><br><span class="line">                    inDegree.put(ingredient, <span class="number">0</span>);</span><br><span class="line">                }</span><br><span class="line">                updateInDegree(recipe);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(recipe)) {</span><br><span class="line">                graph.put(recipe, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// System.out.println(graph);</span></span><br><span class="line">        <span class="comment">// System.out.println(inDegree);</span></span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String k : supplies) {</span><br><span class="line">            <span class="keyword">if</span> (!inDegree.containsKey(k)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(k) == <span class="number">0</span>) {</span><br><span class="line">                dq.addLast(k);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// System.out.println(dq);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">curRecipe</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                <span class="comment">// System.out.println(curRecipe);</span></span><br><span class="line">                List&lt;String&gt; neighbors = adj(curRecipe);</span><br><span class="line">                <span class="keyword">for</span> (String neighbor : neighbors) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">curIndegree</span> <span class="operator">=</span> inDegree.get(neighbor) - <span class="number">1</span>;</span><br><span class="line">                    inDegree.put(neighbor, curIndegree);</span><br><span class="line">                    <span class="keyword">if</span> (curIndegree == <span class="number">0</span>) {</span><br><span class="line">                        dq.addLast(neighbor);</span><br><span class="line">                        res.add(neighbor);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String from, String to)</span> {</span><br><span class="line">        LinkedList&lt;String&gt; cur = graph.getOrDefault(from, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        cur.addLast(to);</span><br><span class="line">        graph.put(from, cur);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInDegree</span><span class="params">(String to)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> inDegree.getOrDefault(to, <span class="number">0</span>);</span><br><span class="line">        inDegree.put(to, cur + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">adj</span><span class="params">(String cur)</span> {</span><br><span class="line">        <span class="keyword">return</span> graph.get(cur);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] inDegree;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) {</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) dq.addLast(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            path.add(cur);</span><br><span class="line">            count++;</span><br><span class="line">            List&lt;Integer&gt; neighbors = adj(graph, cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : neighbors) {</span><br><span class="line">                inDegree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[next] == <span class="number">0</span>) dq.addLast(next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) {</span><br><span class="line">            <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                res[i] = path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prerequisites.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> prerequisites[i][<span class="number">1</span>], to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            add(graph, from, to);</span><br><span class="line">            inDegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        graph.get(a).add(b);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">return</span> graph.get(cur);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯之集合划分问题</title>
      <link href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h1>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯之排列-组合-子集问题</title>
      <link href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>综述</h1><p>这类问题一般就是说 从 <strong>序列</strong> <code>nums</code> 中 <strong>以给定规则取若干元素</strong> 有如下几种变体：</p><ol><li>元素<strong>无重不可复选</strong>，即 <code>nums</code> 中的元素都是唯一的，每个元素最多只能被使用一次，这也是<strong>最基本</strong>的形式<ol><li>以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 7 的组合应该只有 <code>[7]</code>。</li></ol></li><li><strong>元素可重不可复选</strong>，即 <code>nums</code> 中的元素可以<strong>存在重复</strong>，每个元素最多只能被使用一次。<ol><li>以组合为例，如果输入 <code>nums = [2,5,2,1,2]</code>，和为 7 的组合应该有两种 <code>[2,2,2,1]</code> 和 <code>[5,2]</code>。</li></ol></li><li><strong>元素无重可复选</strong>，即 <code>nums</code> 中的<strong>元素都是唯一</strong>的，每个元素可以被<strong>使用若干次</strong>。<ol><li>以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 7 的组合应该有两种 <code>[2,2,3]</code> 和 <code>[7]</code>。</li></ol></li></ol><p>PS: 也可以说有第四种形式，即<strong>元素可重可复选</strong>。但既然元素可复选，那又<strong>何必存在重复元素</strong>呢？元素去重之后就等同于形式三，所以这种情况不用考虑。</p><p>排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。但无论形式怎么变化，其本质就是<strong>穷举所有解</strong>，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽。</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E5%9B%9E%E6%BA%AF%E7%BB%84%E5%90%88_%E5%AD%90%E9%9B%86%E6%A0%91.jpeg" alt="回溯组合_子集树"></p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%8E%92%E5%88%97%E6%A0%91.jpeg" alt="回溯排列树"></p><h1>元素无重不可复选</h1><h2 id="78-子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc78%E5%AD%90%E9%9B%86.jpeg" alt="lc78子集"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backtracking(nums, startIdx);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">      <span class="comment">// 直接将路径加入答案中</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            path.add(cur);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="77-组合"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h2><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc77_%E7%BB%84%E5%90%88_%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95.jpg" alt="lc77_组合_代码随想录"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        backtracking(idx, paths, path, n, k);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> idx, List&lt;List&lt;Integer&gt;&gt; paths, List&lt;Integer&gt; path, <span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt;= n; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(i + <span class="number">1</span>, paths, path, n, k);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="剪枝-（只需要当元素不够时剪掉即可）-n-k-path-size-1">剪枝 （只需要当元素不够时剪掉即可）-&gt; n - (k - path.size()) + 1</h3><p>当所需要的元素 &gt; 可选选项可以提供的元素时，我们就无需再往后面进行计算了，直接剪掉</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E7%BB%84%E5%90%88%E2%80%94%E5%89%AA%E6%9E%9D.png" alt="组合—剪枝"></p><p>优化过程如下：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;= 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;= n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        backtracking(idx, paths, path, n, k);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> idx, List&lt;List&lt;Integer&gt;&gt; paths, List&lt;Integer&gt; path, <span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(i + <span class="number">1</span>, paths, path, n, k);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="46-全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97-%E8%B7%AF%E5%BE%84.jpeg" alt="全排列-路径"></p><p><strong><code>[2]</code> 就是「路径」，记录你已经做过的选择；</strong></p><p><strong><code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；</strong></p><p><strong>「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候</strong>。</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97-%E5%81%9A%E9%80%89%E6%8B%A9.jpeg" alt="全排列-做选择"></p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc46_%E5%85%A8%E6%8E%92%E5%88%97.jpeg" alt="lc46_全排列"></p><p>全排列和上边的组合和子集不同的是，我们需要左边的元素，因此不能用<code>startIdx</code>来避免掉重复元素，并且我们<strong>不能</strong>重复选择一个元素，那么我们就需要一个额外的数据结构来跟踪哪些值是被用过了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            visited.add(nums[i]);</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            visited.remove(nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意hashset在这里是有局限性的因为这道题的元素不重复因此可以用hashset，但应该用<code>boolean visited[]</code>更通用一些：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (used[i]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            track.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="总结">总结</h2><h3 id="子集-还是-组合：">子集 还是 组合：</h3><p>要求大小为 2 的所有组合，就是所有大小为 2 的子集</p><p>所以 <strong>组合和子集是一样的：大小为 <code>k</code> 的组合就是大小为 <code>k</code> 的子集</strong>。</p><p>比如：</p><p>LC77：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>就是：</p><p>给你输入一个数组 <code>nums = [1,2..,n]</code> 和一个正整数 <code>k</code>，请你生成所有大小为 <code>k</code> 的子集。</p><p>也就是LC78：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>这个组合和子集的唯一区别就是我们现在只需要输出第k层的记过，而不是在前序位置每条路径都加入</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/LC77_%E7%BB%84%E5%90%88_labuladong.jpeg" alt="LC77_组合_labuladong"></p><h3 id="全排列的index：">全排列的index：</h3><p>排列问题本身就是让你穷举元素的位置，<code>nums[i]</code> 之后也可以出现 <code>nums[i]</code> 左边的元素，所以之前的那一套使用 <code>startIndex</code> 的就不行了，需要额外使用 <code>used</code> 数组或者<code>hashSet</code>来标记哪些元素还可以被选择。</p><p>如果题目不让你算全排列，而是让你算元素个数为 <code>k</code> 的排列，怎么算？也很简单，改下 <code>backtrack</code> 函数的 base case，仅收集第 <code>k</code> 层的节点值即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯算法核心函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="comment">// base case，到达第 k 层，收集节点的值</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == k) {</span><br><span class="line">        <span class="comment">// 第 k 层节点的值就是大小为 k 的排列</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        backtrack(nums, k);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>元素可重不可复选</h1><h2 id="90-子集-II"><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h2><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc90_subset2_tree.jpeg" alt="lc90_subset2_tree"></p><p>如图中所示，我们可以看到的是，同一层的相邻元素如果相同，我们就不需要再处理。</p><p>为了保证相邻元素是相同的我们就需要用一个sort</p><p>综上我们有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">      <span class="comment">// 排序来保证相邻元素一定是相同的（如果有的话）</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">// 注意这里的剪枝逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIdx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="40-组合总和-II"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>子集问题就是组合的一种问题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curSum == target) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行额外的剪枝，否则会超时</span></span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            curSum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            curSum -= candidates[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="47-全排列-II"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2><ol><li>用used数组来跟踪哪些数在**递归（向下生长时）**被用过，从而避免重复</li><li><code>i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]</code><ol><li>主要是用来判断当前的数和之前是否相同，如果相同且之前在<strong>同一层</strong>时候处理过，那么我们不需要再处理一遍，跳过即可</li><li>其实核心就是 <strong>保证相同元素在排列中的相对位置保持不变</strong>。</li><li>效果： <strong>当出现重复元素时，比如输入 <code>nums = [1,2,2',2'']</code>，<code>2'</code> 只有在 <code>2</code> 已经被使用的情况下才会被选择，同理，<code>2''</code> 只有在 <code>2'</code> 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定</strong>。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.length == path.size()) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="number">1</span>]) {</span><br><span class="line">                <span class="comment">// 这里的 nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]</span></span><br><span class="line">                <span class="comment">// 主要是为了说明现在出现了一个新的和之前一样的数，那么由于之前已经计算过，现在已经不需要重复算了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>元素无重可复选</h1><h2 id="39-组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p>对于之前的解法我们是 <code>startIdx</code> 每一次传入<code>i + 1</code> 那么下一层回溯树就是从 <code>i + 1</code> 开始，从而保证当前元素不会被重复使用：</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc_%E5%AD%90%E9%9B%86%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D.jpeg" alt="lc_子集不可重复"></p><p>对于本题来说，其实就是修改了<code>startIdx</code> 之前是 <code>i + 1</code> 现在是 <code>i</code></p><p>相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用：</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/lc39_tree.jpeg" alt="lc39_tree"></p><p>⚠️ 需要注意的是，这样会导致树无限生长，因此我们还需要额外的base case 来结束递归: <code>if (curSum &gt; target) return;</code> 即路径和大于 <code>target</code> 时就没必要再遍历下去了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curSum == target) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length; i++) {</span><br><span class="line">            curSum += candidates[i];</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            backtracking(candidates, target, i);</span><br><span class="line">            curSum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="排列">排列</h2><p>力扣上没有类似的题目，我们不妨先想一下，<code>nums</code> 数组中的元素无重复且可复选的情况下，会有哪些排列？</p><p>比如输入 <code>nums = [1,2,3]</code>，那么这种条件下的全排列共有 3^3 = 27 种：</p><p>标准的全排列算法利用 <code>used</code> 数组进行剪枝，避免重复使用同一个元素。如果允许重复使用元素的话，直接放飞自我，<strong>去除所有 <code>used</code> 数组的剪枝逻辑</strong>就行了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteRepeat</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法核心函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// base case，到达叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) {</span><br><span class="line">            <span class="comment">// 收集叶子节点上的值</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            <span class="comment">// 进入下一层回溯树</span></span><br><span class="line">            backtrack(nums);</span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1>总结</h1><p>有很多的共性，其实树都是差不多的只是多了一些剪枝操作以及base case略有不同</p><h2 id="元素无重不可复选">元素无重不可复选</h2><p>即 <code>nums</code> 中的元素都是唯一的，每个元素最多只能被使用一次</p><p>对于组合或者子集问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> {</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于排列问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="元素可重不可复选">元素可重不可复选</h2><p>即 <code>nums</code> 中的元素可以存在重复，每个元素最多只能被使用一次，其<strong>关键在于排序和剪枝</strong>，<code>backtrack</code> 核心代码如下：</p><p>对于组合或者子集问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> {</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 剪枝逻辑，跳过值相同的相邻树枝</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于排列问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="元素无重可复选"><strong>元素无重可复选</strong></h2><p>即 <code>nums</code> 中的元素都是唯一的，每个元素可以被使用若干次，只要<strong>删掉去重逻辑即可</strong>，<code>backtrack</code> 核心代码如下：</p><p>对于组合或者子集问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> {</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于排列问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>其他例题</h1><h2 id="组合">组合</h2><h3 id="216-组合总和-III"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h3><p>和77题几乎一模一样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(path, paths, k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; paths, <span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="keyword">if</span> (curSum == n) {</span><br><span class="line">                paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            curSum += i;</span><br><span class="line">            backTracking(path, paths, k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            curSum -= i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="剪枝">剪枝</h4><p>这道题剪枝有两个： 剩余元素的剪枝 + 求和的剪枝</p><p>剩余元素的剪枝:</p><p>即，可选列表中的元素 &lt; 要用的元素</p><p>求和的剪枝：</p><p>即，当前和已经大于了题目要求的和</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C3-%E5%89%AA%E6%9E%9D.png" alt="组合总和3-剪枝"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(path, paths, k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; paths, <span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="keyword">if</span> (curSum == n) {</span><br><span class="line">                paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            curSum += i;</span><br><span class="line">            <span class="keyword">if</span> (curSum &gt; n) {</span><br><span class="line">                curSum -= i;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            backTracking(path, paths, k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            curSum -= i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="17-电话号码的字母组合"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>组合的应用题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">            phoneMap.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            phoneMap.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">            List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            backtracking(digits, cur, res, idx);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits, StringBuilder cur, List&lt;String&gt; res, <span class="type">int</span> idx)</span> {</span><br><span class="line">            <span class="keyword">if</span> (idx &gt; digits.length() - <span class="number">1</span>) {</span><br><span class="line">                res.add(cur.toString());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(idx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">digit2Chars</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digit2Chars.length(); i++) {</span><br><span class="line">                <span class="type">char</span> <span class="variable">target</span> <span class="operator">=</span> digit2Chars.charAt(i);</span><br><span class="line">                cur.append(target);</span><br><span class="line">                backtracking(digits, cur, res, idx + <span class="number">1</span>);</span><br><span class="line">                cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="子集">子集</h2><h3 id="491-递增子序列"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h3><p>首先 本题在寻找 递增<strong>子序列</strong> 因此本题相当于寻找一种特殊的<strong>子集</strong>，特殊的地方在于 <strong>子集中的元素是递增的</strong></p><p>但是相较于子集问题（特指 90.子集2）本题特殊点在于我们不能再通过排序来过滤掉重复元素，因为这会破坏数组原本的顺序。</p><p>因此我们需要一个 <strong>hashset</strong> 来帮助我们寻找哪些元素在<strong>本层</strong>中用过，注意这里只需要看本层：</p><p><img src="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/491_%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97_tree.png" alt="491_递增子序列_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; used = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!path.isEmpty() &amp;&amp; path.getLast() &gt; nums[i]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (used.contains(nums[i])) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            used.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="为什么回溯前-used-add-nums-i-回溯后没有撤销？">为什么回溯前 <code>used.add(nums[i]);</code> 回溯后没有撤销？</h4><p>因为 <code>used</code> 是记录<strong>本层</strong>元素是否重复使用，新的一层used都会<strong>重新定义（清空）</strong>，所以要知道used只负责本层！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树之公共祖先</title>
      <link href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h1>二叉树之（最近）公共祖先</h1><h2 id="思路：">思路：</h2><p>考虑问题一个简单的问题：如何寻找一个或多个元素:<br>Eg: 寻找值为 <code>val1</code> <strong>或</strong> <code>val2</code> 的节点</p><p>非常简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> {</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 前序位置，看看 root 是不是目标值</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/lc236_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png" alt="LC236公共祖先"></p><p>那么对于寻找LCA来说，其实就是找 <strong>在一个子树下面是否能够同时找到p和q</strong>，寻找最近的公共节点就是寻找最深的公共节点，因此要选择<strong>后序遍历</strong></p><p>那么我们就会得出：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="comment">// 通过这个function 来找到子树里是否含有 p 和 q：</span></span><br><span class="line">    <span class="keyword">return</span> findTargeValues(root, p, q);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findTargeValues</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历位置，解决情况二：一旦发现有值等于target值，那么它本身就作为最近的祖先；</span></span><br><span class="line">    <span class="comment">// 因为题目说了 p 和 q 一定存在于二叉树中(这点很重要），</span></span><br><span class="line">    <span class="comment">// 所以即便我们遇到 q 就直接返回，根本没遍历到 p，也依然可以断定 p 在 q 底下，q 就是 LCA 节点。</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftValue</span> <span class="operator">=</span> findTargeValues(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightValue</span> <span class="operator">=</span> findTargeValues(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历位置，如果leftValue != null 证明左子树中含有target值，rightValue同理</span></span><br><span class="line">    <span class="comment">// 若同时满足，那么当前root就为最近的公共祖先。</span></span><br><span class="line">    <span class="keyword">if</span> (leftValue != <span class="literal">null</span> &amp;&amp; rightValue != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不是null的那个或者全是null的，不是null的优先返回。</span></span><br><span class="line">    <span class="keyword">return</span> leftValue == <span class="literal">null</span> ? rightValue : leftValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E5%9B%9E%E6%BA%AF.png" alt="公共祖先的回溯"></p><p>注意</p><p><code>leftValue == null ? rightValue : leftValue</code></p><p>就是</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) { <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) { <span class="comment">// 若找到一个节点</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) { <span class="comment">// 若找到一个节点</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}<span class="keyword">else</span> { <span class="comment">// 若找到两个节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1676-二叉树的最近公共祖先-IV"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/">1676. 二叉树的最近公共祖先 IV</a></h2><p>本题  <strong>不再是p，q，而是一组node</strong></p><p>只需要稍微修改一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode[] nodes)</span> {</span><br><span class="line">    Set&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TreeNode node : nodes) {</span><br><span class="line">        hs.add(node.val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> findTargetsFromNodes(root, hs);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findTargetsFromNodes</span><span class="params">(TreeNode root, Set&lt;Integer&gt; nodes)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依旧是找当前 root 是否本身即为最近公共祖先， 但是为了快速查找且题目要求node值都不相同，</span></span><br><span class="line">    <span class="comment">// 用 hashset来快速找值</span></span><br><span class="line">    <span class="keyword">if</span> (nodes.contains(root.val)) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftValue</span> <span class="operator">=</span> findTargetsFromNodes(root.left, nodes);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightValue</span> <span class="operator">=</span> findTargetsFromNodes(root.right, nodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftValue != <span class="literal">null</span> &amp;&amp; rightValue != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftValue != <span class="literal">null</span> ? leftValue : rightValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1644-二叉树的最近公共祖先-II"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. 二叉树的最近公共祖先 II</a></h2><p>之前的题目都说target节点都在树里，但是本题 <strong>不保证树里一定有p 和 q</strong></p><p>那么，对于上边两道题在前序遍历位置时发现当前root节点和target值相等直接返回就不能用了，<strong>因为不能保证是不是另一个也存在</strong>，我们需要知道树的<strong>所有信息</strong>才行，也就是要在<strong>后序遍历</strong>的位置，即：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isPExist</span> <span class="operator">=</span> <span class="literal">false</span>, isQExist = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ret</span> <span class="operator">=</span> findTargetValues(root, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!isQExist || !isPExist) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findTargetValues</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftValue</span> <span class="operator">=</span> findTargetValues(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightValue</span> <span class="operator">=</span> findTargetValues(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftValue != <span class="literal">null</span> &amp;&amp; rightValue != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 解决情况1，自身节点不是LCA</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val) {</span><br><span class="line">        <span class="comment">// 解决情况2，自身节点是LCA：</span></span><br><span class="line">        isPExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val == q.val) {</span><br><span class="line">        isQExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> leftValue == <span class="literal">null</span> ? rightValue : leftValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="235-二叉搜索树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h2><p>本题最重要的是利用BST的性质</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/BST_%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png" alt="BST_公共祖先"></p><ol><li>当根节点值小于p和q 即 小于 p，q的最小值<ol><li>说明要的公共祖先在右边的树里</li></ol></li><li>当根节点值大于p和q 即 大于 p，q的最大值<ol><li>说明要的公共祖先在左边的树里</li></ol></li><li>当根节点介于中间时则一定为最近的公共祖先<ol><li>为什么最近？<ol><li>因为如果还要进行下去，要么往左走要么往右走总会丢失一个</li><li>按图中的例子，如果5下面还有更近的祖先，那么假设5往左走，那么会丢失q，同理，向右走则会丢失p</li></ol></li></ol></li></ol><p><strong>结论: <code>Math.min(q.val, p.val) &lt;= root.val &lt;= Math.max(q.val, p.val)</code>那么此时的root即为最近的公共祖先</strong></p><p>pseudocode:</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/BST_%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88_%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt="BST_公共祖先_伪代码"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> Math.min(p.val, q.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> Math.max(p.val, q.val);</span><br><span class="line">    <span class="keyword">return</span> findTarget(root, val1, val2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val1) {</span><br><span class="line">        <span class="comment">// 值太小了，应该去右边找</span></span><br><span class="line">        <span class="keyword">return</span> findTarget(root.right, val1, val2);</span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val2) {</span><br><span class="line">        <span class="comment">// 值太大了， 应该去左边找</span></span><br><span class="line">       <span class="keyword">return</span> findTarget(root.left, val1, val2);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// root.val &gt;= val1 root.val &lt;= val2 此时就是一个合法的公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1650-二叉树的最近公共祖先-III"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/">1650. 二叉树的最近公共祖先 III</a></h2><p>本题包含了对父节点的引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题用的是链表合并的思路：</p><p>即让两个指针p1 指向A的指针，p2指向B的指针，<strong>能够同时到达相交节点 <code>c1</code></strong></p><blockquote><p>用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p></blockquote><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6.png" alt="链表合并"></p><p>稍微替换一下，借用parent:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pPointer</span> <span class="operator">=</span> p, qPointer = q;</span><br><span class="line">    <span class="keyword">while</span> (pPointer != qPointer) {</span><br><span class="line">        <span class="keyword">if</span> (pPointer == <span class="literal">null</span>) pPointer = q;</span><br><span class="line">        <span class="keyword">else</span> pPointer = pPointer.parent;</span><br><span class="line">        <span class="keyword">if</span> (qPointer == <span class="literal">null</span>) qPointer = p;</span><br><span class="line">        <span class="keyword">else</span> qPointer = qPointer.parent;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pPointer;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>二叉搜索树-BST</h1><h2 id="基本知识以及操作：">基本知识以及操作：</h2><blockquote><ol><li>提到 BST 就要想到中序遍历：<ol><li>BST的<strong>中序</strong>遍历是<strong>有序的</strong></li></ol></li><li>性质：<ol><li>左子树所有的值都**(严格)小于**根节点</li><li>右子树所有的值都**(严格)大于**根节点</li></ol></li><li>几乎完美的数据结构，复杂度为树高</li><li>最左边的叶子结点是最小值，最右边的叶子结点是最大值</li></ol></blockquote><p>那么对于一个数据结构，无非做的事情就是增删查改。</p><p>那么就是分成两步：1. 找到要操作的位置 （其实就是<strong>查</strong>）2. 操作</p><p>要找到位置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">if</span> (root.val == val) {</span><br><span class="line">      <span class="comment">// 找到节点，返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) {</span><br><span class="line">      <span class="comment">// 利用BST的性质，此时说明需要继续去右边找：</span></span><br><span class="line">      <span class="keyword">return</span> find(root.right, val);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) {</span><br><span class="line">      <span class="comment">// 利用BST的性质，此时说明需要继续去左边找：</span></span><br><span class="line">      <span class="keyword">return</span> = find(root.left, val);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 还有一种补充的写法。不过干的事情其实是一样的，只不过返回位置不同</span></span><br><span class="line">TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 去左子树搜索</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, target);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 去右子树搜索</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, target);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="关于删除操作后的维护：">关于删除操作后的维护：</h3><p>需要分三种情况：</p><h4 id="root-是叶子结点">root 是叶子结点</h4><p>直接删除叶子结点 即 直接return null 让上一层接收：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png" alt="BST_删除叶子结点"></p><h4 id="root-左右有一个子节点为空">root 左右有一个子节点为空</h4><h5 id="当左子树不为空：">当左子树不为空：</h5><p>直接把左子树拼接上去即可，即返回左子树让上一层接收</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA.png" alt="删除节点_左子树不为空"></p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA_%E6%8B%BC%E6%8E%A5%E5%90%8E.png" alt="删除节点_左子树不为空_拼接后"></p><h5 id="当右子树不为空：">当右子树不为空：</h5><p>直接把右子树拼接上去即可，即返回右子树让上一层接收</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA.png" alt="删除节点_右子树不为空"></p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA_%E6%8B%BC%E6%8E%A5%E5%90%8E.png" alt=""></p><h4 id="root-左右均不为空">root 左右均不为空</h4><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E5%9D%87%E4%B8%8D%E4%B8%BA%E7%A9%BA.png" alt="左右子树均不为空"></p><p>那么情况会变的复杂一些，这是由于要找到能够接替被删除节点位置的节点。这时，我们会有两种选择：</p><ul><li>找左子树的最大值</li><li>找右子树的最小值</li></ul><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9_%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E5%9D%87%E4%B8%8D%E4%B8%BA%E7%A9%BA_%E5%B7%A6%E5%AD%90%E6%A0%91%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="左子树最大值"></p><h2 id="98-验证二叉搜索树"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><p>中序遍历而不是前序遍历的原因是：</p><p>中序遍历的特性。中序遍历按照“左-根-右”的顺序访问树中的节点。对于二叉搜索树，中序遍历会按照升序的方式访问树中的所有节点。因此，我们可以通过检查在中序遍历过程中每个相邻节点之间的值的大小关系来验证这棵树是否是有效的二叉搜索树。如果遍历的过程中发现某个节点的值小于等于前一个节点的值，那么这棵树就不是一个有效的二叉搜索树。</p><p>相反，前序遍历按照“根-左-右”的顺序访问树中的节点，这种顺序无法直接用来验证二叉搜索树的性质。因为前序遍历不保证访问的节点值是按照升序排列的，所以使用前序遍历会使得验证二叉搜索树的过程变得更加复杂。</p><p>总之，使用中序遍历是因为它可以直接利用二叉搜索树的性质，按照升序访问树中的节点，从而简化了验证二叉搜索树的过程。</p><p>三个方法：</p><ol><li>使用中序遍历的有序性质 + 辅助数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; inOrderResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = i + <span class="number">1</span>; j &lt; inOrderResult.size();) {</span><br><span class="line">        <span class="keyword">if</span> (inOrderResult.get(j) &lt;= inOrderResult.get(i)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    inOrderResult.add(root.val);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>借用一个非常小的值 继续使用中序遍历 PS：这里使用long minValue的原因是有可能存在int的最小值从而使得无法正确判断当左叶子结点特别小（Int MinValue）的情况。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">longMin</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">return</span> traverse(root);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= longMin) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    longMin = root.val;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>双指针，注意previousNode应该作为全局变量从而每一个更新都能被正确更新。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">previousNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">return</span> traverse(root);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">    <span class="keyword">if</span> (previousNode != <span class="literal">null</span> &amp;&amp; previousNode.val &gt;= root.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    previousNode = root;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作为参数传递的方法：</p><p>之前<code>previousNode</code>没有正确地更新的原因是：Java中的参数传递采用的是值传递（pass-by-value）。虽然Java中的对象是引用类型，但实际上传递的是引用的副本。因此，在函数<code>traverse</code>内部修改<code>previousNode</code>的值（例如<code>previousNode = root;</code>）不会影响到调用方的<code>previousNode</code>。</p><p>要解决这个问题，可以将<code>previousNode</code>的引用包装在一个可变的容器类中，例如一个单元素的数组。这样，在递归调用中，<code>previousNode</code>的更新将会影响到调用方。以下是修改后的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode[] previousNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">return</span> traverse(root, previousNode);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, TreeNode[] previousNode)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left, previousNode);</span><br><span class="line">    <span class="keyword">if</span> (previousNode[<span class="number">0</span>] != <span class="literal">null</span> &amp;&amp; previousNode[<span class="number">0</span>].val &gt;= root.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    previousNode[<span class="number">0</span>] = root;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right, previousNode);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="701-二叉搜索树中的插入操作"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h2><blockquote><p>插入操作和二叉树的构造类型题非常类似详情见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/" title="二叉树之构造类问题">二叉树之构造类问题</a></p></blockquote><p>不难，详情看代码注释即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">return</span> insert(root, val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val); <span class="comment">// 这里指找到了插入位置，那么构造一个TreeNode，返回上去，让上一层接收</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) {</span><br><span class="line">        <span class="comment">// 利用BST的性质，此时说明需要继续去右边找：</span></span><br><span class="line">        root.right = insert(root.right, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) {</span><br><span class="line">        <span class="comment">// 利用BST的性质，此时说明需要继续去左边找：</span></span><br><span class="line">        root.left = insert(root.left, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 将更新好的节点不断向上返回。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">return</span> delete(root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">delete</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; key) {</span><br><span class="line">        <span class="comment">// 要删除的key在当前节点的左边</span></span><br><span class="line">        root.left = delete(root.left, key);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) {</span><br><span class="line">        <span class="comment">// 要删除的key在当前节点的右边</span></span><br><span class="line">        root.right = delete(root.right, key);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 找到了要删除的点：</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftTreeMaxNode</span> <span class="operator">=</span> findLeftTreeMaxNode(root.left);</span><br><span class="line">            root.left = removeLeftTreeMaxNode(root.left);</span><br><span class="line">            leftTreeMaxNode.left = root.left;</span><br><span class="line">            leftTreeMaxNode.right = root.right;</span><br><span class="line">            root = leftTreeMaxNode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到左子树中的最大的节点：</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findLeftTreeMaxNode</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="literal">null</span>) {</span><br><span class="line">        root = root.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像移除链表中的最后一个元素一样移除root</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">removeLeftTreeMaxNode</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 当二叉树走到头时，返回当前节点的左树，这是因为左树中还有节点，如果直接返回null则相当于删除了整个左子树</span></span><br><span class="line">        <span class="keyword">return</span> root.left;</span><br><span class="line">    }</span><br><span class="line">    root.right = removeLeftTreeMaxNode(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="669-修剪二叉搜索树"><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><p>利用BST的性质 <strong>递归的处理左树和右树</strong></p><p>1、<strong><code>root.val &lt; lo</code>，这种情况下 <code>root</code> 节点本身和 <code>root</code> 的左子树全都是小于 <code>lo</code> 的，都需要被剪掉</strong>。</p><p>2、<strong><code>root.val &gt; hi</code>，这种情况下 <code>root</code> 节点本身和 <code>root</code> 的右子树全都是大于 <code>hi</code> 的，都需要被剪掉</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rootTrimmed</span> <span class="operator">=</span> buildTree(root, low, high);</span><br><span class="line">        <span class="keyword">return</span> rootTrimmed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) {</span><br><span class="line">            <span class="comment">// 注意这里不能直接返回右子树: return root.right 我们需要继续递归的处理子树才行，因为我们要的是最终的结果而不是一次性的结果</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(root.right, low, high);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) {</span><br><span class="line">            <span class="comment">// 注意这里不能直接返回左子树: return root.left 我们需要继续递归的处理子树才行，因为我们要的是最终的结果而不是一次性的结果</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(root.left, low, high);</span><br><span class="line">        }</span><br><span class="line">        root.left = buildTree(root.left, low, high);</span><br><span class="line">        root.right = buildTree(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><p>和利用前序和后序数组构造二叉树题目类型非常相似，确定好左右区间，确定好根节点即可：</p><blockquote><p>关于 前序和后序数组<strong>构造</strong>二叉树题目 见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/" title="二叉树之构造类问题">二叉树之构造类问题</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = buildTree(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="538-把二叉搜索树转换为累加树"><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h2><p>利用BST性质，降序输出，这个也是利用了双指针的性质：</p><p>可以想象成一个数组：</p><p>6 7 8</p><p>需要一个 <strong>累加</strong> 数组，此时用双指针 pre cur 指向 7 8</p><p>那么问题就好解决了，同理，是用双指针：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 使用双指针</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.right); <span class="comment">// 先遍历右树，使得其按照降序输出</span></span><br><span class="line">        root.val += pre;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种解法：使用sum作为外部变量</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 中序遍历可以按照升序排列来输出，</span></span><br><span class="line">        <span class="comment">// 那么我们只需要做一些修改使其按照降序排列来输出 并 同时维护一个外部变量sum即可</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.right); <span class="comment">// 先遍历右树，使得其按照降序输出</span></span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树之构造类问题</title>
      <link href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>构造类问题思路：</h1><blockquote><p><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/">labuladong</a>的总结很好</p></blockquote><p>二叉树的构造问题一般都是使用**「分解问题」**的思路：<strong>构造整棵树 = 根节点 + 构造左子树 + 构造右子树。</strong></p><p>经典的构造题有三道：</p><h2 id="654-最大二叉树"><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="comment">// 使用分解问题的思路解题，构造顺序为 根节点 + 构造左树 + 构造的右树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> constructTree(nums);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">constructTree</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIdx</span> <span class="operator">=</span> findMaxNumIndex(nums);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxIdx]);</span><br><span class="line">    <span class="comment">// Arrays.copyOfRange 时间复杂度是O(N)</span></span><br><span class="line">    root.left = constructTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxIdx));</span><br><span class="line">    root.right = constructTree(Arrays.copyOfRange(nums, maxIdx + <span class="number">1</span>, nums.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMaxNumIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) {</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">            idx = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>⚠️由于使用了Arrays.copyOfRange此方法会有些慢</p><p>优化后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> {</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) {</span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; nums[i]) {</span><br><span class="line">            index = i;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">    root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p>此题依然沿用思路：使用分解子问题的方法解题：根节点 + 左子树 + 右子树</p><ul><li>对于根节点：利用<strong>前</strong>序遍历的性质，中左右，开头第一个即为根节点</li><li>对于左右子树：利用中序遍历的性质，左右中，我们可以找到root对应的index从而找到左右子树的范围<ul><li>对于左子树来说，<strong>前</strong>序遍历的数组从 preStart + 1 开始 到 preStart + leftSize，中序遍历的数组则从inStart 开始 到 rootIdxInOrder - 1:</li><li>对于右子树来说，<strong>前</strong>序遍历的数组从 preStart + leftSize + 1 开始 到 preEnd，中序遍历的数组则从 rootIdxInOrder + 1 开始 到 inEnd:</li></ul></li><li>❗️总结：利用前序遍历找到root节点，利用中序遍历确定左右子树的区间</li></ul><p>ps: 一点优化：用于快速查找root在inorder array里面的位置，由于tree里面的值保证不重复</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; val2idxMap;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> {</span><br><span class="line">    <span class="comment">// 继续使用分解子问题的方法解题：根节点 + 左子树 + 右子树</span></span><br><span class="line">    <span class="comment">// 利用前序遍历的性质，中左右，开头第一个即为根节点</span></span><br><span class="line">    <span class="comment">// 利用中序遍历的性质，左右中，我们可以找到root对应的index从而找到左右子树的范围</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于快速查找root在inorder array里面的位置，由于tree里面的值保证不重复：</span></span><br><span class="line">    val2idxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) {</span><br><span class="line">        val2idxMap.put(inorder[i], i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">preStart</span> <span class="operator">=</span> <span class="number">0</span>, preEnd = preorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inStart</span> <span class="operator">=</span> <span class="number">0</span>, inEnd = inorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> build(preorder, preStart, preEnd, inorder, inStart, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIdxInOrder</span> <span class="operator">=</span> val2idxMap.get(val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> rootIdxInOrder - inStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于左子树来说，</span></span><br><span class="line">    <span class="comment">// 前序遍历的数组从 preStart + 1 开始 到 preStart + leftSize</span></span><br><span class="line">    <span class="comment">// 中序遍历的数组则从inStart 开始 到 rootIdxInOrder - 1:</span></span><br><span class="line">    root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">            inorder, inStart, rootIdxInOrder - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于右子树来说，</span></span><br><span class="line">    <span class="comment">// 前序遍历的数组从 preStart + leftSize + 1 开始 到 preEnd</span></span><br><span class="line">    <span class="comment">// 中序遍历的数组则从 rootIdxInOrder + 1 开始 到 inEnd:</span></span><br><span class="line">    root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">            inorder, rootIdxInOrder + <span class="number">1</span>, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2><p>继续沿用上题思路：</p><p>使用分解子问题的方法解题：根节点 + 左子树 + 右子树</p><ul><li>对于根节点：利用<strong>后</strong>序遍历的性质，左右中，右手边第一个即为根节点</li><li>对于左右子树：利用中序遍历的性质，左右中，我们可以找到root对应的index从而找到左右子树的范围<ul><li>PS: ⚠️为了测试，我这里使用rightTreeSize 但是使用leftTreeSize也是可以的：</li><li>对于左子树来说，<strong>后</strong>序遍历的数组从 postStart 开始 到 postEnd - rightTreeSize - 1，中序遍历的数组则从inStart 开始 到 rootIdx - 1:</li><li>对于右子树来说，<strong>后</strong>序遍历的数组从postEnd - rightTreeSize - 1 开始 到 postEnd - 1，中序遍历的数组则从 rootIdx + 1 开始 到 inEnd:</li></ul></li><li>❗️总结：利用<strong>后</strong>序遍历找到root节点，利用中序遍历确定左右子树的区间</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; val2IdxMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">    <span class="comment">// 继续 找根 + 左子树范围 + 右子树范围</span></span><br><span class="line">    <span class="comment">// 用后序找根因为后序遍历的从后往前第一个是根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) {</span><br><span class="line">        val2IdxMap.put(inorder[i], i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">postStart</span> <span class="operator">=</span> <span class="number">0</span>, postEnd = postorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inStart</span> <span class="operator">=</span> <span class="number">0</span>, inEnd = inorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> build(postorder, postStart, postEnd, inorder, inStart, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">    <span class="keyword">if</span> (postStart &gt; postEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIdx</span> <span class="operator">=</span> val2IdxMap.get(rootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightTreeSize</span> <span class="operator">=</span> inEnd - rootIdx;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    root.left = build(postorder, postStart, postEnd - rightTreeSize - <span class="number">1</span>,</span><br><span class="line">            inorder, inStart, rootIdx - <span class="number">1</span>);</span><br><span class="line">    root.right = build(postorder, postEnd - rightTreeSize - <span class="number">1</span>, postEnd - <span class="number">1</span>,</span><br><span class="line">            inorder, rootIdx + <span class="number">1</span>, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用leftTreeSize的解法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">               <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">    <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">    <span class="comment">// 左子树的节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line">    root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                        postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                        postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="889-根据前序和后序遍历构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h2><p>思路其实是相通的，但是：</p><p>⚠️<strong>通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树</strong>。⚠️</p><p>思路：</p><ol><li>首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。</li><li>然后把前序遍历结果的第二个元素作为左子树的根节点的值。</li><li>在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。</li></ol><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg" alt="通过前序后序构造二叉树"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; val2Idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) {</span><br><span class="line">        val2Idx.put(postorder[i], i);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">preStart</span> <span class="operator">=</span> <span class="number">0</span>, preEnd = preorder.length - <span class="number">1</span>,</span><br><span class="line">            postStart = <span class="number">0</span>, postEnd = postorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> build(preorder, preStart, preEnd, postorder, postStart, postEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> {</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (postStart &gt; postEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (preEnd == preStart) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftTreeRootIdxInPostOrder</span> <span class="operator">=</span> val2Idx.get(leftRootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftTreeSize</span> <span class="operator">=</span> leftTreeRootIdxInPostOrder - postStart + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftTreeSize,</span><br><span class="line">            postorder, postStart, leftTreeRootIdxInPostOrder);</span><br><span class="line">    root.right = build(preorder, preStart + leftTreeSize + <span class="number">1</span>, preEnd,</span><br><span class="line">            postorder, leftTreeRootIdxInPostOrder + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>额外多了一个检查：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preEnd == preStart) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br></pre></td></tr></tbody></table></figure><h3 id=""></h3>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树之计算深度</title>
      <link href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/"/>
      <url>/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1>树计算深度类问题：</h1><h2 id="111-二叉树的最小深度"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><h3 id="方法1-DFS">方法1 DFS:</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>  dfsCompose(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfsCompose</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="comment">// 函数定义：返回当前树的最小深度 注意最小深度是根结点到叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这道题递归条件里分为三种情况</span></span><br><span class="line">    <span class="comment">//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> minDepth(cur.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> minDepth(cur.right);</span><br><span class="line">    <span class="comment">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span> || cur.right == <span class="literal">null</span>) <span class="keyword">return</span> m1 + m2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(m1,m2) + <span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfsCompose</span><span class="params">(TreeNode cur, <span class="type">int</span> curDepth)</span> {</span><br><span class="line">    <span class="comment">// 函数定义：返回当前树的最小深度 注意最小深度是根结点到叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) <span class="keyword">return</span> curDepth;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMin</span> <span class="operator">=</span> dfsCompose(cur.left, curDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMin</span> <span class="operator">=</span> dfsCompose(cur.right, curDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.min(leftMin, rightMin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="方法2-BFS">方法2 BFS</h3><p>第一版：（⚠️有瑕疵）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> bfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    dq.addLast(cur);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">levelCur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left == <span class="literal">null</span> &amp;&amp; levelCur.right == <span class="literal">null</span>) min = Math.min(min, height);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left != <span class="literal">null</span>) dq.addLast(levelCur.left);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.right != <span class="literal">null</span>) dq.addLast(levelCur.right);</span><br><span class="line">        }</span><br><span class="line">        height++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个版本有瑕疵的原因是BFS<strong>第一个碰到的叶子结点一定是最短的</strong>。因为他是一层一层下去的</p></blockquote><p>因此无需维护min, 可以直接return 所以可以优化为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> bfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    dq.addLast(cur);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">levelCur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left == <span class="literal">null</span> &amp;&amp; levelCur.right == <span class="literal">null</span>) <span class="keyword">return</span> height;</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left != <span class="literal">null</span>) dq.addLast(levelCur.left);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.right != <span class="literal">null</span>) dq.addLast(levelCur.right);</span><br><span class="line">        }</span><br><span class="line">        height++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化前：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6BFS%E4%BC%98%E5%8C%96%E5%89%8D.png" alt="111. 二叉树的最小深度BFS优化前.png"></p><p>优化后：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6BFS%E4%BC%98%E5%8C%96%E5%90%8E.png" alt="111. 二叉树的最小深度BFS优化后.png"></p><h2 id="104-二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><h3 id="dfs的两个解法：">dfs的两个解法：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MIN_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> getMax(cur.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> getMax(cur.right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) {</span><br><span class="line">        res = Math.max(depth, res);</span><br><span class="line">    }</span><br><span class="line">    traverse(cur.left);</span><br><span class="line">    traverse(cur.right);</span><br><span class="line">    depth--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="559-N-叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2><h3 id="回溯：方法1">回溯：方法1</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    traverse(root); </span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.children.size() == <span class="number">0</span>) {</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) {</span><br><span class="line">        depth++;</span><br><span class="line">        traverse(child);</span><br><span class="line">        depth--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="回溯：格式2">回溯：格式2</h3><p>⚠️注意depth的位置以及res在maxDepth中return的变化⚠️</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    traverse(root); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.children.size() == <span class="number">0</span>) {</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) {</span><br><span class="line">        traverse(child);</span><br><span class="line">    }</span><br><span class="line">    depth--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id=""></h3>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/posts/%E5%9B%9E%E6%BA%AF/"/>
      <url>/posts/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考  <a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">labuladong - 回溯算法框架</a> 以及 <a href="https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">代码随想录 - 回溯篇</a><br>感谢支持！</p></div><div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档目录：</p><p>此文档包含以下几个部分：</p><ul><li><a href="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/" title="从二叉树到回溯到DP">从二叉树到回溯到DP</a></li><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/" title="回溯之排列-组合-子集问题">回溯之排列-组合-子集问题</a></li><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/" title="回溯之集合划分问题">回溯之集合划分问题</a></li><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/" title="回溯之切割问题">回溯之切割问题</a></li><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/" title="回溯之棋盘问题">回溯之棋盘问题</a></li></ul></div><h1>回溯算法框架</h1><p>回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。</p><p>回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong></p><h2 id="关于回溯的撤销">关于回溯的撤销</h2><p>回溯撤销操作通常在以下情况下执行：</p><ol><li>当你已经完成了<strong>当前层级的所有操作，并且需要返回到上一层级以尝试其他可能性时</strong>。在这种情况下，撤销操作可以帮助你恢复到之前的状态，从而允许你继续探索其他可能的解决方案。</li><li>当你在当前层级上遇到了一个<strong>不满足约束条件的解时</strong>。在这种情况下，你需要撤销在这个解上所做的操作，以便回到之前的状态并尝试其他选择。</li></ol><p>在递归算法中，回溯撤销操作通常在递归调用之后执行。这是因为，在递归调用返回时，你已经完成了该层级的所有操作，现在需要恢复到之前的状态以便探索其他可能性。</p><p>回溯撤销操作应在完成<strong>当前层级的所有操作</strong>后执行，以便在回溯过程中恢复到之前的状态并尝试其他可能性。</p><h2 id="步骤">步骤</h2><p>为了解决回溯的相关问题，就是解决一个决策树的遍历</p><p>站在回溯树的一个节点上，需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure><p><strong>核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong></p><h1>应用场景</h1><ul><li><p>排列：N个数按一定规则全排列，有几种排列方式</p></li><li><p>组合：N个数里面按一定规则找出k个数的集合</p></li><li><p>子集：一个N个数的集合里有多少符合条件的子集</p><ul><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/" title="回溯之排列-组合-子集问题">回溯之排列-组合-子集问题</a></li></ul></li><li><p>切割：一个字符串按一定规则有几种切割方式</p><ul><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/" title="回溯之切割问题">回溯之切割问题</a></li></ul></li><li><p>棋盘：N皇后，解数独等等</p><ul><li><a href="/posts/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/" title="回溯之棋盘问题">回溯之棋盘问题</a></li></ul></li></ul><p>关键在于<strong>需要暴力去搜索</strong>的算法</p><h1>总结</h1><h2 id="组合-and-子集">组合 and 子集</h2><h3 id="组合">组合</h3><p><img src="/posts/%E5%9B%9E%E6%BA%AF/%E6%80%BB%E7%BB%93_%E7%BB%84%E5%90%88.png" alt="总结_组合"></p><p>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</p><h3 id="子集">子集</h3><h2 id="排列">排列</h2><h2 id="N皇后-and-解数独">N皇后 and 解数独</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> backtrack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/posts/%E9%80%92%E5%BD%92/"/>
      <url>/posts/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>递归 is all I hate</p></div><h1>递归🐢</h1><blockquote><p>递归讲究的就是一个自信，<strong>相信自己的函数定义和它的return值</strong>，做下去，wow amazing，你就得到了结果</p></blockquote><p>递归算法的<strong>时间</strong>复杂度 = <strong>递归的次数</strong> x <strong>函数本身的时间复杂度</strong></p><p>递归算法的<strong>空间</strong>复杂度 = <strong>递归堆栈的深度</strong> + <strong>算法申请的存储空间</strong></p><p>或者再说得直观一点：</p><p>递归算法的时间复杂度 = <strong>递归树的节点个数</strong> x <strong>每个节点的时间复杂度</strong></p><p>递归算法的空间复杂度 = <strong>递归树的高度</strong> + <strong>算法申请的存储空间</strong></p><h2 id="例题">例题</h2><h3 id="226-翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftSwappedResult</span> <span class="operator">=</span> dfs(cur.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightSwappedResult</span> <span class="operator">=</span> dfs(cur.right);</span><br><span class="line">    cur.left = rightSwappedResult;</span><br><span class="line">    cur.right = leftSwappedResult;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-二叉树篇</a> 以及 <a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/">labuladong - 二叉树</a><br>感谢支持！</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-tree"></i><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" title="二叉树之公共祖先">二叉树之公共祖先</a> 中包含公共祖先的习题以及思路</p><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/" title="二叉树之构造类问题">二叉树之构造类问题</a> 中包含构造类问题的习题以及思路</p><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/" title="二叉树之计算深度">二叉树之计算深度</a> 中包含需要计算深度问题的习题以及思路</p><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="二叉搜索树">二叉搜索树</a> 中包含二叉搜索树问题的习题以及思路</p></div><h1>二叉树</h1><h2 id="定义概念：">定义概念：</h2><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6.png" alt="二叉树的高度和深度"></p><p>高度：二叉树中任意一个节点到<strong>叶子节点</strong>的距离 &lt;- 经常用<strong>后序遍历</strong>解决问题</p><ul><li>通过将子节点的高度返回给父节点父节点高度 +1 即可解决问题</li></ul><p>深度：二叉树中任意一个节点到<strong>根节点</strong>的距离 &lt;- 经常用<strong>前序遍历</strong>解决问题</p><ul><li>一往下就深度就 +1</li></ul><h2 id="思维方法：">思维方法：</h2><p>遇到一道二叉树的题目时的<strong>通用思考</strong>过程是：</p><p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。</p><p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p><p>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</p><p>关于后序遍历：</p><p>后序遍历好在：前序位置的代码只能从<strong>函数参数中获取父节点传递来的数据</strong>，而后序位置的代码<strong>不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</strong></p><p><strong>一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p><blockquote><p>根据刷题经验的补充：可以尝试把树抽象成为数组，来看看用数组怎么解决问题</p></blockquote><h2 id="递归遍历">递归遍历</h2><blockquote><p>🤣 一入递归深似海，走到尽头出不来 :P</p></blockquote><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><h3 id="例题">例题</h3><ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul><p>核心就是 traverse function：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">traversalMain</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    traverse(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode cur, List&lt;Integer&gt; res)</span> {</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 前序遍历位置</span></span><br><span class="line">  traverse(cur.left, res);</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 中序遍历位置</span></span><br><span class="line">  traverse(cur.right, res);</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 后序遍历位置</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="迭代遍历">迭代遍历</h2><p>其实就是用迭代法实现前中后序的遍历</p><blockquote><p>前序 中左右</p><p>中序 左中右</p><p>后序 左右中</p></blockquote><p>前序和后序可以归类为一种而中序略微有些差别：</p><p>前序和中序可以被归类为 类似于层序遍历的遍历：</p><p>对于前序来说由于我们需要的结果为 中左右 那么借助栈的先进后出的性质我们需要放入中/根 (pop) 右左：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法：前序需要满足 中左右 的遍历顺序</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (dq.peekLast() == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) dq.addLast(cur.right);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) dq.addLast(cur.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于后序遍历来说，我们只需要完成如下的操作：</p><ol><li>调整层里的右左（前序） -&gt; 左右（后序）</li><li>反转结果即可</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法：后序 需要满足 左右中 的遍历顺序</span></span><br><span class="line">    <span class="comment">// 前序 中左右</span></span><br><span class="line">    <span class="comment">// 通过 中右左 -&gt; 左右中 来达成效果</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (dq.peekLast() == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) dq.addLast(cur.left);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) dq.addLast(cur.right);</span><br><span class="line">    }</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>中序遍历会有所不同，因为现在的中不在是上一层的根，而是需要左节点遍历完成后的祖先。因此，我们需要一个额外的遍历的指针来记录visit过的节点：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树中序遍历（迭代法）"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法的中序遍历：左中右</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// cur 这里只作为一个跟踪的指针用，换成root也没有区别。</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty() || cur != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            dq.addLast(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cur = dq.pollLast();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统一后的迭代遍历">统一后的迭代遍历</h3><p>为了风格统一，来用以下的方法来做三序的迭代法本质上是用了<strong>标记法</strong>：<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong></p><p>中序遍历的标记法例子：</p><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif" alt="中序遍历迭代（统一写法）"></p><h4 id="前序遍历">前序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="中序遍历">中序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="后序遍历">后序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="层序遍历">层序遍历</h2><p>核心：使用<strong>队列</strong> 因为有<strong>先入先出</strong>的性质 + 用 size 来维护队列（当前层的元素数量，从而保证元素是固定于这一层）</p><blockquote><p>队列和栈真是好兄弟，队列来做BFS，栈来做DFS <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p><img src="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="二叉树的层序遍历"></p><ol><li>根节点入队</li><li>loop while(!q.isempty())</li><li>int len = q.size()</li><li>while (Len-- &gt; 0)</li></ol><h3 id="例题：">例题：</h3><ul><li>102.二叉树的层序遍历</li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图</li><li>637.二叉树的层平均值</li><li>429.N叉树的层序遍历</li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针</li><li>117.填充每个节点的下一个右侧节点指针II</li><li>104.二叉树的最大深度</li><li>111.二叉树的最小深度</li></ul><blockquote><p>太多了… 仅需几道题详解</p></blockquote><h4 id="102-二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root); <span class="comment">// &lt;- 头节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size(); <span class="comment">// &lt;- get 当前的 size</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            cur.add(top.val);</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="literal">null</span>) dq.addLast(top.left);</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="literal">null</span>) dq.addLast(top.right);</span><br><span class="line">        }</span><br><span class="line">        res.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="107-二叉树的层序遍历-II"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><p>唯一的区别就是用linkedlist把一层的结果加到头部即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            cur.add(curNode.val);</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="literal">null</span>) dq.add(curNode.left);</span><br><span class="line">            <span class="keyword">if</span> (curNode.right != <span class="literal">null</span>) dq.add(curNode.right);</span><br><span class="line">        }</span><br><span class="line">        res.addFirst(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="例题-2">例题</h2><h3 id="树计算深度类问题：">树计算深度类问题：</h3><blockquote><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6/" title="二叉树之计算深度">二叉树之计算深度</a> 中包含计算深度类问题的习题以及思路</p></blockquote><h3 id="求节点和的问题">求节点和的问题</h3><h4 id="404-左叶子之和"><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>此题可以分解为三个问题：</p><ol><li>求所有节点的和, 很简单，就是左右树的节点和加root节点</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历求所有节点值之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfTrees</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">leave</span> <span class="operator">=</span> root.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfTrees(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfTrees(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + leave;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>求所有叶子结点的和, 也很简单，就只是多了一个判断叶子结点的条件：<code>if (root.left == null &amp;&amp; root.right == null)</code></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历求所有叶子节点值之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">        leave = root.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeaves(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + leave;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>求左叶子结点的和, 也不难，无非是分成两步：<ol><li>该节点是其父节点的左子节点。</li><li>该节点是一个叶子节点，即它没有左右子节点。</li></ol></li></ol><p>即：<code>if (cur.left != null &amp;&amp; cur.left.left == null &amp;&amp; cur.left.right == null)</code></p><p>因此借助二叉树的思维框架我们可以用traverse + 额外变量的方式来解决问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; cur.left.left == <span class="literal">null</span> &amp;&amp; cur.left.right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// cur.left 是一个左叶子节点</span></span><br><span class="line">        sum += cur.left.val;</span><br><span class="line">    }</span><br><span class="line">    dfs(cur.left);</span><br><span class="line">    dfs(cur.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="构造类问题">构造类问题</h3><blockquote><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9E%84%E9%80%A0%E7%B1%BB%E9%97%AE%E9%A2%98/" title="二叉树之构造类问题">二叉树之构造类问题</a> 中包含构造类问题的习题以及思路</p></blockquote><h3 id="BST-二叉搜索树相关题目">BST 二叉搜索树相关题目</h3><blockquote><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="二叉搜索树">二叉搜索树</a> 中包含二叉搜索树问题的习题以及思路</p></blockquote><h3 id="二叉树公共祖先">二叉树公共祖先</h3><blockquote><p>见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" title="二叉树之公共祖先">二叉树之公共祖先</a> 中包含公共祖先的习题以及思路</p></blockquote><h3 id="其他例题">其他例题</h3><h4 id="226-翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>二叉树的递归分为**「遍历」<strong>和</strong>「分解问题」**两种思维模式，这道题可以同时使用两种思维模式。</p><h5 id="方法1-递归-分解问题">方法1: 递归 - 分解问题</h5><p>第一个自己写出来的递归，‼️终于‼️感受到为什么说递归讲究的就是一个自信 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfsQuestionsDivide</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftSwappedResult</span> <span class="operator">=</span> dfsQuestionsDivide(cur.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightSwappedResult</span> <span class="operator">=</span> dfsQuestionsDivide(cur.right);</span><br><span class="line">    cur.left = rightSwappedResult;</span><br><span class="line">    cur.right = leftSwappedResult;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="方法2-递归-遍历">方法2: 递归 - 遍历</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfsTraverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfsTraverse</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.left;</span><br><span class="line">    cur.left = cur.right;</span><br><span class="line">    cur.right = tmp;</span><br><span class="line"></span><br><span class="line">    dfsTraverse(cur.left);</span><br><span class="line">    dfsTraverse(cur.right);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="257-二叉树的所有路径"><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><p>这是一道backtrack的题，这里我先给出代码再解释为什么 root.left后没有 <strong>显性</strong> 的removeLast() 操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// backtrack</span></span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; nodesList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backtrack(root, res, nodesList);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(TreeNode root, List&lt;String&gt; res, LinkedList&lt;String&gt; nodesList)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">        nodesList.addLast(String.valueOf(root.val));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">"-&gt;"</span>, nodesList);</span><br><span class="line">        res.add(s);</span><br><span class="line">        nodesList.removeLast();</span><br><span class="line">    }</span><br><span class="line">    nodesList.addLast(String.valueOf(root.val));</span><br><span class="line">    backtrack(root.left, res, nodesList);</span><br><span class="line">    backtrack(root.right, res, nodesList);</span><br><span class="line">    <span class="comment">// 撤销操作</span></span><br><span class="line">    nodesList.removeLast();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设我们有以下二叉树：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    1</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  2   3</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">4   5</span></span><br></pre></td></tr></tbody></table></figure><p>当我们调用 <code>traverse(root)</code> 时，执行顺序如下：</p><ol><li>添加 1 到 <code>path</code>，此时 <code>path = [1]</code>。</li><li>调用 <code>traverse(root.left)</code> 以遍历左子树（节点 2）。<ol><li>添加 2 到 <code>path</code>，此时 <code>path = [1, 2]</code>。</li><li>调用 <code>traverse(root.left)</code> 以遍历左子树（节点 4）。<ol><li>添加 4 到 <code>path</code>，此时 <code>path = [1, 2, 4]</code>。</li><li>4 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 4，此时 <code>path = [1, 2]</code>。</li><li>返回上一层递归调用（节点 2）。</li></ol></li><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 5）。<ol><li>添加 5 到 <code>path</code>，此时 <code>path = [1, 2, 5]</code>。 ii. 5 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 5，此时 <code>path = [1, 2]</code>。 iii. 返回上一层递归调用（节点 2）。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 2，此时 <code>path = [1]</code>。</li></ol></li><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 3）。<ol><li>添加 3 到 <code>path</code>，此时 <code>path = [1, 3]</code>。</li><li>3 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 3，此时 <code>path = [1]</code>。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 1，此时 <code>path</code> 为空。</li></ol><p>在这个例子中，我们可以看到，在每次递归调用返回时，<code>path.removeLast()</code> 都会被执行。这样，我们可以确保在遍历过程中，<code>path</code> 变量始终正确地表示从根节点到当前节点的路径。在遍历左子树（节点 2）时，<code>path.removeLast()</code> 被执行了两次：一次是在遍历节点 4 后，另一次是在遍历节点 5 后。这样，我们可以确保在遍历右子树（节点 3）之前，<code>path</code> 变量已经从左子树遍历的影响中恢复。这可以确保在继续遍历过程时，<code>path</code> 变量正确地表示从根节点到当前节点的路径。</p><p>继续遍历右子树（节点 3）：</p><ol><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 3）。<ol><li>添加 3 到 <code>path</code>，此时 <code>path = [1, 3]</code>。</li><li>3 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 3，此时 <code>path = [1]</code>。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 1，此时 <code>path</code> 为空。</li></ol><p>现在，整个树的遍历已经完成，<code>res</code> 变量包含了所有从根节点到叶子节点的路径，即 <code>["1-&gt;2-&gt;4", "1-&gt;2-&gt;5", "1-&gt;3"]</code>。</p><h4 id="437-路径总和-III"><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h4><p>这道题很多知识点，涉及到了前缀和的一些理解：</p><p>我们需要一个 哈希表 来存储前缀和的个数，由于这道题只需要返回答案个数，所以记录个数即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;Long, Integer&gt; hmPrefixCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> targetSum;</span><br><span class="line">    <span class="type">long</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> {</span><br><span class="line">        hmPrefixCount.put(<span class="number">0L</span> ,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.targetSum = targetSum;</span><br><span class="line">        <span class="keyword">return</span> traverse(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        curSum += root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        res += hmPrefixCount.getOrDefault(curSum - targetSum, <span class="number">0</span>); </span><br><span class="line">        hmPrefixCount.put(curSum, hmPrefixCount.getOrDefault(curSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftTotal</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightTotal</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line"></span><br><span class="line">        res = res + leftTotal + rightTotal;</span><br><span class="line"></span><br><span class="line">        hmPrefixCount.put(curSum, hmPrefixCount.get(curSum) - <span class="number">1</span>);</span><br><span class="line">        curSum -= root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中我认为最不好理解的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res += hmPrefixCount.getOrDefault(curSum - targetSum, <span class="number">0</span>); </span><br></pre></td></tr></tbody></table></figure><ol><li>为什么是<code>curSum - targetSum</code>？</li></ol><p>这是因为：</p><p>假设我们有以下路径：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; X -&gt; D -&gt; Y</span><br></pre></td></tr></tbody></table></figure><p>从 <code>X</code> 到 <code>Y</code> 的路径和为 <code>target</code>，即 <code>X + D + Y = target</code>。</p><p>从 <code>A</code> 到 <code>Y</code> 的整个路径和为 <code>curSum</code>，即 <code>A + B + X + D + Y = curSum</code>。</p><p>我们的目标是找到从 <code>A</code> 到哪里的路径和，使得剩下的路径和（即从那个位置到 <code>Y</code>）等于 <code>target</code>。如果我们把这个位置称为 <code>Z</code>，那么 <code>Z</code> 就是 <code>X</code> 的前一个位置，即 <code>B</code>。</p><p>为了得到从 <code>A</code> 到 <code>Z</code>（即 <code>B</code>）的路径和，我们可以这样算：</p><p>从 <code>A</code> 到 <code>Y</code> 的路径和减去从 <code>X</code> 到 <code>Y</code> 的路径和，得到：</p><p><code>A + B = curSum - (X + D + Y)</code></p><p>这确实是 <code>A</code> 到 <code>B</code> 的路径和，不是到 <code>X</code>。因此，<code>curSum - target</code> 表示的是从 <code>A</code> 到 <code>B</code> 的路径和。这意味着从 <code>X</code> 开始到 <code>Y</code> 结束的路径和等于 <code>target</code>。</p><ol start="2"><li>为什么这么找而不直接找哪一段路径和为target？</li></ol><p>直接找哪个路径和等于 <code>target</code> 的确是一种方法，但效率不高。为了找到所有与 <code>target</code> 相等的路径和，你必须从每个节点开始，并考虑所有可能的子路径，这导致了O(n^2)的复杂性，其中n是树的节点数。</p><p>使用 <code>prefixMap</code> 和当前累加和 <code>curSum</code> 的方法优化了这个搜索过程。原因如下：</p><ol><li><p><strong>连续子数组问题的解决思路</strong>：这个问题与数组中找连续子数组和等于某个数的问题非常相似。在数组问题中，我们使用一个累加和来记录从数组开始到当前位置的所有元素的和，然后使用一个哈希表来记录之前看到的所有累加和。这种方法可以在O(1)的时间内判断是否存在一个子数组的和等于目标值。</p></li><li><p><strong>时间复杂度</strong>：通过使用 <code>prefixMap</code>，我们可以在O(n)的时间复杂度内解决这个问题。对于每个节点，我们只需要O(1)的时间来更新 <code>prefixMap</code> 和查找 <code>curSum - target</code>。</p></li><li><p><strong>记录所有前缀和</strong>：通过在遍历过程中记录所有可能的前缀和及其出现的次数，我们可以迅速地知道从当前节点回溯到之前的任何节点的路径和是否等于 <code>target</code>。</p></li></ol><p>所以，使用这种方法比直接搜索效率更高，因为它利用了哈希表的查找能力，大大提高了搜索速度。</p><h4 id="1530-好叶子节点对的数量"><a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量</a></h4><p>利用了后序遍历的特性 – 即我们可以从后续位置得到信息</p><p>以及<code>ArrayList&lt;&gt;(1)</code>是创建了一个size为1的list而不是里面有一个1</p><p>若想创建一个list里面有一个1: <code>Arrays.asList(1);</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> distance;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPairs</span><span class="params">(TreeNode root, <span class="type">int</span> distance)</span> {</span><br><span class="line">        <span class="built_in">this</span>.distance = distance;</span><br><span class="line">        dfsDepth(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">dfsDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; nodeLeftList = dfsDepth(root.left);</span><br><span class="line">        List&lt;Integer&gt; nodeRightList = dfsDepth(root.right);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> leftLen : nodeLeftList) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> rightLen : nodeRightList) {</span><br><span class="line">                <span class="keyword">if</span> (leftLen + rightLen &lt;= distance) {</span><br><span class="line">                    <span class="built_in">this</span>.res++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> leftLen : nodeLeftList) {</span><br><span class="line">            leftLen++;</span><br><span class="line">            all.add(leftLen);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> rightLen : nodeRightList) {</span><br><span class="line">            rightLen++;</span><br><span class="line">            all.add(rightLen);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列和单调栈</title>
      <link href="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1>单调(<strong>Monotonic</strong>)队列和单调栈</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵茶山艾府 - 单调栈</a></p><p><a href="https://www.bilibili.com/video/BV1bM411X72E/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵茶山艾府 - 单调队列</a></p></blockquote><p>概念：DIY的一个队列，队列中的元素是单调递增或者单调递减</p><p>目的是为了找到 下一个更大或更小元素</p><p>比如：一个<strong>递减栈，从栈底到栈顶递减</strong>，用来找出从左往右遍历第一个比它大的位置。</p><h1>单调栈</h1><h2 id="739-每日温度"><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><p>通过这个题搞清楚从右向左以及从左向右的单调栈的区别。</p><p>假设数组[1, 4, 3, 5, 5, 2, 3, 6]</p><p>从右向左遍历：<code>本质上是把下一个更大的数存到了栈里</code></p><p>检查栈顶以及当前元素num</p><ol><li><p>若 <code>num &gt;= 栈顶</code> pop 掉栈中元素，从而保证栈底到栈顶是单调递减的</p></li><li><p>更新answer[i]为栈顶元素</p></li><li><p>将num加入栈顶</p></li></ol><p><img src="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/739_%E4%BB%8E%E5%8F%B3%E5%90%91%E5%B7%A6%E9%81%8D%E5%8E%86.jpeg" alt="739_从右向左遍历"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i]) {</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">                answer[i] = stack.peek() - i;</span><br><span class="line">            }            </span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从左向右：<code>本质上是把还没来得及找到下一个更大元素的当前元素放在栈里</code></p><p>一旦发现元素 &gt; 栈顶元素，去掉老的，更新答案</p><p><img src="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/739_%E4%BB%8E%E5%B7%A6%E5%90%91%E5%8F%B3%E9%81%8D%E5%8E%86.jpeg" alt="739_从左向右遍历"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                answer[idx] = i - idx;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) answer[i] = <span class="number">0</span>;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>单调队列</h1><h2 id="239-滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>这道题还涵盖了一个滑动窗口的框架</p><blockquote><a href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 滑动窗口 section</blockquote><p><img src="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/239_%E6%80%9D%E8%B7%AF1.png" alt="239_思路1"></p><p><img src="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/239_%E6%80%9D%E8%B7%AF_%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.png" alt="239_思路_单调队列"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="comment">// 滑动窗口框架：</span></span><br><span class="line">            <span class="comment">// 1. 入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt;= num) {</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            }</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">            <span class="comment">// 2. 出</span></span><br><span class="line">            <span class="keyword">if</span> (i - dq.peekFirst() &gt;= k) {</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 3. 记录答案</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) {</span><br><span class="line">                res.add(nums[dq.peekFirst()]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size(); i++) {</span><br><span class="line">            resultArray[i] = res.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> resultArray;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>题目</h1><h2 id="239-滑动窗口最大值-2"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>需要自己设计一个数据结构支持：</p><ol><li>Pop()</li><li>Push()</li><li>getMaxValue()</li></ol><p>数据结构内部<strong>单调递减</strong>，也就是单调队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">MonolithicDownQueue</span> <span class="variable">monolithicDownQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonolithicDownQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; k) {</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) {</span><br><span class="line">            monolithicDownQueue.pop(nums[left]);</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonolithicDownQueue</span> {</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() == value) {</span><br><span class="line">                dq.removeFirst();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="comment">// 保证数据结构内部单调递减即碰见新元素时，如果新元素大于队尾元素，移除队尾的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; value &gt; dq.peekLast()) {</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            }</span><br><span class="line">            dq.addLast(value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> dq.isEmpty() ? <span class="number">0</span> : dq.peekFirst();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1944-队列中可以看到的人数"><a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/">1944. 队列中可以看到的人数</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] canSeePersonsCount(<span class="type">int</span>[] heights) {</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekLast() &lt; heights[i]) {</span><br><span class="line">                res[i]++;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty()) res[i] += <span class="number">1</span>;</span><br><span class="line">            dq.addLast(heights[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单调队列和单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java碎碎念</title>
      <link href="/posts/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/posts/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>收集些容易忽视的Java的用法</p></div><h1>Java</h1><h2 id="Collections-Interface">Collections Interface</h2><p><img src="/posts/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/Collections-in-Java.png" alt="Collections Interface"></p><h3 id="List">List</h3><h4 id="ArrayList">ArrayList</h4><h4 id="LinkedList">LinkedList</h4><p>LinkedList Methods:</p><table><thead><tr><th>Methods</th><th>Description</th></tr></thead><tbody><tr><td>addFirst()</td><td>Adds an item to the beginning of the list.</td></tr><tr><td>addLast()</td><td>Add an item to the end of the list</td></tr><tr><td>removeFirst()</td><td>Remove an item from the beginning of the list.</td></tr><tr><td>removeLast()</td><td>Remove an item from the end of the list</td></tr><tr><td>getFirst()</td><td>Get the item at the beginning of the list</td></tr><tr><td>getLast()</td><td>Get the item at the end of the list</td></tr></tbody></table><h3 id="Deque">Deque</h3><h4 id="LinkedList-实现">LinkedList 实现</h4><h4 id="ArrayDeque-实现">ArrayDeque 实现</h4><h3 id="总结">总结</h3><p>其实就是array和linkedlist区别，大部分时间里array会比较快。但是当添加元素时超了array的容积，则ArrayDeque需要resize.</p><h1>Stream()</h1><ol><li>List to array one line:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List.stream().mapToInt(i -&gt; i).toArray();</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>Print elements in an int[]:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(ret).forEach(a -&gt; System.out.print(a + <span class="string">" "</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="Reduce">Reduce()</h2><p>有三个组成元素：</p><p>identity, accumulator, combiner:</p><ul><li><em>Identity</em> – an element that is the initial value of the reduction operation and the default result if the stream is empty</li><li><em>Accumulator</em> – a function that takes two parameters: a partial result of the reduction operation and the next element of the stream</li><li><em>Combiner</em> – a function used to combine the partial result of the reduction operation when the reduction is parallelized or when there’s a mismatch between the types of the accumulator arguments and the types of the accumulator implementation</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, (subtotal, element) -&gt; subtotal + element);</span><br><span class="line">assertThat(result).isEqualTo(<span class="number">21</span>);</span><br></pre></td></tr></tbody></table></figure><p>0 <code>is</code> identity</p><p>subtotal, element -&gt; subtotal + element <code>is</code> accumulator</p><h2 id="Pair">Pair</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> pair.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> pair.getValue();</span><br></pre></td></tr></tbody></table></figure><h1>Comparator</h1><p>在Arrays.sort中使用 Comparator:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(costs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> {</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>] - o1[<span class="number">1</span>] - (o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>在Collections.sort中使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(costs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;List&lt;Integer&gt;&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(List&lt;Integer&gt; o1, List&lt;Integer&gt; o2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff1</span> <span class="operator">=</span> o1.get(<span class="number">0</span>) - o1.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff2</span> <span class="operator">=</span> o2.get(<span class="number">0</span>) - o2.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(diff1, diff2);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>和<code>Map.Entry</code> 结合在一起:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hm.entrySet());</span><br><span class="line">Collections.sort(ls, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e1, Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e2)</span> {</span><br><span class="line">        <span class="type">Character</span> <span class="variable">e1Key</span> <span class="operator">=</span> e1.getKey();</span><br><span class="line">        <span class="type">Character</span> <span class="variable">e2Key</span> <span class="operator">=</span> e2.getKey();</span><br><span class="line">        <span class="type">int</span>[] e1Value = e1.getValue();</span><br><span class="line">        <span class="type">int</span>[] e2Value = e2.getValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> e1Value.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> e1Value[i], second = e2Value[i];</span><br><span class="line">            <span class="keyword">if</span> (first == second) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> second - first;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e1Key - e2Key;</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1>通过位运算来互换大小写</h1><p>大写字符与其对应的小写字符的 ASCII 的差为 32</p><p>也就是 <code>1&lt;&lt;5</code></p><p>所以：</p><p>变换大小写这件事等价于：</p><ul><li>如果字符是小写字符，减去 32 得到大写字符；</li><li>如果字符是大写字符，加上 32 得到小写字符。</li></ul><p>而这两者合并起来，就是给这个字符做一次不进位的加法，即异或上 1 &lt;&lt; 5。</p><blockquote><p>为什么两者合并起来相当于一个不进位的加法?</p><p>考虑一下异或操作的特性：</p><ul><li>0 XOR 0 = 0</li><li>1 XOR 0 = 1</li><li>0 XOR 1 = 1</li><li>1 XOR 1 = 0</li></ul><p>这与不进位加法的规则相同，即：</p><ul><li>0 + 0 = 0</li><li>1 + 0 = 1</li><li>0 + 1 = 1</li><li>1 + 1 = 0 (不考虑进位)</li></ul><p>现在，考虑ASCII值。大写字母与其对应的小写字母的ASCII值之间的差异在第5位上。例如：</p><ul><li>‘A’ = 65 = 1000001 (二进制)</li><li>‘a’ = 97 = 1100001 (二进制)</li></ul><p>请注意第5位的差异。要从’A’转到’a’，我们需要将第5位从0变为1，这可以通过加32（即1左移5位）来实现。反之亦然。</p><p>当我们异或一个数字时，我们实际上是在为该数字的每一位执行不进位加法。因此，当我们对字符值进行异或操作<code>1 &lt;&lt; 5</code>时，我们实际上是在进行以下操作：</p><ul><li>如果第5位是0（即该字符是大写字母），我们将其加上1，从而将该字符转换为小写字母。</li><li>如果第5位是1（即该字符是小写字母），我们将其加上0，从而将该字符转换为大写字母。</li></ul><p>因此，异或操作实际上是实现不进位加法的一种快速方法。在这种情况下，它可以用来在大写和小写字符之间进行快速切换。</p></blockquote><h2 id="代码：">代码：</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="使用此技巧的例题">使用此技巧的例题</h2><h3 id="784-字母大小写全排列"><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h3><blockquote><p>这个题在 <a href="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/" title="从二叉树到回溯到DP">从二叉树到回溯到DP</a> 中</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>通过左括号指针判断括号是否合法：</h1><p>思路是用代表左括号的指针移动，碰到左括号右移，右括号左移，如果left == 0证明合法，否则比如左括号的idx &lt; 0则代表右括号&gt;左括号数量，不合法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String sb)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : sb.toCharArray()) {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">            left--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 右括号比左括号多，肯定无效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果左括号的数量等于右括号的数量，才是一个有效的括号字符串</span></span><br><span class="line">    <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用此技巧的例题-2">使用此技巧的例题</h2><h3 id="301-删除无效的括号"><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h3><p>在 <a href="/posts/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/" title="从二叉树到回溯到DP">从二叉树到回溯到DP</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        n = s.length();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> filterResult();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">filterResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 筛选出最长的有效括号字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            maxLen = Math.max(maxLen, str.length());</span><br><span class="line">        }</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            <span class="keyword">if</span> (str.length() == maxLen) {</span><br><span class="line">                set.add(str);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb.toString())) {</span><br><span class="line">                paths.add(sb.toString());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>) {</span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 选择当前的括号</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不选择当前的括号</span></span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String sb)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sb.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 右括号比左括号多，肯定无效</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果左括号的数量等于右括号的数量，才是一个有效的括号字符串</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>StringBuilder</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sb.append(c);</span><br><span class="line">backtrack(idx + <span class="number">1</span>);</span><br><span class="line">sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><h1></h1>]]></content>
      
      
      <categories>
          
          <category> Programming-Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列和栈</title>
      <link href="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
      <url>/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-队列与栈篇</a><br>感谢支持！</p></div><h1>队列 (Queue) and 栈 (Stack)</h1><blockquote><a href="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含队列和栈的基础知识</blockquote><h2 id="题目">题目</h2><h3 id="232-用栈实现队列"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>双栈实现队列题</p><p>很简单，一个栈负责暂时储存元素，另一个栈若为空的时候从第一个栈拿元素 aka <strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.gif" alt="232.用栈实现队列"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; dq1, dq2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> {</span><br><span class="line">        dq1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dq2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        dq1.push(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        count--;</span><br><span class="line">        moveElements();</span><br><span class="line">        <span class="keyword">return</span> dq2.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveElements</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (dq2.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!dq1.isEmpty()) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dq1.pop();</span><br><span class="line">                dq2.push(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        moveElements();</span><br><span class="line">        <span class="keyword">return</span> dq2.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="225-用队列实现栈"><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>用两个数组时，核心在于一个辅助数组用于置换，从而始终保持有一个数组的头为最后一个进来的元素，以达到FILO的结果：</p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/225_%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225_队列实现栈"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; q1, q2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        q2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty()) {</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题也可以只用一个Queue来做：</p><p>其实相当于形成了个循环队列，只不过开头一定是新进来的那个元素</p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/225_%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88_%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E7%89%88.gif" alt="225-OneQueueVer"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        q.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="20-有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] s2Char = s.toCharArray();</span><br><span class="line">        Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s2Char) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                dq.push(<span class="string">')'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'{'</span>) {</span><br><span class="line">                dq.push(<span class="string">'}'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) {</span><br><span class="line">                dq.push(<span class="string">']'</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (dq.isEmpty() || dq.peek() != c) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                dq.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dq.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1047-删除字符串中的所有相邻重复项"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><p><strong>本题有点像祖玛游戏</strong></p><blockquote><p>Credit to: <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/solution/dong-hua-tu-jie-yong-zhan-bao-cun-wei-be-4u5w/">LC详解 - 负雪明烛</a></p></blockquote><p>本题要点：</p><ol><li>两个相邻且相同字符会被删除。（注意：是两个！）</li><li>删除字符串中两个相邻并且相同的字符可能会产生新的相邻并且相同的字符。 比如对于 abba ，删除 bb 之后， aa 会碰到一起，也需要继续把 aa 删掉。</li></ol><p>所以：</p><p>① 并不能一次删除操作就能达到目的；而应该在每次删除一对相邻且相同的字符之后、再看新的字符串是否存在相邻且相同的一对字符。</p><p>② 如果存在多组的相邻且相同的字符时，先删除哪一对对最终结果是没有影响的。比如对于 abbacca ，无论先删除 bb 还是先删除 cc 最终的结果都是 a 。</p><p>通过 ① 我们得出：需要用一个数据结构缓存结果，这个数据结构应该是<strong>后进先出</strong>，也就是<strong>栈</strong>！<br>通过 ② 我们得出：可以从左到右遍历一次输入字符串 S 的所有字符 Si，把 Si 跟栈顶元素比较</p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/1047_%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047_删除重复项"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">char</span>[] s2Char = s.toCharArray();</span><br><span class="line">    Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s2Char) {</span><br><span class="line">        <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; c == dq.peekLast()) {</span><br><span class="line">            dq.removeLast();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dq.addLast(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        sb.append(dq.removeFirst());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="150-逆波兰表达式求值"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p>这是一道关于**「表达式计算」<strong>的题目。所有的</strong>「表达式计算」<strong>问题都离不开</strong>「栈」**。</p><p>思路总结：遇到数字压栈，遇到符号取出数字，计算，压栈更新后的数字。</p><p><img src="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><p>用Deque：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) {</span><br><span class="line">        <span class="keyword">if</span> (token.equals(<span class="string">"+"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left + right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"*"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left * right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"-"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left - right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"/"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left / right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dq.addLast(token);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数组模拟栈：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] ts)</span> {</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[ts.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : ts) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"+-*/"</span>.contains(s)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> d[tt--], a = d[tt--];</span><br><span class="line">                d[++tt] = calc(a, b, s);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                d[++tt] = Integer.parseInt(s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> d[tt];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String op)</span> {</span><br><span class="line">        <span class="keyword">if</span> (op.equals(<span class="string">"+"</span>)) <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"-"</span>)) <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>)) <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"/"</span>)) <span class="keyword">return</span> a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="239-滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>两个难点：</p><ol><li>我们需要求 k 窗口内的 最大值</li><li>不能够使用优先队列<ol><li>因为优先队列排序后，要pop的元素可能不是排序后的元素了。<ol><li>比如：1 3 -1 -3</li><li>队列中 3 1 -1 -3 此时会pop 3 而不是 1</li></ol></li></ol></li></ol><p>因此需要自己设计一个数据结构支持：</p><ol><li>Pop()</li><li>Push()</li><li>getMaxValue()</li><li>数据结构内部单调递减，也就是 <a href="/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/" title="单调队列和单调栈">单调队列和单调栈</a></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">MonolithicDownQueue</span> <span class="variable">monolithicDownQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonolithicDownQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; k) {</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) {</span><br><span class="line">            monolithicDownQueue.pop(nums[left]);</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonolithicDownQueue</span> {</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() == value) {</span><br><span class="line">                dq.removeFirst();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="comment">// 保证数据结构内部单调递减即碰见新元素时，如果新元素大于队尾元素，移除队尾的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; value &gt; dq.peekLast()) {</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            }</span><br><span class="line">            dq.addLast(value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> dq.isEmpty() ? <span class="number">0</span> : dq.peekFirst();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="347-前-K-个高频元素"><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>本题用到了 <strong>优先队列</strong> + <strong>Map</strong></p><blockquote><p>Highlight: 用的是<strong>小顶堆</strong>，这样就不用维护所有的值而只维护<strong>k个</strong>元素，因为是不断把最小的元素pop()出去, <strong>因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong> 从而由 nlogn -&gt; nlogk。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">    Map&lt;Integer, Integer&gt; num2Count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">        num2Count.put(i, num2Count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; numEntry : num2Count.entrySet()) {</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[]{numEntry.getKey(), numEntry.getValue()};</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &lt; k) {</span><br><span class="line">            pq.add(cur);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 确定pop出去的是相对小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt;= numEntry.getValue()) <span class="keyword">continue</span>;</span><br><span class="line">            pq.poll();</span><br><span class="line">            pq.add(cur);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//                pq.forEach(a -&gt; System.out.print(a[0] + " " + a[1]));</span></span><br><span class="line"><span class="comment">//                System.out.println();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        ret[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列和栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://www.programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html">代码随想录-字符串篇</a><br>感谢支持！</p></div><h1>字符串 String</h1><blockquote><a href="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含字符串的基础知识</blockquote><h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></p><p>非常基本的双指针应用题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        <span class="comment">// 双指针swap:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            swap(s, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></p><p>本题难点在于问题转化：题干上：</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p>如果直接模拟这两条规则的话会比较麻烦，但是其实这两条可以等价转化为如下的问题：</p><p><strong>当剩余元素多于k个，反转前k个 (i, i + k)，否则反转后k个 (i, n - 1)</strong></p><p>那么问题迎刃而解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">      <span class="type">char</span>[] s2char = s.toCharArray();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// methodOne(k, s2char);</span></span><br><span class="line">      <span class="comment">// methodTwo:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; s2char.length; left += <span class="number">2</span> * k) {</span><br><span class="line">          swap(s2char, left, Math.min(left + k, s2char.length) - <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> String.valueOf(s2char);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">(<span class="type">int</span> k, <span class="type">char</span>[] s2char)</span> {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; s2char.length; left = left + k * <span class="number">2</span>) {</span><br><span class="line">          <span class="keyword">if</span> (left + k &lt;= s2char.length) {</span><br><span class="line">              <span class="comment">// 元素在length里面不会取空</span></span><br><span class="line">              swap(s2char, left, left + k - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="comment">// 若少于k个，翻转剩余全部字符</span></span><br><span class="line">          swap(s2char, left, s2char.length - <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">char</span>[] s2char, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">          <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s2char[left];</span><br><span class="line">          s2char[left] = s2char[right];</span><br><span class="line">          s2char[right] = temp;</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><p>此题的解法有两个分别是：</p><ol><li><p>用到额外的空间 （非常简单，直接秒杀）</p><ol><li>这里简单提一下StringBuilder 和 StringBuffer的区别</li><li>StringBuilder 单线程，会快一些</li></ol></li><li><p>不用额外的空间，原地修改</p><p><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.gif" alt="替换空格-原地修改"></p><ol><li><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></li><li>这么做有两个好处：<ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) {</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="string">' '</span>) sb.append(<span class="string">" "</span>).append(<span class="string">" "</span>);</span><br><span class="line">          }</span><br><span class="line">          <span class="comment">// older length</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">          s = s + sb;</span><br><span class="line">          <span class="comment">// newer length</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">          <span class="type">char</span>[] sAsChar = s.toCharArray();</span><br><span class="line">          <span class="keyword">while</span> (fast &gt;= <span class="number">0</span>) {</span><br><span class="line">              <span class="keyword">if</span> (sAsChar[fast] != <span class="string">' '</span>) {</span><br><span class="line">                  sAsChar[slow] = sAsChar[fast];</span><br><span class="line">                  fast--;</span><br><span class="line">                  slow--;</span><br><span class="line">              } <span class="keyword">else</span> {</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'0'</span>;</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'2'</span>;</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'%'</span>;</span><br><span class="line">                  fast--;</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> String.valueOf(sAsChar);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> String <span class="title function_">methodOneWithExtraSpace</span><span class="params">(String s)</span> {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) {</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="string">' '</span>) {</span><br><span class="line">                  sb.append(<span class="string">"%20"</span>);</span><br><span class="line">              } <span class="keyword">else</span> {</span><br><span class="line">                  sb.append(c);</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> sb.toString();</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p><p>依旧是两个解法：</p><ol><li><p>使用库函数：</p><ol><li>String.trim()<ol><li><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/String_Trim.png" alt="String.trim()"></li><li>eliminates leading and trailing spaces.</li><li>Time: <strong>O(N)</strong></li></ol></li><li>String.split(String reges, int limit)<ol><li>breaks a given string around matches of the given regular expression</li><li>Time: <strong>O(N)</strong></li></ol></li><li><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2LC%E9%A2%98%E8%A7%A3.png" alt="151_LC_解法"></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">methodOneUseLibrary</span><span class="params">(String s)</span> {</span><br><span class="line">    String[] elementsArr = s.trim().split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//            Arrays.stream(elementsArr).forEach(e -&gt; System.out.println(e + "/"));</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = elementsArr.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(elementsArr[i], <span class="string">""</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(elementsArr[i]).append(<span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">    sb.append(elementsArr[i]);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/151-fan-zhuan-zi-fu-chuan-li-de-dan-ci-shuang-zh-2/">双指针：</a></p><ol><li>倒序遍历字符串 <em>s</em> ，记录单词左右索引边界 <em>i, j</em></li><li>每确定一个单词的边界，则将其添加至单词列表 <em>res</em> ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> {</span><br><span class="line">    s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) != <span class="string">' '</span>) left--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">        sb.append(s, left + <span class="number">1</span>, right + <span class="number">1</span>).append(<span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) == <span class="string">' '</span>) left--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">        right = left; <span class="comment">// right 指向下个单词的尾字符</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></p><p>依旧是两个做法：</p><p>不使用额外空间：整体反转 + 局部反转</p><p><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="左旋转字符串"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="comment">// 局部反转 + 整体反转</span></span><br><span class="line">      <span class="comment">// 反转区间为前n的子串</span></span><br><span class="line">      <span class="comment">// 反转区间为n到末尾的子串</span></span><br><span class="line">      <span class="comment">// 反转整个字符串</span></span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">      swap(sb, <span class="number">0</span>, n);</span><br><span class="line">      swap(sb, n, s.length());</span><br><span class="line">      swap(sb, <span class="number">0</span>, sb.length());</span><br><span class="line">      <span class="keyword">return</span> sb.toString();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">          <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">          sb.setCharAt(left, sb.charAt(right));</span><br><span class="line">          sb.setCharAt(right, temp);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>使用额外空间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">methodOneUserExtraSpace</span><span class="params">(String s, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s.substring(n));</span><br><span class="line">    sb.append(s, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/posts/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/posts/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8">代码随想录-哈希表篇</a><br>感谢支持！</p></div><h1>哈希表 Hash Table</h1><blockquote><a href="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含哈希表的基础知识</blockquote><h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>[] alpha = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; s.length(); i++) {</span><br><span class="line">        alpha[s.charAt(i) - <span class="string">'a'</span>] ++;</span><br><span class="line">        alpha[t.charAt(i) - <span class="string">'a'</span>] --;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(alpha[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p><p>没有什么难点，但是有个用法可以学一下: Java 的 stream： 把set中的值变成array:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = resSet.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">      Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i : nums1) {</span><br><span class="line">          numSet.add(i);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i : nums2) {</span><br><span class="line">          <span class="keyword">if</span> (numSet.contains(i)) {</span><br><span class="line">              resSet.add(i);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="type">int</span>[] res = resSet.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p><p>这道题主要在于识别题干中的 <strong>无限循环</strong>， 即会出现<strong>sum重复出现</strong>的情况 于是题目就变成：<strong>如何快速查找sum是否已经出现过</strong>，即哈希应用题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 由于可能出现 无限循环 即会出现sum重复出现的情况</span></span><br><span class="line">    <span class="comment">// 于是题目就变成：如何快速查找sum是否已经出现过，即哈希应用题；</span></span><br><span class="line">    Set&lt;Integer&gt; sumSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nCopy</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (!sumSet.contains(sum)) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">newN</span> <span class="operator">=</span> nCopy;</span><br><span class="line">        sumSet.add(sum);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (newN &gt; <span class="number">0</span>) {</span><br><span class="line">            sum += (newN % <span class="number">10</span>) * (newN % <span class="number">10</span>);</span><br><span class="line">            newN /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        nCopy = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>缅怀我逝去的青春 <span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">    Map&lt;Integer, Integer&gt; val2Idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> target - cur;</span><br><span class="line">        <span class="keyword">if</span> (val2Idx.containsKey(needNum)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {val2Idx.get(needNum), i};</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            val2Idx.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></p><p>首先非常丑的暴力做法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">brutalForce</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">    <span class="comment">// 非常丑的 暴力： 200^4 = over 10^8 超时</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) {</span><br><span class="line">                    <span class="keyword">if</span> (nums1[i] + nums2[j] + nums3[k] + nums4[l] == <span class="number">0</span>) count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以考虑用时间换空间，借用两数之和的思想我们可以想到哈希表：</p><p>使用哈希表来优化至 O(N^2)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">  <span class="comment">// 哈希表两两分组：</span></span><br><span class="line">  <span class="comment">// nums1 nums2 一组 的所有可能出现的和 存入哈希表</span></span><br><span class="line">  <span class="comment">// nums3 nums4 一组 在哈希表找可能出现的 -(的所有可能出现的和)</span></span><br><span class="line">  <span class="comment">// 哈希可以使其优化到 O(N^2)</span></span><br><span class="line">  Map&lt;Integer, Integer&gt; sum2Count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">          sum2Count.put(sum, sum2Count.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums3[k] + nums4[l];</span><br><span class="line">          <span class="keyword">if</span> (sum2Count.containsKey(-sum)) {</span><br><span class="line">              count += sum2Count.get(-sum);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">      <span class="type">int</span>[] hm = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> r : ransomNote.toCharArray()) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> r - <span class="string">'a'</span>;</span><br><span class="line">          hm[pos] += <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> m : magazine.toCharArray()) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> m - <span class="string">'a'</span>;</span><br><span class="line">          hm[pos] -= <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j : hm) {</span><br><span class="line">          <span class="keyword">if</span> (j &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>写做三数之和但是用哈希表来做会非常麻烦由于涉及到去重的操作。因此双指针会简便许多。具体流程如下：</p><p><img src="/posts/%E5%93%88%E5%B8%8C%E8%A1%A8/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="三数之和过程"></p><p>另外一些关于去重问题的考虑：</p><p>我们有三个数需要去重 nums[i] nums[left] nums[right]：</p><ol><li>i 的去重<ol><li>在 i 入口处就可以跳过：那么问题是我们应该用 <strong>nums[i] == nums[i + 1]</strong> 还是 <strong>nums[i] == nums[i - 1]</strong><ol><li>答案是用 <strong>nums[i] == nums[i - 1]</strong></li><li>考虑用{-1, -1 ,2} 这组数据，如果用<strong>nums[i] == nums[i + 1]</strong> 当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</li></ol></li></ol></li><li>nums[left] nums[right] 的 去重：<ol><li>见代码 4. 处</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) { <span class="comment">// 1. Change the loop condition</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> -num;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[left] + nums[right]; <span class="comment">// 2. Calculate the current sum</span></span><br><span class="line">                <span class="keyword">if</span> (currentSum &lt; needNum) {</span><br><span class="line">                    left++;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (currentSum &gt; needNum) {</span><br><span class="line">                    right--;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">                            nums[i], nums[left], nums[right] <span class="comment">// 3. Use nums[i], nums[left], nums[right] instead of i, left, right</span></span><br><span class="line">                    ));</span><br><span class="line">                    res.add(temp);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4. Handle duplicates for left and right pointers</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5. Move left and right pointers inward</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></p><p>本质上还是三数之和即排序加双指针但是有两个地方需要注意一下看下面的代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) {</span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++) {</span><br><span class="line">              <span class="comment">// 注意这里是 j &gt; i + 1 不能直接 j &gt; 0 否则 case 例如 [2, 2, 2, 2, 2] 会返回空 （毕竟看到2就都过去了）</span></span><br><span class="line">              <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 注意边界，需要用long for case：</span></span><br><span class="line">              <span class="comment">// [1000000000,1000000000,1000000000,1000000000] -294967296</span></span><br><span class="line">              <span class="type">long</span> <span class="variable">sumIJ</span> <span class="operator">=</span> nums[i] + nums[j];</span><br><span class="line">              <span class="type">long</span> <span class="variable">needSum</span> <span class="operator">=</span> target - sumIJ;</span><br><span class="line">              <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                  <span class="type">long</span> <span class="variable">curSum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">                  <span class="keyword">if</span> (curSum &lt; needSum) {</span><br><span class="line">                      left++;</span><br><span class="line">                  } <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; needSum) {</span><br><span class="line">                      right--;</span><br><span class="line">                  } <span class="keyword">else</span> {</span><br><span class="line">                      List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">                              Arrays.asList(nums[i], nums[j], nums[left], nums[right])</span><br><span class="line">                      );</span><br><span class="line">                      res.add(temp);</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                      <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                      left++;</span><br><span class="line">                      right--;</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/%E9%93%BE%E8%A1%A8/"/>
      <url>/posts/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录-链表篇</a><br>感谢支持！</p></div><h1>链表 LinkedList</h1><blockquote><a href="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含链表的基础知识</blockquote><h2 id="题目：">题目：</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a> <br>边界非常多的题目，主要考虑如何更新链表节点的时候不要错误的更新。可以使用printHelper来帮助debug。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node() {</span><br><span class="line">        }</span><br><span class="line">        Node(<span class="type">int</span> val) {</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> {</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= index) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curIdx == index ? cur.val : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = cur;</span><br><span class="line">        cur.prev = head;</span><br><span class="line">        cur.next = headNext;</span><br><span class="line">        headNext.prev = cur;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tailPrev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        tail.prev = cur;</span><br><span class="line">        tailPrev.next = cur;</span><br><span class="line">        cur.prev = tailPrev;</span><br><span class="line">        cur.next = tail;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// System.out.println("add at tail");</span></span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &gt; count) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index == curIdx) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curPrev</span> <span class="operator">=</span> cur.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">needAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            curPrev.next = needAdd;</span><br><span class="line">            needAdd.next = cur;</span><br><span class="line">            needAdd.prev = curPrev;</span><br><span class="line">            cur.prev = needAdd;</span><br><span class="line">        }</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= index) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index == curIdx) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curPrev</span> <span class="operator">=</span> cur.prev;</span><br><span class="line">            curPrev.next = cur.next;</span><br><span class="line">            cur.next.prev = curPrev;</span><br><span class="line">        }</span><br><span class="line">        count--;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a> <br>非常基础的删除链表中的元素题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) {</span><br><span class="line">                prev.next = cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a><br>这道题主要在于如何使用递归：<br>递归实现反转链表常常用来考察递归思想，我这里就用<strong>纯递归</strong>来翻转链表。对于递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 reverse 函数定义是这样的：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。</p><blockquote><p>quote: <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/">Labuladong 的翻转链表集合</a><br>想通递归函数定义后就很好实现了</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">return</span> reverse(head);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span> || cur.next == <span class="literal">null</span>) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(cur.next);</span><br><span class="line">        cur.next.next = cur; <span class="comment">// 这里是为了让head变成tail</span></span><br><span class="line">        cur.next = <span class="literal">null</span>; <span class="comment">// 注意这里要归为null否则会成环</span></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p><p>使用虚拟头节点来大幅简化问题的一道模拟题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">secondNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = secondNode.next;</span><br><span class="line">            secondNode.next = cur;</span><br><span class="line">            prev.next = secondNode;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">// helperPrint(dummyHead.next);</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helperPrint</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dm</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (dm != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(dm.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            dm = dm.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a> <br>写做链表，但其实本质还是双指针 - 快慢指针的一道应用题：<br>如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dmh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dmh.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dmh;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dmh;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="comment">// 先让fast移动k步</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="comment">// System.out.println(fast.val + " " + slow.val);</span></span><br><span class="line">        <span class="keyword">return</span> dmh.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07.链表相交</a><br>其实还是双指针但是要先找长的链表要先移动几步从而可以让两条链表同一起点：<br><img src="/posts/%E9%93%BE%E8%A1%A8/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="链表相交"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curLong</span> <span class="operator">=</span> headA, curShort = headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenLong</span> <span class="operator">=</span> <span class="number">0</span>, lenShort = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curLong != <span class="literal">null</span>) {</span><br><span class="line">            lenLong++;</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curShort != <span class="literal">null</span>) {</span><br><span class="line">            lenShort++;</span><br><span class="line">            curShort = curShort.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        curLong = headA;</span><br><span class="line">        curShort = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// always make sure lenLong and curLong is the longer one</span></span><br><span class="line">        <span class="keyword">if</span> (lenShort &gt; lenLong) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> lenShort;</span><br><span class="line">            lenShort = lenLong;</span><br><span class="line">            lenLong = temp;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curLong;</span><br><span class="line">            curLong = curShort;</span><br><span class="line">            curShort = tempNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> lenLong - lenShort;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) {</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">            gap--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printHelper(curLong);</span></span><br><span class="line">        <span class="comment">// printHelper(curShort);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curLong != <span class="literal">null</span> &amp;&amp; curShort != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (curLong == curShort) <span class="keyword">return</span> curLong;</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">            curShort = curShort.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表II</a><br>考察的其实还是双指针 - 快慢指针，但是加了一点数学。<br>需要做到两点：</p><ol><li><p>判断链表是否含有环</p><ol><li>使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。<br><img src="/posts/%E9%93%BE%E8%A1%A8/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="检查有环"></li></ol></li><li><p>若有环，怎么找环开始的地方</p><ol><li>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。<br><img src="/posts/%E9%93%BE%E8%A1%A8/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif" alt="环的入口"></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">idxStart</span> <span class="operator">=</span> head, meetStart = fast;</span><br><span class="line">                <span class="keyword">while</span> (idxStart != meetStart) {</span><br><span class="line">                    idxStart = idxStart.next;</span><br><span class="line">                    meetStart = meetStart.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> idxStart;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/posts/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>双指针</h1><h2 id="快慢指针：">快慢指针：</h2><p>慢指针用于保存性质，快指针用于探路。[0, 慢指针] 均满足性质</p><p><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a></p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="comment">// brutal force:</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">           <span class="keyword">if</span> (nums[i] == val) {</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; count; j++) {</span><br><span class="line">                   nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">               }</span><br><span class="line">               i -= <span class="number">1</span>;</span><br><span class="line">               count--;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">        <span class="comment">// fast-slow pointers:</span></span><br><span class="line">        <span class="comment">// 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</span></span><br><span class="line">        <span class="comment">// 慢指针：指向更新 新数组下标的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) {</span><br><span class="line">            <span class="keyword">while</span> (fast &lt; nums.length &amp;&amp; nums[fast] == val) {</span><br><span class="line">                fast++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (fast == nums.length) <span class="keyword">break</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">            slow++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="相向双指针">相向双指针</h2><p><a href="https://leetcode.cn/problems/remove-element/">977.有序数组的平方</a></p><p>由于满足性质：如果想要非递减顺序那么数组平方后的最大值一定在两侧并向中间收敛，因此相向双指针</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] twoPointers(<span class="type">int</span>[] nums) {</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt; Math.abs(nums[right])){</span><br><span class="line">            res[k--] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res[k--] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="滑动窗口">滑动窗口</h2><p>框架：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="comment">// 滑动窗口框架：</span></span><br><span class="line">    <span class="comment">// 1. 入</span></span><br><span class="line">    <span class="comment">// 2. 出</span></span><br><span class="line">    <span class="comment">// 3. 记录答案</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">209.长度最小的子数组</a></p><p>窗口内满足题目要求的性质，不断更新并在过程中寻找最小值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">whileLoopVersionSlidingWindow</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; nums.length) {</span><br><span class="line">                sum += nums[right];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res = Math.min(res, right - left + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (left + <span class="number">1</span> &lt; nums.length) {</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forLoopVersionSlidingWindow</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) {</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) {</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>二分查找， Binary Search</h1><blockquote><p><a href="https://leetcode.cn/problems/binary-search/solutions/8337/er-fen-cha-zhao-xiang-jie-by-labuladong/">二分总结 by labuladong</a></p></blockquote><p><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></p><p>二分查找有两个模板：</p><ol><li><p>左闭右闭</p><ol><li><p>leetcode 704:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchCloseInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="comment">// 左闭右闭：我们要考虑右区间的数然后和target比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">                <span class="comment">// 因为接下来要继续判断 left &lt;= right 而 right = mid 一定不为答案</span></span><br><span class="line">                <span class="comment">// 但我们的定义又要求 right 是有意义的因此 right = mid - 1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target){</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>左闭右开</p><ol><li><p>leetcode 704:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchOpenInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">       <span class="comment">// 左闭右开：我们无需考虑右区间的数然后和target比较</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">               <span class="comment">// 此时 我们 用 left &lt; right 保证在下一次不考虑right因此直接用 right = mid 即可</span></span><br><span class="line">               right = mid;</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></li></ol><p>两者方法的本质上的差别是要不要考虑右区间:</p><ol><li>若[left, right] 即 left &lt;= right<ol><li>right = nums.length - 1 &lt;- 很好理解，因为right本身在比较之中因此right = nums.length - 1</li><li>right = mid - 1 &lt;- 因为若 nums[mid] &gt; target 也就是说 right 一定不为答案，且在while中我们会考虑right因为它不为答案我们需要考虑其之前的一个数: right = mid - 1;</li></ol></li><li>若[left, right) 即 left &lt; right:<ol><li>right = nums.length, 同理，因为right本身不含在我们的比较计划中，因此right = nums.length即可</li><li>right = mid &lt;- 因为若 nums[mid] &gt; target 也就是说 right 一定不为答案，且在while中我们<strong>不</strong>会考虑right因为它不为答案我们<strong>不</strong>需要考虑其之前的一个数: right = mid;</li></ol></li></ol></li></ol><h1>总结</h1><p>题型基本可以分成以下几种：</p><ol><li>基本型<ol><li>二分找出答案就可以，不需要过多的去考虑左端点右端点</li></ol></li><li>找边界<ol><li>找到最左/右边的满足条件的值</li><li>比如：[1, 2, 2, 2, 3] 找索引1或3的2</li></ol></li></ol><h2 id="基本">基本</h2><p>默写二分即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) {</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="边界">边界</h2><p>左右边界的区别就在于在找到答案后先不返回而是继续寻找，</p><p>找左边界就不断收紧right，右边界不断收紧left</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-总汇</title>
      <link href="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/"/>
      <url>/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<h1>代码随想录</h1><h2 id="数组">数组</h2><h3 id="例题">例题</h3><p><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a><br>题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。<br>先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。</p><blockquote><p>见 <a href="/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="二分查找">二分查找</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a><br>题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。</p><blockquote><p>见 <a href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/remove-element/">977.有序数组的平方</a><br>题目建议： 本题关键在于理解双指针思想</p><blockquote><p>见 <a href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">209.长度最小的子数组</a><br>题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。</p><blockquote><p>见 <a href="/posts/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59.螺旋矩阵II</a><br>题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">    <span class="comment">// 此题的关键点在于循环不变量</span></span><br><span class="line">    <span class="comment">// 即 每次循环中都要遵循一个准则，</span></span><br><span class="line">    <span class="comment">// 如二分法中的 左闭右闭 或 左闭右开 性质的定义</span></span><br><span class="line">    <span class="comment">// 我们规定左闭右开，即每一行/列的最后一个值交由下一次循环处理：</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">circleCount</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (circleCount &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 处理上边的行：（左到右）</span></span><br><span class="line">        <span class="keyword">for</span> (j = startY; j &lt; n - offset; j++) {</span><br><span class="line">            res[startX][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理右边的列：（上到下）</span></span><br><span class="line">        <span class="keyword">for</span> (i = startX; i &lt; n - offset; i++) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理下边的行：（右到左）</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt; startY; j--) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理左边的列：（下到上）</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt; startX; i--) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line">        offset++;</span><br><span class="line">        circleCount--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        res[startX][startY] = count;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="链表">链表</h2><h3 id="基本知识：">基本知识：</h3><blockquote><p>其是一种通过指针串联在一起的 <strong>线性</strong> 数据结构，每一个节点都包含：<strong>数据域</strong> 和 <strong>指针域</strong>，最后一个节点的指针域指向null, aka 空指针。</p></blockquote><p>常见的包含三种类型：单链表（上述），双链表，循环链表：</p><h4 id="单链表：">单链表：</h4><p>上述，它的指针域只能指向节点的下一个节点。<br><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p><h4 id="双链表：">双链表：</h4><p>每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。因此双链表可以向前以及向后查。<br><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%8F%8C%E9%93%BE%E8%A1%A8.png" alt="双链表"></p><h4 id="循环链表">循环链表</h4><p>链表首尾相连，可以用来解决<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫环</a>的问题<br><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="循环链表"></p><h4 id="存储方式：">存储方式：</h4><ol><li>不是连续分布，instead, 散乱分布</li><li>通过指针链接内存中的各个节点</li></ol><h4 id="定义：">定义：</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="操作">操作</h4><p>删除节点：<br>next指向下一个即可</p><p>添加节点：取消原本的next，指向新的节点，新的节点指向下一个节点。</p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%93%BE%E8%A1%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="链表性能分析"></p><h3 id="总结">总结</h3><blockquote><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p></blockquote><blockquote><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p></blockquote><h3 id="例题：">例题：</h3><blockquote><p>例题详解见 <a href="/posts/%E9%93%BE%E8%A1%A8/" title="链表">链表</a></p></blockquote><p>● 203.移除链表元素<br>● 707.设计链表<br>● 206.反转链表<br>● 24. 两两交换链表中的节点<br>● 19.删除链表的倒数第N个节点<br>● 面试题 02.07. 链表相交<br>● 142.环形链表II</p><h2 id="哈希表">哈希表</h2><h3 id="基本知识：-2">基本知识：</h3><p>即 Hash Table, 又称散列表。<br>哈希表是根据关键码的值而直接进行防卫的数据结构。e.g.数组就是哈希表的一个非常好的应用因为可以通过下标来返回对应值。<br><strong>主要解决的问题：</strong> 快速判断一个元素是否出现在集合里。 <br>值 -&gt; 哈希表 的 <strong>映射</strong> 即为Hash Function aka 哈希函数 \</p><h4 id="哈希函数">哈希函数</h4><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" alt="哈希函数"><br>把学生姓名映射到了哈希表存储的函数过程。通过<strong>hashCode</strong>把<strong>名字转化为数值</strong>，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><blockquote><p>问题1: 如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了 怎么办？</p></blockquote><blockquote><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p></blockquote><blockquote><p>问题2: 如果学生的数量大于哈希表的大小，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p></blockquote><blockquote><p>即哈希碰撞的处理问题</p></blockquote><h4 id="哈希碰撞-Hash-Collisions：">哈希碰撞, Hash Collisions：</h4><blockquote><p>两个值映射到了同一个位置即为Hash Collisions</p></blockquote><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E.png" alt="哈希碰撞"><br>解决方法：</p><ol><li>拉链法</li><li>线性探测法</li></ol><h5 id="拉链法">拉链法</h5><p>从冲突的位置拉一条链表出来：<br><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E6%8B%89%E9%93%BE%E6%B3%95.png" alt="拉链法"><br>需要注意的是链表上的查询需要一个一个查，因此大小很重要。</p><h5 id="线性探测法">线性探测法</h5><blockquote><p>要求 hash table 的大小 <strong>一定</strong> 要大于 data size 因为需要依赖哈希表中的空位来解决碰撞问题。线性探测法要把冲突的元素放在下一个 <strong>空闲的</strong> 位置</p></blockquote><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E7%BA%BF%E6%80%A7%E5%86%B2%E7%AA%81%E6%B3%95.png" alt="线性冲突法"></p><p>图中小王需要放到小李的下面的位置。</p><h4 id="常见的哈希结构：">常见的哈希结构：</h4><p>一般会有以下三种结构：</p><ol><li>数组</li><li>hashset</li><li>hashmap</li></ol><table><thead><tr><th>数据结构</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>HashMap</td><td>哈希表（数组 + 链表/红黑树）</td><td>无序</td><td>键不可重复，值可重复</td><td>可以</td><td>O(1) ~ O(n)</td><td>O(1) ~ O(n)</td></tr><tr><td>HashSet</td><td>基于HashMap实现</td><td>无序</td><td>不可重复</td><td>间接支持</td><td>O(1) ~ O(n)</td><td>O(1) ~ O(n)</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>有序</td><td>键不可重复，值可重复</td><td>可以</td><td>O(log n)</td><td>O(log n)</td></tr></tbody></table><table><thead><tr><th>HashMap</th><th>HashSet</th><th>TreeMap</th></tr></thead><tbody><tr><td>底层实现：哈希表（数组 + 链表/红黑树）</td><td>基于HashMap实现</td><td>红黑树</td></tr><tr><td>是否有序：无序</td><td>无序</td><td>有序</td></tr><tr><td>数值是否可以重复：键不可重复，值可重复</td><td>不可重复</td><td>键不可重复，值可重复</td></tr><tr><td>能否更改数值：可以 通过put()方法更新键对应的值。</td><td>间接支持</td><td>可以通过put()方法更新键对应的值</td></tr><tr><td>查询效率：O(1) ~ O(n)</td><td>O(1) ~ O(n)</td><td>O(log n) 由于红黑树是平衡的</td></tr><tr><td>增删效率：O(1) ~ O(n)</td><td>O(1) ~ O(n)</td><td>O(log n) 由于红黑树是平衡的</td></tr></tbody></table><ol start="3"><li>TreeMap</li></ol><p>底层实现：基于红黑树实现，红黑树是一种自平衡的二叉搜索树。是否有序：保证有序。TreeMap中的元素按照键（Key）的自然顺序或者提供的比较器（Comparator）进行排序。数值是否可以重复：键（Key）不可重复，值（Value）可重复。能否更改数值：可以更改数值。通过put()方法更新键对应的值。查询效率：时间复杂度为O(log n)，其中n为元素数量。由于红黑树是平衡的，查询效率相对较高。增删效率：时间复杂度为O(log n)，其中n为元素数量。由于红黑树具有自平衡特性，增删操作效率相对较高。</p><h3 id="例题-2">例题</h3><blockquote><p>例题详解见 <a href="/posts/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a></p></blockquote><p>● 242.有效的字母异位词</p><p>● 349. 两个数组的交集</p><p>● 202. 快乐数</p><p>● 1. 两数之和</p><p>● 454.四数相加II</p><p>● 383. 赎金信</p><p>● 15. 三数之和</p><p>● 18. 四数之和</p><h3 id="总结-2">总结</h3><ol><li><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。其本质是通过<strong>通过空间换了时间</strong></li><li>经典题目：<ol><li>数组作为哈希表：eg: int[] = new int[26];<ol><li>在<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！这道题目包含小写字母，那么使用数组来做哈希最合适不过。在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！和<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>很像，<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>是求 字符串a 和 字符串b 是否可以相互组成，在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</li></ol></li><li>Set作为哈希表：<ol><li>在<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集 (opens new window)</a>中我们给出了什么时候用数组就不行了，需要用set。这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</li><li><strong>主要因为如下两点：</strong><ol><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ol></li></ol></li><li>Map本身作为哈希表：<ol><li>e g: 两数之和</li><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ol></li></ol></li></ol><h2 id="字符串">字符串</h2><h3 id="总结-3">总结</h3><ol><li>字符串是字符组成的有限序列</li><li>使用方法：<ol><li>双指针：<ol><li>344.反转字符串</li><li>剑指Offer 05.替换空格</li></ol></li><li>反转<ol><li>例题： 541. 反转字符串II</li><li>例题：151.翻转字符串里的单词</li></ol></li><li>KMP</li></ol></li></ol><h3 id="例题-3">例题</h3><blockquote><p>例题详解见 <a href="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串">字符串</a></p></blockquote><p>● 344.反转字符串</p><p>● 541. 反转字符串II</p><p>● 剑指Offer 05.替换空格</p><p>● 151.翻转字符串里的单词</p><p>● 剑指Offer58-II.左旋转字符串</p><p>● 28. 实现 strStr()</p><p>● 459.重复的子字符串</p><h2 id="队列-Queue-and-栈-Stack">队列 (Queue) and 栈 (Stack)</h2><blockquote><p>例题详解见 <a href="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" title="队列和栈">队列和栈</a></p></blockquote><ol><li>队列先进先出 FIFO 栈先进后出 FILO</li></ol><h3 id="Java">Java</h3><p>在 Java 中，栈（Stack）和队列（Queue）是两种常用的数据结构。它们可以通过 Java 集合框架中的类来实现。</p><h4 id="栈（Stack）实现方法：">栈（Stack）实现方法：</h4><p>Java 有一个名为 Stack 的类。但是，由于 Stack 类被认为是过时的，不推荐使用。相反，我们可以使用 Deque（双端队列）来实现栈。以下是使用 Deque 实现栈的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>栈的底层实现是<strong>通过数组或链表</strong>。在这个例子中，我们使用了 LinkedList（链表）作为底层实现。栈的主要操作（push 和 pop）的时间复杂度是 O(1)。</p><h4 id="队列（Queue）实现方法：">队列（Queue）实现方法：</h4><p>Java 提供了 Queue 接口来实现队列。以下是使用 LinkedList 实现队列的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>队列的底层实现可以是数组或链表。在这个例子中，我们使用了 LinkedList（链表）作为底层实现。队列的主要操作（offer 和 poll）的时间复杂度是 O(1)。</p><p>注意：虽然在上面的例子中，我们使用 LinkedList 作为底层实现，但实际上还有其他实现方式，如 ArrayDeque（基于数组的双端队列），它在某些情况下可能比 LinkedList 更高效。另外，Java 还提供了 PriorityQueue（优先队列），其底层实现是基于二叉堆的数据结构，用于实现具有优先级的队列。</p><h4 id="优先队列-Priority-Queue">优先队列 (Priority Queue):</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个整数优先队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; intQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将整数添加到优先队列</span></span><br><span class="line">        intQueue.offer(<span class="number">5</span>);</span><br><span class="line">        intQueue.offer(<span class="number">2</span>);</span><br><span class="line">        intQueue.offer(<span class="number">8</span>);</span><br><span class="line">        intQueue.offer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将整数从优先队列中删除并打印（默认为自然顺序，即升序）</span></span><br><span class="line">        <span class="keyword">while</span> (!intQueue.isEmpty()) {</span><br><span class="line">            System.out.println(intQueue.poll());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个字符串优先队列，使用自定义的 Comparator 对象</span></span><br><span class="line">        PriorityQueue&lt;String&gt; stringQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">StringLengthComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串添加到优先队列</span></span><br><span class="line">        stringQueue.offer(<span class="string">"apple"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"banana"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"cherry"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"date"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串从优先队列中删除并打印（根据字符串长度排序）</span></span><br><span class="line">        <span class="keyword">while</span> (!stringQueue.isEmpty()) {</span><br><span class="line">            System.out.println(stringQueue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的 Comparator 类，按字符串长度进行排序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StringLengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">            <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Comparator in one line:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个字符串优先队列，使用自定义的 Comparator 对象</span></span><br><span class="line">        PriorityQueue&lt;String&gt; stringQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">                <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串添加到优先队列</span></span><br><span class="line">        stringQueue.offer(<span class="string">"apple"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"banana"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"cherry"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"date"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串从优先队列中删除并打印（根据字符串长度排序）</span></span><br><span class="line">        <span class="keyword">while</span> (!stringQueue.isEmpty()) {</span><br><span class="line">            System.out.println(stringQueue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="例题-4">例题</h3><blockquote><p>例题详解见 <a href="/posts/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" title="队列和栈">队列和栈</a></p></blockquote><p>● 232.用栈实现队列</p><p>● 225. 用队列实现栈</p><p>● 20. 有效的括号</p><p>● 1047. 删除字符串中的所有相邻重复项</p><p>● 150. 逆波兰表达式求值</p><p>● 239. 滑动窗口最大值</p><p>● 347.前 K 个高频元素</p><h3 id="总结-4">总结</h3><ol><li>225.用队列实现栈：一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</li></ol><h5 id="栈的应用">栈的应用</h5><ol><li><strong>括号匹配（有效的括号）, 表达式（逆波兰表达式求值），字符串相邻元素去重（删除字符串中的所有相邻重复项）<strong>都是使用</strong>栈</strong>解决的经典问题其核心是<strong>匹配</strong>问题</li></ol><h5 id="队列的应用">队列的应用</h5><ol><li>滑动窗口最大值问题中，队列<strong>没有</strong>必要维护窗口里的所有元素，<strong>只需要</strong>维护有可能成为窗口里<strong>最大值的元素</strong>就可以了，同时<strong>保证队列里的元素数值是由大到小的。</strong></li><li>单调队列 ≠ 优先队列</li><li><strong>单调队列不是一成不变的，而是不同场景不同写法</strong>，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。</li></ol><h5 id="优先队列">优先队列</h5><p><strong>一个披着队列外衣的堆</strong>，优先队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是<strong>大顶堆</strong>，小于等于左右孩子就是<strong>小顶堆</strong>。</p><p>前 K 个高频元素 用到了优先队列</p><h2 id="二叉树">二叉树</h2><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.png" alt="二叉树基本知识"></p><h3 id="二叉树种类">二叉树种类</h3><p>主要有两种：<strong>满二叉树</strong>以及<strong>完全二叉树</strong></p><p>节点的高度：节点到最远叶子节点的最长路径上边的数量。叶子节点高度为0。<br>节点的深度：节点到根节点的路径上边的数量。所有根节点深度为0。<br>树的高度：树的高度等于根节点的高度，等于最远叶子节点的深度。<br>树的深度：树的深度等于树的高度。<br>树的宽度：两个最长路径的叶子节点之间节点数。</p><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8D%E8%AF%8D.webp" alt="二叉树名词"></p><h4 id="满二叉树">满二叉树</h4><p>定义：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为 叶子结点 ）。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值。所有叶子结点必须在同一层上.</p><p>例子：<img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><p>深度为k，有 2 ^ (k-1) 个节点的二叉树</p><h4 id="完全二叉树">完全二叉树</h4><p>除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边</strong>的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。</p><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><p>ps: 优先队列 用到了 堆 而堆就是一个完全二叉树但保证了父子节点的顺序关系</p><h4 id="二叉搜索树">二叉搜索树</h4><p>二叉搜索树，有值，且其是一个有序树。对节点没有要求，对顺序有要求</p><p>有以下三个特点：</p><ul><li>若它的左子树不空，则<strong>左子树上所有结点的值均小于它的根结点</strong>的值；</li><li>若它的右子树不空，则<strong>右子树上所有结点的值均大于它的根结点</strong>的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p><h4 id="平衡二叉搜索树">平衡二叉搜索树</h4><p><strong>平衡二叉查找树</strong>：简称平衡二叉树</p><p>特点：任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logN)</p><p>总结：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="平衡二叉搜索树"></p><h3 id="二叉树的存储方式">二叉树的存储方式</h3><p>两种：</p><ol><li>用<strong>指针</strong>的<strong>链式存储</strong></li></ol><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="链式存储"></p><ol><li>用<strong>数组</strong>的<strong>顺序存储</strong></li></ol><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="顺序存储"></p><p>如果父节点的数组下标是 i，那么它的<strong>左孩子就是 i * 2 + 1</strong>，<strong>右孩子就是 i * 2 + 2</strong>。</p><h3 id="二叉树的遍历">二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p><ol><li><p><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</p><ol><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ol><p>前中后，其实指的就是<strong>中间节点</strong>的<strong>遍历顺序</strong>，前中后序指的就是中间节点的位置：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p><img src="/posts/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="前中后的遍历"></p></li><li><p><strong>广度优先遍历</strong>：一层一层的去遍历。</p><ol><li>层次遍历（迭代法）</li></ol></li></ol><h3 id="二叉树定义-链式存储">二叉树定义(链式存储)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line">  TreeNode() {}</span><br><span class="line">  TreeNode(<span class="type">int</span> val) { <span class="built_in">this</span>.val = val; }</span><br><span class="line">  TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) {</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例题-5">例题</h3><blockquote><p>例题详解见 <a href="/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a></p></blockquote><ul><li>递归遍历<ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul></li><li>迭代遍历</li><li>统一迭代</li><li>层序遍历：<ul><li>102.二叉树的层序遍历</li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图</li><li>637.二叉树的层平均值</li><li>429.N叉树的层序遍历</li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针</li><li>117.填充每个节点的下一个右侧节点指针II</li><li>104.二叉树的最大深度</li><li>111.二叉树的最小深度</li></ul></li><li>226.翻转二叉树</li><li>101.对称二叉树 2</li><li>104.二叉树的最大深度</li><li>559.n叉树的最大深度</li><li>111.二叉树的最小深度</li><li>222.完全二叉树的节点个数</li><li>110.平衡二叉树</li><li>257.二叉树的所有路径</li><li>404.左叶子之和</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 总汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world/"/>
      <url>/posts/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
