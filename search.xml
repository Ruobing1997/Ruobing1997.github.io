<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回溯</title>
      <link href="/2023/04/20/%E5%9B%9E%E6%BA%AF/"/>
      <url>/2023/04/20/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考  <a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">labuladong - 回溯算法框架</a><br>感谢支持！</p></div><h1 id="回溯算法框架"><a href="#回溯算法框架" class="headerlink" title="回溯算法框架"></a>回溯算法框架</h1><p>回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。</p><p>回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong></p><h2 id="关于回溯的撤销"><a href="#关于回溯的撤销" class="headerlink" title="关于回溯的撤销"></a>关于回溯的撤销</h2><p>回溯撤销操作通常在以下情况下执行：</p><ol><li>当你已经完成了<strong>当前层级的所有操作，并且需要返回到上一层级以尝试其他可能性时</strong>。在这种情况下，撤销操作可以帮助你恢复到之前的状态，从而允许你继续探索其他可能的解决方案。</li><li>当你在当前层级上遇到了一个<strong>不满足约束条件的解时</strong>。在这种情况下，你需要撤销在这个解上所做的操作，以便回到之前的状态并尝试其他选择。</li></ol><p>在递归算法中，回溯撤销操作通常在递归调用之后执行。这是因为，在递归调用返回时，你已经完成了该层级的所有操作，现在需要恢复到之前的状态以便探索其他可能性。</p><p>回溯撤销操作应在完成<strong>当前层级的所有操作</strong>后执行，以便在回溯过程中恢复到之前的状态并尝试其他可能性。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>为了解决回溯的相关问题，就是解决一个决策树的遍历</p><p>站在回溯树的一个节点上，需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure><p><strong>核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong></p><h2 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h2><p>回溯问题的两个典型例子就是 <strong>全排列</strong> 以及 <strong>N皇后</strong></p><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><p><img src="/2023/04/20/%E5%9B%9E%E6%BA%AF/%E5%85%A8%E6%8E%92%E5%88%97-%E8%B7%AF%E5%BE%84.jpeg" alt="全排列-路径"></p><p><strong><code>[2]</code> 就是「路径」，记录你已经做过的选择；</strong></p><p><strong><code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；</strong></p><p><strong>「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候</strong>。</p><p><img src="/2023/04/20/%E5%9B%9E%E6%BA%AF/%E5%85%A8%E6%8E%92%E5%88%97-%E5%81%9A%E9%80%89%E6%8B%A9.jpeg" alt="全排列-做选择"></p><h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h3>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2023/04/17/%E9%80%92%E5%BD%92/"/>
      <url>/2023/04/17/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>递归 is all I hate </p></div><h1 id="递归🐢"><a href="#递归🐢" class="headerlink" title="递归🐢"></a>递归🐢</h1><blockquote><p>递归讲究的就是一个自信，<strong>相信自己的函数定义和它的return值</strong>，做下去，wow amazing，你就得到了结果</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftSwappedResult</span> <span class="operator">=</span> dfs(cur.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightSwappedResult</span> <span class="operator">=</span> dfs(cur.right);</span><br><span class="line">    cur.left = rightSwappedResult;</span><br><span class="line">    cur.right = leftSwappedResult;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming-Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-二叉树篇</a> 以及 <a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/">labuladong - 二叉树</a><br>感谢支持！</p></div><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义概念："><a href="#定义概念：" class="headerlink" title="定义概念："></a>定义概念：</h2><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6.png" alt="二叉树的高度和深度"></p><p>高度：二叉树中任意一个节点到<strong>叶子节点</strong>的距离 &lt;- 经常用<strong>后序遍历</strong>解决问题</p><ul><li>通过将子节点的高度返回给父节点父节点高度 +1 即可解决问题</li></ul><p>深度：二叉树中任意一个节点到<strong>根节点</strong>的距离 &lt;- 经常用<strong>前序遍历</strong>解决问题</p><ul><li>一往下就深度就 +1</li></ul><h2 id="思维方法："><a href="#思维方法：" class="headerlink" title="思维方法："></a>思维方法：</h2><p>遇到一道二叉树的题目时的<strong>通用思考</strong>过程是：</p><p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。</p><p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p><p>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</p><p>关于后序遍历：</p><p>后序遍历好在：前序位置的代码只能从<strong>函数参数中获取父节点传递来的数据</strong>，而后序位置的代码<strong>不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</strong></p><p><strong>一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><blockquote><p>🤣 一入递归深似海，走到尽头出不来 :P</p></blockquote><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul><p>核心就是 traverse function：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">traversalMain</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    traverse(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode cur, List&lt;Integer&gt; res)</span> {</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 前序遍历位置</span></span><br><span class="line">  traverse(cur.left, res);</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 中序遍历位置</span></span><br><span class="line">  traverse(cur.right, res);</span><br><span class="line">  <span class="comment">// res.add(cur.val); &lt;- 后序遍历位置</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><p>其实就是用迭代法实现前中后序的遍历</p><blockquote><p>前序 中左右 </p><p>中序 左中右 </p><p>后序 左右中</p></blockquote><p>前序和后序可以归类为一种而中序略微有些差别：</p><p>前序和中序可以被归类为 类似于层序遍历的遍历：</p><p>对于前序来说由于我们需要的结果为 中左右 那么借助栈的先进后出的性质我们需要放入中/根 (pop) 右左：</p><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法：前序需要满足 中左右 的遍历顺序</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (dq.peekLast() == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) dq.addLast(cur.right);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) dq.addLast(cur.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于后序遍历来说，我们只需要完成如下的操作：</p><ol><li>调整层里的右左（前序） -&gt; 左右（后序）</li><li>反转结果即可</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法：后序 需要满足 左右中 的遍历顺序</span></span><br><span class="line">    <span class="comment">// 前序 中左右</span></span><br><span class="line">    <span class="comment">// 通过 中右左 -&gt; 左右中 来达成效果</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (dq.peekLast() == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) dq.addLast(cur.left);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) dq.addLast(cur.right);</span><br><span class="line">    }</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>中序遍历会有所不同，因为现在的中不在是上一层的根，而是需要左节点遍历完成后的祖先。因此，我们需要一个额外的遍历的指针来记录visit过的节点：</p><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树中序遍历（迭代法）"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// 迭代法的中序遍历：左中右</span></span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// cur 这里只作为一个跟踪的指针用，换成root也没有区别。</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty() || cur != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            dq.addLast(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cur = dq.pollLast();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统一后的迭代遍历"><a href="#统一后的迭代遍历" class="headerlink" title="统一后的迭代遍历"></a>统一后的迭代遍历</h3><p>为了风格统一，来用以下的方法来做三序的迭代法本质上是用了<strong>标记法</strong>：<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong></p><p>中序遍历的标记法例子：</p><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif" alt="中序遍历迭代（统一写法）"></p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>核心：使用<strong>队列</strong> 因为有<strong>先入先出</strong>的性质 + 用 size 来维护队列（当前层的元素数量，从而保证元素是固定于这一层）</p><blockquote><p>队列和栈真是好兄弟，队列来做BFS，栈来做DFS <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="二叉树的层序遍历"></p><ol><li>根节点入队</li><li>loop while(!q.isempty())</li><li>int len = q.size()</li><li>while (Len– &gt; 0)</li></ol><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><ul><li>102.二叉树的层序遍历</li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图</li><li>637.二叉树的层平均值</li><li>429.N叉树的层序遍历</li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针</li><li>117.填充每个节点的下一个右侧节点指针II</li><li>104.二叉树的最大深度</li><li>111.二叉树的最小深度</li></ul><blockquote><p>太多了… 仅需几道题详解</p></blockquote><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root); <span class="comment">// &lt;- 头节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size(); <span class="comment">// &lt;- get 当前的 size</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            cur.add(top.val);</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="literal">null</span>) dq.addLast(top.left);</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="literal">null</span>) dq.addLast(top.right);</span><br><span class="line">        }</span><br><span class="line">        res.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><p>唯一的区别就是用linkedlist把一层的结果加到头部即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dq.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            cur.add(curNode.val);</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="literal">null</span>) dq.add(curNode.left);</span><br><span class="line">            <span class="keyword">if</span> (curNode.right != <span class="literal">null</span>) dq.add(curNode.right);</span><br><span class="line">        }</span><br><span class="line">        res.addFirst(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="树计算深度类问题："><a href="#树计算深度类问题：" class="headerlink" title="树计算深度类问题："></a>树计算深度类问题：</h3><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><h5 id="方法1-DFS"><a href="#方法1-DFS" class="headerlink" title="方法1 DFS:"></a>方法1 DFS:</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>  dfsCompose(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfsCompose</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="comment">// 函数定义：返回当前树的最小深度 注意最小深度是根结点到叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这道题递归条件里分为三种情况</span></span><br><span class="line">    <span class="comment">//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> minDepth(cur.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> minDepth(cur.right);</span><br><span class="line">    <span class="comment">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span> || cur.right == <span class="literal">null</span>) <span class="keyword">return</span> m1 + m2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(m1,m2) + <span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfsCompose</span><span class="params">(TreeNode cur, <span class="type">int</span> curDepth)</span> {</span><br><span class="line">    <span class="comment">// 函数定义：返回当前树的最小深度 注意最小深度是根结点到叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) <span class="keyword">return</span> curDepth;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMin</span> <span class="operator">=</span> dfsCompose(cur.left, curDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMin</span> <span class="operator">=</span> dfsCompose(cur.right, curDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.min(leftMin, rightMin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="方法2-BFS"><a href="#方法2-BFS" class="headerlink" title="方法2 BFS"></a>方法2 BFS</h5><p>第一版：（⚠️有瑕疵）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> bfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    dq.addLast(cur);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">levelCur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left == <span class="literal">null</span> &amp;&amp; levelCur.right == <span class="literal">null</span>) min = Math.min(min, height);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left != <span class="literal">null</span>) dq.addLast(levelCur.left);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.right != <span class="literal">null</span>) dq.addLast(levelCur.right);</span><br><span class="line">        }</span><br><span class="line">        height++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个版本有瑕疵的原因是BFS<strong>第一个碰到的叶子结点一定是最短的</strong>。因为他是一层一层下去的</p></blockquote><p>因此无需维护min, 可以直接return 所以可以优化为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> bfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    Deque&lt;TreeNode&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    dq.addLast(cur);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dq.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">levelCur</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left == <span class="literal">null</span> &amp;&amp; levelCur.right == <span class="literal">null</span>) <span class="keyword">return</span> height;</span><br><span class="line">            <span class="keyword">if</span> (levelCur.left != <span class="literal">null</span>) dq.addLast(levelCur.left);</span><br><span class="line">            <span class="keyword">if</span> (levelCur.right != <span class="literal">null</span>) dq.addLast(levelCur.right);</span><br><span class="line">        }</span><br><span class="line">        height++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化前：</p><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6BFS%E4%BC%98%E5%8C%96%E5%89%8D.png" alt="111. 二叉树的最小深度BFS优化前.png"></p><p>优化后：</p><p><img src="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6BFS%E4%BC%98%E5%8C%96%E5%90%8E.png" alt="111. 二叉树的最小深度BFS优化后.png"></p><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h5 id="dfs的两个解法："><a href="#dfs的两个解法：" class="headerlink" title="dfs的两个解法："></a>dfs的两个解法：</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MIN_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> getMax(cur.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> getMax(cur.right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) {</span><br><span class="line">        res = Math.max(depth, res);</span><br><span class="line">    }</span><br><span class="line">    traverse(cur.left);</span><br><span class="line">    traverse(cur.right);</span><br><span class="line">    depth--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><h5 id="回溯：方法1"><a href="#回溯：方法1" class="headerlink" title="回溯：方法1"></a>回溯：方法1</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    traverse(root); </span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.children.size() == <span class="number">0</span>) {</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) {</span><br><span class="line">        depth++;</span><br><span class="line">        traverse(child);</span><br><span class="line">        depth--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="回溯：格式2"><a href="#回溯：格式2" class="headerlink" title="回溯：格式2"></a>回溯：格式2</h5><p>⚠️注意depth的位置以及res在maxDepth中return的变化⚠️</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    traverse(root); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.children.size() == <span class="number">0</span>) {</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) {</span><br><span class="line">        traverse(child);</span><br><span class="line">    }</span><br><span class="line">    depth--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求节点和的问题"><a href="#求节点和的问题" class="headerlink" title="求节点和的问题"></a>求节点和的问题</h3><h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>此题可以分解为三个问题：</p><ol><li>求所有节点的和, 很简单，就是左右树的节点和加root节点</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历求所有节点值之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfTrees</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">leave</span> <span class="operator">=</span> root.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfTrees(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfTrees(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + leave;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>求所有叶子结点的和, 也很简单，就只是多了一个判断叶子结点的条件：<code>if (root.left == null &amp;&amp; root.right == null)</code></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历求所有叶子节点值之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">        leave = root.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeaves(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + leave;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>求左叶子结点的和, 也不难，无非是分成两步：<ol><li>该节点是其父节点的左子节点。</li><li>该节点是一个叶子节点，即它没有左右子节点。</li></ol></li></ol><p>即：<code>if (cur.left != null &amp;&amp; cur.left.left == null &amp;&amp; cur.left.right == null)</code></p><p>因此借助二叉树的思维框架我们可以用traverse + 额外变量的方式来解决问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; cur.left.left == <span class="literal">null</span> &amp;&amp; cur.left.right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// cur.left 是一个左叶子节点</span></span><br><span class="line">        sum += cur.left.val;</span><br><span class="line">    }</span><br><span class="line">    dfs(cur.left);</span><br><span class="line">    dfs(cur.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>二叉树的递归分为<strong>「遍历」</strong>和<strong>「分解问题」</strong>两种思维模式，这道题可以同时使用两种思维模式。</p><h4 id="方法1-递归-分解问题"><a href="#方法1-递归-分解问题" class="headerlink" title="方法1: 递归 - 分解问题"></a>方法1: 递归 - 分解问题</h4><p>第一个自己写出来的递归，‼️终于‼️感受到为什么说递归讲究的就是一个自信 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfsQuestionsDivide</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftSwappedResult</span> <span class="operator">=</span> dfsQuestionsDivide(cur.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightSwappedResult</span> <span class="operator">=</span> dfsQuestionsDivide(cur.right);</span><br><span class="line">    cur.left = rightSwappedResult;</span><br><span class="line">    cur.right = leftSwappedResult;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="方法2-递归-遍历"><a href="#方法2-递归-遍历" class="headerlink" title="方法2: 递归 - 遍历"></a>方法2: 递归 - 遍历</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> dfsTraverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">dfsTraverse</span><span class="params">(TreeNode cur)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.left;</span><br><span class="line">    cur.left = cur.right;</span><br><span class="line">    cur.right = tmp;</span><br><span class="line"></span><br><span class="line">    dfsTraverse(cur.left);</span><br><span class="line">    dfsTraverse(cur.right);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>这是一道backtrack的题，这里我先给出代码再解释为什么 root.left后没有 <strong>显性</strong> 的removeLast() 操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="comment">// backtrack</span></span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; nodesList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backtrack(root, res, nodesList);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(TreeNode root, List&lt;String&gt; res, LinkedList&lt;String&gt; nodesList)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">        nodesList.addLast(String.valueOf(root.val));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">"-&gt;"</span>, nodesList);</span><br><span class="line">        res.add(s);</span><br><span class="line">        nodesList.removeLast();</span><br><span class="line">    }</span><br><span class="line">    nodesList.addLast(String.valueOf(root.val));</span><br><span class="line">    backtrack(root.left, res, nodesList);</span><br><span class="line">    backtrack(root.right, res, nodesList);</span><br><span class="line">    <span class="comment">// 撤销操作</span></span><br><span class="line">    nodesList.removeLast();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设我们有以下二叉树：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    1</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  2   3</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">4   5</span></span><br></pre></td></tr></tbody></table></figure><p>当我们调用 <code>traverse(root)</code> 时，执行顺序如下：</p><ol><li>添加 1 到 <code>path</code>，此时 <code>path = [1]</code>。</li><li>调用 <code>traverse(root.left)</code> 以遍历左子树（节点 2）。<ol><li>添加 2 到 <code>path</code>，此时 <code>path = [1, 2]</code>。 </li><li>调用 <code>traverse(root.left)</code> 以遍历左子树（节点 4）。 <ol><li>添加 4 到 <code>path</code>，此时 <code>path = [1, 2, 4]</code>。</li><li>4 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 4，此时 <code>path = [1, 2]</code>。</li><li>返回上一层递归调用（节点 2）。</li></ol></li><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 5）。 <ol><li>添加 5 到 <code>path</code>，此时 <code>path = [1, 2, 5]</code>。 ii. 5 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 5，此时 <code>path = [1, 2]</code>。 iii. 返回上一层递归调用（节点 2）。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 2，此时 <code>path = [1]</code>。</li></ol></li><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 3）。 <ol><li>添加 3 到 <code>path</code>，此时 <code>path = [1, 3]</code>。 </li><li>3 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 3，此时 <code>path = [1]</code>。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 1，此时 <code>path</code> 为空。</li></ol><p>在这个例子中，我们可以看到，在每次递归调用返回时，<code>path.removeLast()</code> 都会被执行。这样，我们可以确保在遍历过程中，<code>path</code> 变量始终正确地表示从根节点到当前节点的路径。在遍历左子树（节点 2）时，<code>path.removeLast()</code> 被执行了两次：一次是在遍历节点 4 后，另一次是在遍历节点 5 后。这样，我们可以确保在遍历右子树（节点 3）之前，<code>path</code> 变量已经从左子树遍历的影响中恢复。这可以确保在继续遍历过程时，<code>path</code> 变量正确地表示从根节点到当前节点的路径。</p><p>继续遍历右子树（节点 3）：</p><ol><li>调用 <code>traverse(root.right)</code> 以遍历右子树（节点 3）。<ol><li>添加 3 到 <code>path</code>，此时 <code>path = [1, 3]</code>。 </li><li>3 是叶子节点，将 <code>path</code> 添加到 <code>res</code>，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 3，此时 <code>path = [1]</code>。</li></ol></li><li>在后序遍历位置，执行 <code>path.removeLast()</code>，从 <code>path</code> 中移除 1，此时 <code>path</code> 为空。</li></ol><p>现在，整个树的遍历已经完成，<code>res</code> 变量包含了所有从根节点到叶子节点的路径，即 <code>["1-&gt;2-&gt;4", "1-&gt;2-&gt;5", "1-&gt;3"]</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列和单调栈</title>
      <link href="/2023/04/16/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/04/16/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列和单调栈"><a href="#单调队列和单调栈" class="headerlink" title="单调队列和单调栈"></a>单调队列和单调栈</h1><p>概念：DIY的一个队列，队列中的元素是单调递增或者单调递减</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>需要自己设计一个数据结构支持：</p><ol><li>Pop()</li><li>Push()</li><li>getMaxValue()</li></ol><p>数据结构内部<strong>单调递减</strong>，也就是单调队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">MonolithicDownQueue</span> <span class="variable">monolithicDownQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonolithicDownQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; k) {</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) {</span><br><span class="line">            monolithicDownQueue.pop(nums[left]);</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonolithicDownQueue</span> {</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() == value) {</span><br><span class="line">                dq.removeFirst();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="comment">// 保证数据结构内部单调递减即碰见新元素时，如果新元素大于队尾元素，移除队尾的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; value &gt; dq.peekLast()) {</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            }</span><br><span class="line">            dq.addLast(value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> dq.isEmpty() ? <span class="number">0</span> : dq.peekFirst();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列和单调栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java碎碎念</title>
      <link href="/2023/04/15/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2023/04/15/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>收集些容易忽视的Java的用法</p></div><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Collections-Interface"><a href="#Collections-Interface" class="headerlink" title="Collections Interface"></a>Collections Interface</h2><p><img src="/2023/04/15/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/Collections-in-Java.png" alt="Collections Interface"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList Methods:</p><table><thead><tr><th>Methods</th><th>Description</th></tr></thead><tbody><tr><td>addFirst()</td><td>Adds an item to the beginning of the list.</td></tr><tr><td>addLast()</td><td>Add an item to the end of the list</td></tr><tr><td>removeFirst()</td><td>Remove an item from the beginning of the list.</td></tr><tr><td>removeLast()</td><td>Remove an item from the end of the list</td></tr><tr><td>getFirst()</td><td>Get the item at the beginning of the list</td></tr><tr><td>getLast()</td><td>Get the item at the end of the list</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h4 id="LinkedList-实现"><a href="#LinkedList-实现" class="headerlink" title="LinkedList 实现"></a>LinkedList 实现</h4><h4 id="ArrayDeque-实现"><a href="#ArrayDeque-实现" class="headerlink" title="ArrayDeque 实现"></a>ArrayDeque 实现</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实就是array和linkedlist区别，大部分时间里array会比较快。但是当添加元素时超了array的容积，则ArrayDeque需要resize.</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream()"></a>Stream()</h2><ol><li>List to array one line:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List.stream().mapToInt(i -&gt; i).toArray();</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>Print elements in an int[]:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(ret).forEach(a -&gt; System.out.print(a + <span class="string">" "</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> pair.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> pair.getValue();</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming-Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列和栈</title>
      <link href="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
      <url>/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-队列与栈篇</a><br>感谢支持！</p></div><h1 id="队列-Queue-and-栈-Stack"><a href="#队列-Queue-and-栈-Stack" class="headerlink" title="队列 (Queue) and 栈 (Stack)"></a>队列 (Queue) and 栈 (Stack)</h1><blockquote><a href="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含队列和栈的基础知识</blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>双栈实现队列题</p><p>很简单，一个栈负责暂时储存元素，另一个栈若为空的时候从第一个栈拿元素 aka <strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.gif" alt="232.用栈实现队列"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; dq1, dq2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> {</span><br><span class="line">        dq1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dq2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        dq1.push(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        count--;</span><br><span class="line">        moveElements();</span><br><span class="line">        <span class="keyword">return</span> dq2.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveElements</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (dq2.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!dq1.isEmpty()) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dq1.pop();</span><br><span class="line">                dq2.push(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        moveElements();</span><br><span class="line">        <span class="keyword">return</span> dq2.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>用两个数组时，核心在于一个辅助数组用于置换，从而始终保持有一个数组的头为最后一个进来的元素，以达到FILO的结果：</p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/225_%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225_队列实现栈"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; q1, q2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        q2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty()) {</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题也可以只用一个Queue来做：</p><p>其实相当于形成了个循环队列，只不过开头一定是新进来的那个元素</p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/225_%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88_%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E7%89%88.gif" alt="225-OneQueueVer"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        q.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] s2Char = s.toCharArray();</span><br><span class="line">        Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s2Char) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                dq.push(<span class="string">')'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'{'</span>) {</span><br><span class="line">                dq.push(<span class="string">'}'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) {</span><br><span class="line">                dq.push(<span class="string">']'</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (dq.isEmpty() || dq.peek() != c) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                dq.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dq.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><p><strong>本题有点像祖玛游戏</strong></p><blockquote><p>Credit to: <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/solution/dong-hua-tu-jie-yong-zhan-bao-cun-wei-be-4u5w/">LC详解 - 负雪明烛</a></p></blockquote><p>本题要点：</p><ol><li>两个相邻且相同字符会被删除。（注意：是两个！）</li><li>删除字符串中两个相邻并且相同的字符可能会产生新的相邻并且相同的字符。 比如对于 abba ，删除 bb 之后， aa 会碰到一起，也需要继续把 aa 删掉。</li></ol><p>所以：</p><p>① 并不能一次删除操作就能达到目的；而应该在每次删除一对相邻且相同的字符之后、再看新的字符串是否存在相邻且相同的一对字符。</p><p>② 如果存在多组的相邻且相同的字符时，先删除哪一对对最终结果是没有影响的。比如对于 abbacca ，无论先删除 bb 还是先删除 cc 最终的结果都是 a 。</p><p>通过 ① 我们得出：需要用一个数据结构缓存结果，这个数据结构应该是<strong>后进先出</strong>，也就是<strong>栈</strong>！<br>通过 ② 我们得出：可以从左到右遍历一次输入字符串 S 的所有字符 Si，把 Si 跟栈顶元素比较</p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/1047_%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047_删除重复项"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">char</span>[] s2Char = s.toCharArray();</span><br><span class="line">    Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s2Char) {</span><br><span class="line">        <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; c == dq.peekLast()) {</span><br><span class="line">            dq.removeLast();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dq.addLast(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) {</span><br><span class="line">        sb.append(dq.removeFirst());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p>这是一道关于<strong>「表达式计算」</strong>的题目。所有的<strong>「表达式计算」</strong>问题都离不开<strong>「栈」</strong>。</p><p>思路总结：遇到数字压栈，遇到符号取出数字，计算，压栈更新后的数字。</p><p><img src="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><p>用Deque：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) {</span><br><span class="line">        <span class="keyword">if</span> (token.equals(<span class="string">"+"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left + right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"*"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left * right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"-"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left - right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"/"</span>)) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(left / right);</span><br><span class="line">            dq.addLast(res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dq.addLast(token);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Integer.parseInt(dq.removeLast());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数组模拟栈：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] ts)</span> {</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[ts.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : ts) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"+-*/"</span>.contains(s)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> d[tt--], a = d[tt--];</span><br><span class="line">                d[++tt] = calc(a, b, s);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                d[++tt] = Integer.parseInt(s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> d[tt];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String op)</span> {</span><br><span class="line">        <span class="keyword">if</span> (op.equals(<span class="string">"+"</span>)) <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"-"</span>)) <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>)) <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"/"</span>)) <span class="keyword">return</span> a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>两个难点：</p><ol><li>我们需要求 k 窗口内的 最大值</li><li>不能够使用优先队列<ol><li>因为优先队列排序后，要pop的元素可能不是排序后的元素了。<ol><li>比如：1 3 -1 -3</li><li>队列中 3 1 -1 -3 此时会pop 3 而不是 1</li></ol></li></ol></li></ol><p>因此需要自己设计一个数据结构支持：</p><ol><li>Pop()</li><li>Push()</li><li>getMaxValue()</li><li>数据结构内部单调递减，也就是 <a href="/2023/04/16/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/" title="单调队列和单调栈">单调队列和单调栈</a></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">MonolithicDownQueue</span> <span class="variable">monolithicDownQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonolithicDownQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; k) {</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) {</span><br><span class="line">            monolithicDownQueue.pop(nums[left]);</span><br><span class="line">            monolithicDownQueue.push(nums[right]);</span><br><span class="line">            res.add(monolithicDownQueue.getMaxValue());</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonolithicDownQueue</span> {</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() == value) {</span><br><span class="line">                dq.removeFirst();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="comment">// 保证数据结构内部单调递减即碰见新元素时，如果新元素大于队尾元素，移除队尾的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; value &gt; dq.peekLast()) {</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            }</span><br><span class="line">            dq.addLast(value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> dq.isEmpty() ? <span class="number">0</span> : dq.peekFirst();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>本题用到了 <strong>优先队列</strong> + <strong>Map</strong></p><blockquote><p>Highlight: 用的是<strong>小顶堆</strong>，这样就不用维护所有的值而只维护<strong>k个</strong>元素，因为是不断把最小的元素pop()出去, <strong>因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong> 从而由 nlogn -&gt; nlogk。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">    Map&lt;Integer, Integer&gt; num2Count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">        num2Count.put(i, num2Count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; numEntry : num2Count.entrySet()) {</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[]{numEntry.getKey(), numEntry.getValue()};</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &lt; k) {</span><br><span class="line">            pq.add(cur);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 确定pop出去的是相对小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (pq.peek()[<span class="number">1</span>] &gt;= numEntry.getValue()) <span class="keyword">continue</span>;</span><br><span class="line">            pq.poll();</span><br><span class="line">            pq.add(cur);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//                pq.forEach(a -&gt; System.out.print(a[0] + " " + a[1]));</span></span><br><span class="line"><span class="comment">//                System.out.println();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        ret[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列和栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://www.programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html">代码随想录-字符串篇</a><br>感谢支持！</p></div><h1 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h1><blockquote><a href="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含字符串的基础知识</blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></p><p>非常基本的双指针应用题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        <span class="comment">// 双指针swap:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            swap(s, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></p><p>本题难点在于问题转化：题干上：</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p>如果直接模拟这两条规则的话会比较麻烦，但是其实这两条可以等价转化为如下的问题：</p><p><strong>当剩余元素多于k个，反转前k个 (i, i + k)，否则反转后k个 (i, n - 1)</strong></p><p>那么问题迎刃而解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">      <span class="type">char</span>[] s2char = s.toCharArray();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// methodOne(k, s2char);</span></span><br><span class="line">      <span class="comment">// methodTwo:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; s2char.length; left += <span class="number">2</span> * k) {</span><br><span class="line">          swap(s2char, left, Math.min(left + k, s2char.length) - <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> String.valueOf(s2char);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">(<span class="type">int</span> k, <span class="type">char</span>[] s2char)</span> {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; s2char.length; left = left + k * <span class="number">2</span>) {</span><br><span class="line">          <span class="keyword">if</span> (left + k &lt;= s2char.length) {</span><br><span class="line">              <span class="comment">// 元素在length里面不会取空</span></span><br><span class="line">              swap(s2char, left, left + k - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="comment">// 若少于k个，翻转剩余全部字符</span></span><br><span class="line">          swap(s2char, left, s2char.length - <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">char</span>[] s2char, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">          <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s2char[left];</span><br><span class="line">          s2char[left] = s2char[right];</span><br><span class="line">          s2char[right] = temp;</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><p>此题的解法有两个分别是：</p><ol><li><p>用到额外的空间 （非常简单，直接秒杀）</p><ol><li>这里简单提一下StringBuilder 和 StringBuffer的区别</li><li>StringBuilder 单线程，会快一些</li></ol></li><li><p>不用额外的空间，原地修改</p><p><img src="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.gif" alt="替换空格-原地修改"></p><ol><li><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></li><li>这么做有两个好处：<ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) {</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="string">' '</span>) sb.append(<span class="string">" "</span>).append(<span class="string">" "</span>);</span><br><span class="line">          }</span><br><span class="line">          <span class="comment">// older length</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">          s = s + sb;</span><br><span class="line">          <span class="comment">// newer length</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">          <span class="type">char</span>[] sAsChar = s.toCharArray();</span><br><span class="line">          <span class="keyword">while</span> (fast &gt;= <span class="number">0</span>) {</span><br><span class="line">              <span class="keyword">if</span> (sAsChar[fast] != <span class="string">' '</span>) {</span><br><span class="line">                  sAsChar[slow] = sAsChar[fast];</span><br><span class="line">                  fast--;</span><br><span class="line">                  slow--;</span><br><span class="line">              } <span class="keyword">else</span> {</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'0'</span>;</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'2'</span>;</span><br><span class="line">                  sAsChar[slow--] = <span class="string">'%'</span>;</span><br><span class="line">                  fast--;</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> String.valueOf(sAsChar);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> String <span class="title function_">methodOneWithExtraSpace</span><span class="params">(String s)</span> {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) {</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="string">' '</span>) {</span><br><span class="line">                  sb.append(<span class="string">"%20"</span>);</span><br><span class="line">              } <span class="keyword">else</span> {</span><br><span class="line">                  sb.append(c);</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> sb.toString();</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p><p>依旧是两个解法：</p><ol><li><p>使用库函数：</p><ol><li>String.trim() <ol><li><img src="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/String_Trim.png" alt="String.trim()"></li><li>eliminates leading and trailing spaces.</li><li>Time: <strong>O(N)</strong></li></ol></li><li>String.split(String reges, int limit)<ol><li>breaks a given string around matches of the given regular expression</li><li>Time: <strong>O(N)</strong></li></ol></li><li><img src="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2LC%E9%A2%98%E8%A7%A3.png" alt="151_LC_解法"></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">methodOneUseLibrary</span><span class="params">(String s)</span> {</span><br><span class="line">    String[] elementsArr = s.trim().split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//            Arrays.stream(elementsArr).forEach(e -&gt; System.out.println(e + "/"));</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = elementsArr.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(elementsArr[i], <span class="string">""</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(elementsArr[i]).append(<span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">    sb.append(elementsArr[i]);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/151-fan-zhuan-zi-fu-chuan-li-de-dan-ci-shuang-zh-2/">双指针：</a></p><ol><li>倒序遍历字符串 <em>s</em> ，记录单词左右索引边界 <em>i, j</em></li><li>每确定一个单词的边界，则将其添加至单词列表 <em>res</em> ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> {</span><br><span class="line">    s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) != <span class="string">' '</span>) left--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">        sb.append(s, left + <span class="number">1</span>, right + <span class="number">1</span>).append(<span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) == <span class="string">' '</span>) left--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">        right = left; <span class="comment">// right 指向下个单词的尾字符</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></p><p>依旧是两个做法：</p><p>不使用额外空间：整体反转 + 局部反转</p><p><img src="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="左旋转字符串"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="comment">// 局部反转 + 整体反转</span></span><br><span class="line">      <span class="comment">// 反转区间为前n的子串</span></span><br><span class="line">      <span class="comment">// 反转区间为n到末尾的子串</span></span><br><span class="line">      <span class="comment">// 反转整个字符串</span></span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">      swap(sb, <span class="number">0</span>, n);</span><br><span class="line">      swap(sb, n, s.length());</span><br><span class="line">      swap(sb, <span class="number">0</span>, sb.length());</span><br><span class="line">      <span class="keyword">return</span> sb.toString();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">          <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">          sb.setCharAt(left, sb.charAt(right));</span><br><span class="line">          sb.setCharAt(right, temp);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>使用额外空间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">methodOneUserExtraSpace</span><span class="params">(String s, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s.substring(n));</span><br><span class="line">    sb.append(s, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8">代码随想录-哈希表篇</a><br>感谢支持！</p></div><h1 id="哈希表-Hash-Table"><a href="#哈希表-Hash-Table" class="headerlink" title="哈希表 Hash Table"></a>哈希表 Hash Table</h1><blockquote><a href="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含哈希表的基础知识</blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>[] alpha = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; s.length(); i++) {</span><br><span class="line">        alpha[s.charAt(i) - <span class="string">'a'</span>] ++;</span><br><span class="line">        alpha[t.charAt(i) - <span class="string">'a'</span>] --;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(alpha[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p><p>没有什么难点，但是有个用法可以学一下: Java 的 stream： 把set中的值变成array:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = resSet.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">      Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i : nums1) {</span><br><span class="line">          numSet.add(i);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i : nums2) {</span><br><span class="line">          <span class="keyword">if</span> (numSet.contains(i)) {</span><br><span class="line">              resSet.add(i);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="type">int</span>[] res = resSet.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p><p>这道题主要在于识别题干中的 <strong>无限循环</strong>， 即会出现<strong>sum重复出现</strong>的情况 于是题目就变成：<strong>如何快速查找sum是否已经出现过</strong>，即哈希应用题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 由于可能出现 无限循环 即会出现sum重复出现的情况</span></span><br><span class="line">    <span class="comment">// 于是题目就变成：如何快速查找sum是否已经出现过，即哈希应用题；</span></span><br><span class="line">    Set&lt;Integer&gt; sumSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nCopy</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (!sumSet.contains(sum)) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">newN</span> <span class="operator">=</span> nCopy;</span><br><span class="line">        sumSet.add(sum);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (newN &gt; <span class="number">0</span>) {</span><br><span class="line">            sum += (newN % <span class="number">10</span>) * (newN % <span class="number">10</span>);</span><br><span class="line">            newN /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        nCopy = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>缅怀我逝去的青春 <span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">    Map&lt;Integer, Integer&gt; val2Idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> target - cur;</span><br><span class="line">        <span class="keyword">if</span> (val2Idx.containsKey(needNum)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {val2Idx.get(needNum), i};</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            val2Idx.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></p><p>首先非常丑的暴力做法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">brutalForce</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">    <span class="comment">// 非常丑的 暴力： 200^4 = over 10^8 超时</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) {</span><br><span class="line">                    <span class="keyword">if</span> (nums1[i] + nums2[j] + nums3[k] + nums4[l] == <span class="number">0</span>) count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以考虑用时间换空间，借用两数之和的思想我们可以想到哈希表：</p><p>使用哈希表来优化至 O(N^2) </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">  <span class="comment">// 哈希表两两分组：</span></span><br><span class="line">  <span class="comment">// nums1 nums2 一组 的所有可能出现的和 存入哈希表</span></span><br><span class="line">  <span class="comment">// nums3 nums4 一组 在哈希表找可能出现的 -(的所有可能出现的和)</span></span><br><span class="line">  <span class="comment">// 哈希可以使其优化到 O(N^2)</span></span><br><span class="line">  Map&lt;Integer, Integer&gt; sum2Count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">          sum2Count.put(sum, sum2Count.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums3[k] + nums4[l];</span><br><span class="line">          <span class="keyword">if</span> (sum2Count.containsKey(-sum)) {</span><br><span class="line">              count += sum2Count.get(-sum);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">      <span class="type">int</span>[] hm = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> r : ransomNote.toCharArray()) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> r - <span class="string">'a'</span>;</span><br><span class="line">          hm[pos] += <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> m : magazine.toCharArray()) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> m - <span class="string">'a'</span>;</span><br><span class="line">          hm[pos] -= <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j : hm) {</span><br><span class="line">          <span class="keyword">if</span> (j &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>写做三数之和但是用哈希表来做会非常麻烦由于涉及到去重的操作。因此双指针会简便许多。具体流程如下：</p><p><img src="/2023/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="三数之和过程"></p><p>另外一些关于去重问题的考虑：</p><p>我们有三个数需要去重 nums[i] nums[left] nums[right]：</p><ol><li>i 的去重<ol><li>在 i 入口处就可以跳过：那么问题是我们应该用 <strong>nums[i] == nums[i + 1]</strong> 还是 <strong>nums[i] == nums[i - 1]</strong><ol><li>答案是用 <strong>nums[i] == nums[i - 1]</strong></li><li>考虑用{-1, -1 ,2} 这组数据，如果用<strong>nums[i] == nums[i + 1]</strong> 当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</li></ol></li></ol></li><li>nums[left] nums[right] 的 去重：<ol><li>见代码 4. 处</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) { <span class="comment">// 1. Change the loop condition</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> -num;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[left] + nums[right]; <span class="comment">// 2. Calculate the current sum</span></span><br><span class="line">                <span class="keyword">if</span> (currentSum &lt; needNum) {</span><br><span class="line">                    left++;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (currentSum &gt; needNum) {</span><br><span class="line">                    right--;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">                            nums[i], nums[left], nums[right] <span class="comment">// 3. Use nums[i], nums[left], nums[right] instead of i, left, right</span></span><br><span class="line">                    ));</span><br><span class="line">                    res.add(temp);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4. Handle duplicates for left and right pointers</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5. Move left and right pointers inward</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></p><p>本质上还是三数之和即排序加双指针但是有两个地方需要注意一下看下面的代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) {</span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++) {</span><br><span class="line">              <span class="comment">// 注意这里是 j &gt; i + 1 不能直接 j &gt; 0 否则 case 例如 [2, 2, 2, 2, 2] 会返回空 （毕竟看到2就都过去了）</span></span><br><span class="line">              <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 注意边界，需要用long for case：</span></span><br><span class="line">              <span class="comment">// [1000000000,1000000000,1000000000,1000000000] -294967296</span></span><br><span class="line">              <span class="type">long</span> <span class="variable">sumIJ</span> <span class="operator">=</span> nums[i] + nums[j];</span><br><span class="line">              <span class="type">long</span> <span class="variable">needSum</span> <span class="operator">=</span> target - sumIJ;</span><br><span class="line">              <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                  <span class="type">long</span> <span class="variable">curSum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">                  <span class="keyword">if</span> (curSum &lt; needSum) {</span><br><span class="line">                      left++;</span><br><span class="line">                  } <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; needSum) {</span><br><span class="line">                      right--;</span><br><span class="line">                  } <span class="keyword">else</span> {</span><br><span class="line">                      List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">                              Arrays.asList(nums[i], nums[j], nums[left], nums[right])</span><br><span class="line">                      );</span><br><span class="line">                      res.add(temp);</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                      <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                      left++;</span><br><span class="line">                      right--;</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/04/06/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/04/06/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考 <a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录-链表篇</a><br>感谢支持！</p></div><h1 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h1><blockquote><a href="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/" title="代码随想录-总汇">代码随想录-总汇</a> 中包含链表的基础知识</blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a> <br>边界非常多的题目，主要考虑如何更新链表节点的时候不要错误的更新。可以使用printHelper来帮助debug。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node() {</span><br><span class="line">        }</span><br><span class="line">        Node(<span class="type">int</span> val) {</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> {</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= index) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curIdx == index ? cur.val : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = cur;</span><br><span class="line">        cur.prev = head;</span><br><span class="line">        cur.next = headNext;</span><br><span class="line">        headNext.prev = cur;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tailPrev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        tail.prev = cur;</span><br><span class="line">        tailPrev.next = cur;</span><br><span class="line">        cur.prev = tailPrev;</span><br><span class="line">        cur.next = tail;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// System.out.println("add at tail");</span></span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &gt; count) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index == curIdx) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curPrev</span> <span class="operator">=</span> cur.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">needAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            curPrev.next = needAdd;</span><br><span class="line">            needAdd.next = cur;</span><br><span class="line">            needAdd.prev = curPrev;</span><br><span class="line">            cur.prev = needAdd;</span><br><span class="line">        }</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= index) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curIdx &lt; index &amp;&amp; cur != <span class="literal">null</span>) {</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            curIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index == curIdx) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curPrev</span> <span class="operator">=</span> cur.prev;</span><br><span class="line">            curPrev.next = cur.next;</span><br><span class="line">            cur.next.prev = curPrev;</span><br><span class="line">        }</span><br><span class="line">        count--;</span><br><span class="line">        <span class="comment">// printHelper();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a> <br>非常基础的删除链表中的元素题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) {</span><br><span class="line">                prev.next = cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a><br>这道题主要在于如何使用递归：<br>递归实现反转链表常常用来考察递归思想，我这里就用<strong>纯递归</strong>来翻转链表。对于递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 reverse 函数定义是这样的：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。</p><blockquote><p>quote: <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/">Labuladong 的翻转链表集合</a><br>想通递归函数定义后就很好实现了</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">return</span> reverse(head);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span> || cur.next == <span class="literal">null</span>) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(cur.next);</span><br><span class="line">        cur.next.next = cur; <span class="comment">// 这里是为了让head变成tail</span></span><br><span class="line">        cur.next = <span class="literal">null</span>; <span class="comment">// 注意这里要归为null否则会成环</span></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p><p>使用虚拟头节点来大幅简化问题的一道模拟题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">secondNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = secondNode.next;</span><br><span class="line">            secondNode.next = cur;</span><br><span class="line">            prev.next = secondNode;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">// helperPrint(dummyHead.next);</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helperPrint</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dm</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (dm != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(dm.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            dm = dm.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a> <br>写做链表，但其实本质还是双指针 - 快慢指针的一道应用题：<br>如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dmh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dmh.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dmh;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dmh;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="comment">// 先让fast移动k步</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="comment">// System.out.println(fast.val + " " + slow.val);</span></span><br><span class="line">        <span class="keyword">return</span> dmh.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07.链表相交</a><br>其实还是双指针但是要先找长的链表要先移动几步从而可以让两条链表同一起点：<br><img src="/2023/04/06/%E9%93%BE%E8%A1%A8/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="链表相交"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curLong</span> <span class="operator">=</span> headA, curShort = headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenLong</span> <span class="operator">=</span> <span class="number">0</span>, lenShort = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curLong != <span class="literal">null</span>) {</span><br><span class="line">            lenLong++;</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curShort != <span class="literal">null</span>) {</span><br><span class="line">            lenShort++;</span><br><span class="line">            curShort = curShort.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        curLong = headA;</span><br><span class="line">        curShort = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// always make sure lenLong and curLong is the longer one</span></span><br><span class="line">        <span class="keyword">if</span> (lenShort &gt; lenLong) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> lenShort;</span><br><span class="line">            lenShort = lenLong;</span><br><span class="line">            lenLong = temp;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curLong;</span><br><span class="line">            curLong = curShort;</span><br><span class="line">            curShort = tempNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> lenLong - lenShort;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) {</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">            gap--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printHelper(curLong);</span></span><br><span class="line">        <span class="comment">// printHelper(curShort);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curLong != <span class="literal">null</span> &amp;&amp; curShort != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (curLong == curShort) <span class="keyword">return</span> curLong;</span><br><span class="line">            curLong = curLong.next;</span><br><span class="line">            curShort = curShort.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            System.out.print(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表II</a><br>考察的其实还是双指针 - 快慢指针，但是加了一点数学。<br>需要做到两点：</p><ol><li><p>判断链表是否含有环</p><ol><li>使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。<br><img src="/2023/04/06/%E9%93%BE%E8%A1%A8/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="检查有环"></li></ol></li><li><p>若有环，怎么找环开始的地方</p><ol><li>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。<br><img src="/2023/04/06/%E9%93%BE%E8%A1%A8/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif" alt="环的入口"><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">idxStart</span> <span class="operator">=</span> head, meetStart = fast;</span><br><span class="line">                <span class="keyword">while</span> (idxStart != meetStart) {</span><br><span class="line">                    idxStart = idxStart.next;</span><br><span class="line">                    meetStart = meetStart.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> idxStart;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="快慢指针："><a href="#快慢指针：" class="headerlink" title="快慢指针："></a>快慢指针：</h2><p>慢指针用于保存性质，快指针用于探路。[0, 慢指针] 均满足性质</p><p><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a> </p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="comment">// brutal force:</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">           <span class="keyword">if</span> (nums[i] == val) {</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; count; j++) {</span><br><span class="line">                   nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">               }</span><br><span class="line">               i -= <span class="number">1</span>;</span><br><span class="line">               count--;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">        <span class="comment">// fast-slow pointers:</span></span><br><span class="line">        <span class="comment">// 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</span></span><br><span class="line">        <span class="comment">// 慢指针：指向更新 新数组下标的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) {</span><br><span class="line">            <span class="keyword">while</span> (fast &lt; nums.length &amp;&amp; nums[fast] == val) {</span><br><span class="line">                fast++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (fast == nums.length) <span class="keyword">break</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">            slow++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h2><p><a href="https://leetcode.cn/problems/remove-element/">977.有序数组的平方</a></p><p>由于满足性质：如果想要非递减顺序那么数组平方后的最大值一定在两侧并向中间收敛，因此相向双指针</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] twoPointers(<span class="type">int</span>[] nums) {</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt; Math.abs(nums[right])){</span><br><span class="line">            res[k--] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res[k--] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">209.长度最小的子数组</a></p><p>窗口内满足题目要求的性质，不断更新并在过程中寻找最小值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">whileLoopVersionSlidingWindow</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; nums.length) {</span><br><span class="line">                sum += nums[right];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res = Math.min(res, right - left + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (left + <span class="number">1</span> &lt; nums.length) {</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forLoopVersionSlidingWindow</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) {</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) {</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2023/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找，-Binary-Search"><a href="#二分查找，-Binary-Search" class="headerlink" title="二分查找， Binary Search"></a>二分查找， Binary Search</h1><p><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></p><p>二分查找有两个模板：</p><ol><li><p>左闭右闭</p><ol><li><p>leetcode 704:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchCloseInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="comment">// 左闭右闭：我们要考虑右区间的数然后和target比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">                <span class="comment">// 因为接下来要继续判断 left &lt;= right 而 right = mid 一定不为答案</span></span><br><span class="line">                <span class="comment">// 但我们的定义又要求 right 是有意义的因此 right = mid - 1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target){</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>左闭右开</p><ol><li><p>leetcode 704:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchOpenInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">       <span class="comment">// 左闭右开：我们无需考虑右区间的数然后和target比较</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">               <span class="comment">// 此时 我们 用 left &lt; right 保证在下一次不考虑right因此直接用 right = mid 即可</span></span><br><span class="line">               right = mid;</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></li></ol><p>两者方法的本质上的差别是要不要考虑右区间:</p><ol><li>若[left, right] 即 left &lt;= right<ol><li>right = nums.length - 1 &lt;- 很好理解，因为right本身在比较之中因此right = nums.length - 1</li><li>right = mid - 1 &lt;- 因为若 nums[mid] &gt; target 也就是说 right 一定不为答案，且在while中我们会考虑right因为它不为答案我们需要考虑其之前的一个数: right = mid - 1;</li></ol></li><li>若[left, right) 即 left &lt; right:<ol><li>right = nums.length, 同理，因为right本身不含在我们的比较计划中，因此right = nums.length即可</li><li>right = mid &lt;- 因为若 nums[mid] &gt; target 也就是说 right 一定不为答案，且在while中我们<strong>不</strong>会考虑right因为它不为答案我们<strong>不</strong>需要考虑其之前的一个数: right = mid;</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-总汇</title>
      <link href="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/"/>
      <url>/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a><br>题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。<br>先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。</p><blockquote><p>见 <a href="/2023/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="二分查找">二分查找</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a><br>题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。 </p><blockquote><p>见 <a href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/remove-element/">977.有序数组的平方</a><br>题目建议： 本题关键在于理解双指针思想 </p><blockquote><p>见 <a href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">209.长度最小的子数组</a><br>题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。</p><blockquote><p>见 <a href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a> 专题</p></blockquote><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59.螺旋矩阵II</a><br>题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">    <span class="comment">// 此题的关键点在于循环不变量</span></span><br><span class="line">    <span class="comment">// 即 每次循环中都要遵循一个准则，</span></span><br><span class="line">    <span class="comment">// 如二分法中的 左闭右闭 或 左闭右开 性质的定义</span></span><br><span class="line">    <span class="comment">// 我们规定左闭右开，即每一行/列的最后一个值交由下一次循环处理：</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">circleCount</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (circleCount &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 处理上边的行：（左到右）</span></span><br><span class="line">        <span class="keyword">for</span> (j = startY; j &lt; n - offset; j++) {</span><br><span class="line">            res[startX][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理右边的列：（上到下）</span></span><br><span class="line">        <span class="keyword">for</span> (i = startX; i &lt; n - offset; i++) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理下边的行：（右到左）</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt; startY; j--) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理左边的列：（下到上）</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt; startX; i--) {</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line">        offset++;</span><br><span class="line">        circleCount--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        res[startX][startY] = count;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h3><blockquote><p>其是一种通过指针串联在一起的 <strong>线性</strong> 数据结构，每一个节点都包含：<strong>数据域</strong> 和 <strong>指针域</strong>，最后一个节点的指针域指向null, aka 空指针。</p></blockquote><p>常见的包含三种类型：单链表（上述），双链表，循环链表：</p><h4 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h4><p>上述，它的指针域只能指向节点的下一个节点。<br><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p><h4 id="双链表："><a href="#双链表：" class="headerlink" title="双链表："></a>双链表：</h4><p>每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。因此双链表可以向前以及向后查。<br><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%8F%8C%E9%93%BE%E8%A1%A8.png" alt="双链表"></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>链表首尾相连，可以用来解决<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫环</a>的问题<br><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="循环链表"></p><h4 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h4><ol><li>不是连续分布，instead, 散乱分布</li><li>通过指针链接内存中的各个节点</li></ol><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>删除节点：<br>next指向下一个即可</p><p>添加节点：取消原本的next，指向新的节点，新的节点指向下一个节点。</p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%93%BE%E8%A1%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="链表性能分析"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p></blockquote><blockquote><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p></blockquote><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><blockquote><p>例题详解见 <a href="/2023/04/06/%E9%93%BE%E8%A1%A8/" title="链表">链表</a></p></blockquote><p>● 203.移除链表元素<br>● 707.设计链表<br>● 206.反转链表<br>● 24. 两两交换链表中的节点<br>● 19.删除链表的倒数第N个节点<br>● 面试题 02.07. 链表相交<br>● 142.环形链表II </p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="基本知识：-1"><a href="#基本知识：-1" class="headerlink" title="基本知识："></a>基本知识：</h3><p>即 Hash Table, 又称散列表。<br>哈希表是根据关键码的值而直接进行防卫的数据结构。e.g.数组就是哈希表的一个非常好的应用因为可以通过下标来返回对应值。<br><strong>主要解决的问题：</strong> 快速判断一个元素是否出现在集合里。 <br>值 -&gt; 哈希表 的 <strong>映射</strong> 即为Hash Function aka 哈希函数 \</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" alt="哈希函数"><br>把学生姓名映射到了哈希表存储的函数过程。通过<strong>hashCode</strong>把<strong>名字转化为数值</strong>，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><blockquote><p>问题1: 如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了 怎么办？ </p></blockquote><blockquote><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p></blockquote><blockquote><p>问题2: 如果学生的数量大于哈希表的大小，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p></blockquote><blockquote><p>即哈希碰撞的处理问题 </p></blockquote><h4 id="哈希碰撞-Hash-Collisions："><a href="#哈希碰撞-Hash-Collisions：" class="headerlink" title="哈希碰撞, Hash Collisions："></a>哈希碰撞, Hash Collisions：</h4><blockquote><p>两个值映射到了同一个位置即为Hash Collisions</p></blockquote><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E.png" alt="哈希碰撞"><br>解决方法：</p><ol><li>拉链法</li><li>线性探测法</li></ol><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>从冲突的位置拉一条链表出来：<br><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E6%8B%89%E9%93%BE%E6%B3%95.png" alt="拉链法"><br>需要注意的是链表上的查询需要一个一个查，因此大小很重要。</p><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><blockquote><p>要求 hash table 的大小 <strong>一定</strong> 要大于 data size 因为需要依赖哈希表中的空位来解决碰撞问题。线性探测法要把冲突的元素放在下一个 <strong>空闲的</strong> 位置 </p></blockquote><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E7%BA%BF%E6%80%A7%E5%86%B2%E7%AA%81%E6%B3%95.png" alt="线性冲突法"></p><p>图中小王需要放到小李的下面的位置。</p><h4 id="常见的哈希结构："><a href="#常见的哈希结构：" class="headerlink" title="常见的哈希结构："></a>常见的哈希结构：</h4><p>一般会有以下三种结构：</p><ol><li>数组</li><li>hashset</li><li>hashmap</li></ol><table><thead><tr><th>数据结构</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>HashMap</td><td>哈希表（数组 + 链表/红黑树）</td><td>无序</td><td>键不可重复，值可重复</td><td>可以</td><td>O(1) ~ O(n)</td><td>O(1) ~ O(n)</td></tr><tr><td>HashSet</td><td>基于HashMap实现</td><td>无序</td><td>不可重复</td><td>间接支持</td><td>O(1) ~ O(n)</td><td>O(1) ~ O(n)</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>有序</td><td>键不可重复，值可重复</td><td>可以</td><td>O(log n)</td><td>O(log n)</td></tr></tbody></table><table><thead><tr><th>HashMap</th><th>HashSet</th><th>TreeMap</th></tr></thead><tbody><tr><td>底层实现：哈希表（数组 + 链表/红黑树）</td><td>基于HashMap实现</td><td>红黑树</td></tr><tr><td>是否有序：无序</td><td>无序</td><td>有序</td></tr><tr><td>数值是否可以重复：键不可重复，值可重复</td><td>不可重复</td><td>键不可重复，值可重复</td></tr><tr><td>能否更改数值：可以 通过put()方法更新键对应的值。</td><td>间接支持</td><td>可以通过put()方法更新键对应的值</td></tr><tr><td>查询效率：O(1) ~ O(n)</td><td>O(1) ~ O(n)</td><td>O(log n) 由于红黑树是平衡的</td></tr><tr><td>增删效率：O(1) ~ O(n)</td><td>O(1) ~ O(n)</td><td>O(log n) 由于红黑树是平衡的</td></tr></tbody></table><ol start="3"><li>TreeMap</li></ol><p>底层实现：基于红黑树实现，红黑树是一种自平衡的二叉搜索树。是否有序：保证有序。TreeMap中的元素按照键（Key）的自然顺序或者提供的比较器（Comparator）进行排序。数值是否可以重复：键（Key）不可重复，值（Value）可重复。能否更改数值：可以更改数值。通过put()方法更新键对应的值。查询效率：时间复杂度为O(log n)，其中n为元素数量。由于红黑树是平衡的，查询效率相对较高。增删效率：时间复杂度为O(log n)，其中n为元素数量。由于红黑树具有自平衡特性，增删操作效率相对较高。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><blockquote><p>例题详解见 <a href="/2023/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a></p></blockquote><p>● 242.有效的字母异位词 </p><p>● 349. 两个数组的交集 </p><p>● 202. 快乐数 </p><p>● 1. 两数之和</p><p>● 454.四数相加II </p><p>● 383. 赎金信 </p><p>● 15. 三数之和 </p><p>● 18. 四数之和 </p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。其本质是通过<strong>通过空间换了时间</strong> </li><li>经典题目：<ol><li>数组作为哈希表：eg: int[] = new int[26]; <ol><li>在<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！这道题目包含小写字母，那么使用数组来做哈希最合适不过。在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！和<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>很像，<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词</a>是求 字符串a 和 字符串b 是否可以相互组成，在<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">383.赎金信</a>中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</li></ol></li><li>Set作为哈希表：<ol><li>在<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集 (opens new window)</a>中我们给出了什么时候用数组就不行了，需要用set。这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</li><li><strong>主要因为如下两点：</strong><ol><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ol></li></ol></li><li>Map本身作为哈希表：<ol><li>e g: 两数之和</li><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ol></li></ol></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li>字符串是字符组成的有限序列</li><li>使用方法：<ol><li>双指针：<ol><li>344.反转字符串 </li><li>剑指Offer 05.替换空格</li></ol></li><li>反转<ol><li>例题： 541. 反转字符串II</li><li>例题：151.翻转字符串里的单词</li></ol></li><li>KMP</li></ol></li></ol><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><blockquote><p> 例题详解见 <a href="/2023/04/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串">字符串</a></p></blockquote><p>● 344.反转字符串</p><p>● 541. 反转字符串II</p><p>● 剑指Offer 05.替换空格</p><p>● 151.翻转字符串里的单词</p><p>● 剑指Offer58-II.左旋转字符串</p><p>● 28. 实现 strStr()</p><p>● 459.重复的子字符串</p><h2 id="队列-Queue-and-栈-Stack"><a href="#队列-Queue-and-栈-Stack" class="headerlink" title="队列 (Queue) and 栈 (Stack)"></a>队列 (Queue) and 栈 (Stack)</h2><blockquote><p>例题详解见 <a href="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" title="队列和栈">队列和栈</a></p></blockquote><ol><li>队列先进先出 FIFO 栈先进后出 FILO</li></ol><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在 Java 中，栈（Stack）和队列（Queue）是两种常用的数据结构。它们可以通过 Java 集合框架中的类来实现。</p><h4 id="栈（Stack）实现方法："><a href="#栈（Stack）实现方法：" class="headerlink" title="栈（Stack）实现方法："></a>栈（Stack）实现方法：</h4><p>Java 有一个名为 Stack 的类。但是，由于 Stack 类被认为是过时的，不推荐使用。相反，我们可以使用 Deque（双端队列）来实现栈。以下是使用 Deque 实现栈的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>栈的底层实现是<strong>通过数组或链表</strong>。在这个例子中，我们使用了 LinkedList（链表）作为底层实现。栈的主要操作（push 和 pop）的时间复杂度是 O(1)。</p><h4 id="队列（Queue）实现方法："><a href="#队列（Queue）实现方法：" class="headerlink" title="队列（Queue）实现方法："></a>队列（Queue）实现方法：</h4><p>Java 提供了 Queue 接口来实现队列。以下是使用 LinkedList 实现队列的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>队列的底层实现可以是数组或链表。在这个例子中，我们使用了 LinkedList（链表）作为底层实现。队列的主要操作（offer 和 poll）的时间复杂度是 O(1)。</p><p>注意：虽然在上面的例子中，我们使用 LinkedList 作为底层实现，但实际上还有其他实现方式，如 ArrayDeque（基于数组的双端队列），它在某些情况下可能比 LinkedList 更高效。另外，Java 还提供了 PriorityQueue（优先队列），其底层实现是基于二叉堆的数据结构，用于实现具有优先级的队列。</p><h4 id="优先队列-Priority-Queue"><a href="#优先队列-Priority-Queue" class="headerlink" title="优先队列 (Priority Queue):"></a>优先队列 (Priority Queue):</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个整数优先队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; intQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将整数添加到优先队列</span></span><br><span class="line">        intQueue.offer(<span class="number">5</span>);</span><br><span class="line">        intQueue.offer(<span class="number">2</span>);</span><br><span class="line">        intQueue.offer(<span class="number">8</span>);</span><br><span class="line">        intQueue.offer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将整数从优先队列中删除并打印（默认为自然顺序，即升序）</span></span><br><span class="line">        <span class="keyword">while</span> (!intQueue.isEmpty()) {</span><br><span class="line">            System.out.println(intQueue.poll());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个字符串优先队列，使用自定义的 Comparator 对象</span></span><br><span class="line">        PriorityQueue&lt;String&gt; stringQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">StringLengthComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串添加到优先队列</span></span><br><span class="line">        stringQueue.offer(<span class="string">"apple"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"banana"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"cherry"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"date"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串从优先队列中删除并打印（根据字符串长度排序）</span></span><br><span class="line">        <span class="keyword">while</span> (!stringQueue.isEmpty()) {</span><br><span class="line">            System.out.println(stringQueue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的 Comparator 类，按字符串长度进行排序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StringLengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">            <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Comparator in one line:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个字符串优先队列，使用自定义的 Comparator 对象</span></span><br><span class="line">        PriorityQueue&lt;String&gt; stringQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">                <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串添加到优先队列</span></span><br><span class="line">        stringQueue.offer(<span class="string">"apple"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"banana"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"cherry"</span>);</span><br><span class="line">        stringQueue.offer(<span class="string">"date"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串从优先队列中删除并打印（根据字符串长度排序）</span></span><br><span class="line">        <span class="keyword">while</span> (!stringQueue.isEmpty()) {</span><br><span class="line">            System.out.println(stringQueue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><blockquote><p> 例题详解见 <a href="/2023/04/15/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" title="队列和栈">队列和栈</a></p></blockquote><p>● 232.用栈实现队列</p><p>● 225. 用队列实现栈</p><p>● 20. 有效的括号</p><p>● 1047. 删除字符串中的所有相邻重复项</p><p>● 150. 逆波兰表达式求值</p><p>● 239. 滑动窗口最大值</p><p>● 347.前 K 个高频元素</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol><li>225.用队列实现栈：一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</li></ol><h5 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h5><ol><li><strong>括号匹配（有效的括号）, 表达式（逆波兰表达式求值），字符串相邻元素去重（删除字符串中的所有相邻重复项）</strong>都是使用<strong>栈</strong>解决的经典问题其核心是<strong>匹配</strong>问题</li></ol><h5 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h5><ol><li>滑动窗口最大值问题中，队列<strong>没有</strong>必要维护窗口里的所有元素，<strong>只需要</strong>维护有可能成为窗口里<strong>最大值的元素</strong>就可以了，同时<strong>保证队列里的元素数值是由大到小的。</strong></li><li>单调队列 ≠ 优先队列</li><li><strong>单调队列不是一成不变的，而是不同场景不同写法</strong>，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。</li></ol><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p><strong>一个披着队列外衣的堆</strong>，优先队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是<strong>大顶堆</strong>，小于等于左右孩子就是<strong>小顶堆</strong>。</p><p>前 K 个高频元素 用到了优先队列</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.png" alt="二叉树基本知识"></p><h3 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h3><p>主要有两种：<strong>满二叉树</strong>以及<strong>完全二叉树</strong></p><p>节点的高度：节点到最远叶子节点的最长路径上边的数量。叶子节点高度为0。<br>节点的深度：节点到根节点的路径上边的数量。所有根节点深度为0。<br>树的高度：树的高度等于根节点的高度，等于最远叶子节点的深度。<br>树的深度：树的深度等于树的高度。<br>树的宽度：两个最长路径的叶子节点之间节点数。</p><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8D%E8%AF%8D.webp" alt="二叉树名词"></p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>定义：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为 叶子结点 ）。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值。所有叶子结点必须在同一层上.</p><p>例子：<img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><p>深度为k，有 2 ^ (k-1) 个节点的二叉树</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边</strong>的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。</p><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><p>ps: 优先队列 用到了 堆 而堆就是一个完全二叉树但保证了父子节点的顺序关系</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树，有值，且其是一个有序树。对节点没有要求，对顺序有要求</p><p>有以下三个特点：</p><ul><li>若它的左子树不空，则<strong>左子树上所有结点的值均小于它的根结点</strong>的值；</li><li>若它的右子树不空，则<strong>右子树上所有结点的值均大于它的根结点</strong>的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p><h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p><strong>平衡二叉查找树</strong>：简称平衡二叉树 </p><p>特点：任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logN)</p><p>总结：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="平衡二叉搜索树"></p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p>两种：</p><ol><li>用<strong>指针</strong>的<strong>链式存储</strong></li></ol><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="链式存储"></p><ol><li>用<strong>数组</strong>的<strong>顺序存储</strong></li></ol><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="顺序存储"></p><p>如果父节点的数组下标是 i，那么它的<strong>左孩子就是 i * 2 + 1</strong>，<strong>右孩子就是 i * 2 + 2</strong>。</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p><ol><li><p><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</p><ol><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ol><p>前中后，其实指的就是<strong>中间节点</strong>的<strong>遍历顺序</strong>，前中后序指的就是中间节点的位置：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p><img src="/2023/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%80%BB%E6%B1%87/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="前中后的遍历"></p></li><li><p><strong>广度优先遍历</strong>：一层一层的去遍历。</p><ol><li>层次遍历（迭代法）</li></ol></li></ol><h3 id="二叉树定义-链式存储"><a href="#二叉树定义-链式存储" class="headerlink" title="二叉树定义(链式存储)"></a>二叉树定义(链式存储)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line">  TreeNode() {}</span><br><span class="line">  TreeNode(<span class="type">int</span> val) { <span class="built_in">this</span>.val = val; }</span><br><span class="line">  TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) {</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><blockquote><p>例题详解见 <a href="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a></p></blockquote><ul><li>递归遍历<ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul></li><li>迭代遍历</li><li>统一迭代</li><li>层序遍历：<ul><li>102.二叉树的层序遍历</li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图</li><li>637.二叉树的层平均值</li><li>429.N叉树的层序遍历</li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针</li><li>117.填充每个节点的下一个右侧节点指针II</li><li>104.二叉树的最大深度</li><li>111.二叉树的最小深度</li></ul></li><li>226.翻转二叉树 </li><li>101.对称二叉树 2  </li><li>104.二叉树的最大深度  </li><li>559.n叉树的最大深度</li><li>111.二叉树的最小深度</li><li>222.完全二叉树的节点个数</li><li>110.平衡二叉树 </li><li>257.二叉树的所有路径 </li><li>404.左叶子之和</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 总汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/04/hello-world/"/>
      <url>/2023/04/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
