<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin&#39;s Blog</title>
  
  <subtitle>Welcome to my blog</subtitle>
  <link href="http://ruobingw.com/atom.xml" rel="self"/>
  
  <link href="http://ruobingw.com/"/>
  <updated>2023-10-14T00:33:53.473Z</updated>
  <id>http://ruobingw.com/</id>
  
  <author>
    <name>Ruobing Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Re:从1500分开始的竞赛生活</title>
    <link href="http://ruobingw.com/2023/10/11/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/"/>
    <id>http://ruobingw.com/2023/10/11/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/</id>
    <published>2023-10-11T16:49:38.000Z</published>
    <updated>2023-10-14T00:33:53.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要在这里练习</p><p><a href="https://huxulm.github.io/lc-rating/#/zen">https://huxulm.github.io/lc-rating/#/zen</a></p></div><h1 id="1600-1900"><a href="#1600-1900" class="headerlink" title="1600 - 1900"></a>1600 - 1900</h1>]]></content>
    
    
    <summary type="html">记录下为了周赛的难度练习</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="周赛" scheme="http://ruobingw.com/tags/%E5%91%A8%E8%B5%9B/"/>
    
    <category term="难度练习" scheme="http://ruobingw.com/tags/%E9%9A%BE%E5%BA%A6%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://ruobingw.com/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://ruobingw.com/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-10-05T22:43:02.000Z</published>
    <updated>2023-10-05T23:25:50.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>对于两个字符串求子序列的问题，都是用两个指针 <code>i</code> 和 <code>j</code> 分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--93b6b/">labuladong-最长公共子序列</a></p></blockquote><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><p><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>定义<code>dp(s1, i, s2, j)</code>为<code>s1[i...]</code> 和 <code>s2[j...]</code>的最长公共子序列长度</p><p>goal: <code>dp(s1, 0, s2, 0)</code> 从零开始的最长公共子序列长度</p><p>base case: <code>i == len(s1)</code> 或 <code>j == len(s2)</code> 由于相当于没有string，所以最长公共子序列长度为0</p><p>状态转移：</p><p>在选的情况下，即charAt[i] == charAt[j]时，状态转移：</p><p><img src="/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E9%80%89.jpeg" alt="状态转移_选"></p><p>在不选的情况下可以从三种情况转移：</p><p><img src="/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E4%B8%8D%E9%80%89.jpeg" alt="状态转移"></p><p><strong>但是其实只有情况一和情况二，因为情况三被情况一cover了</strong></p><h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>模板题</p><p>代码：</p><p>自顶向下的递归解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String text1, text2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> {</span><br><span class="line">        m = text1.length();</span><br><span class="line">        n = text2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.text1 = text1;</span><br><span class="line">        <span class="built_in">this</span>.text2 = text2;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上的迭代解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span></span><br><span class="line">        <span class="comment">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span></span><br><span class="line">        <span class="comment">// base case: dp[0][..] = dp[..][0] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 现在 i 和 j 从 1 开始，所以要减一</span></span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><p>变换一下思路，我们要的就是让他们成为他们的公共子序列，问的是需要到达公共子序列所需要的步数:</p><p>即 <code>word1.length - LCS.length + word2.length - LCS.length</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String word1, word2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        m = word1.length();</span><br><span class="line">        n = word2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.word1 = word1;</span><br><span class="line">        <span class="built_in">this</span>.word2 = word2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lcsLength</span> <span class="operator">=</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (m - lcsLength) + (n - lcsLength);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于两个字符串求子序列的问题，都是用两个指针 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 分别在两个字符串上移动，大概率是动态规划思路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://labu</summary>
      
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="LCS" scheme="http://ruobingw.com/tags/LCS/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://ruobingw.com/2023/10/04/%E6%8E%92%E5%BA%8F/"/>
    <id>http://ruobingw.com/2023/10/04/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-10-04T16:24:09.000Z</published>
    <updated>2023-10-05T17:42:09.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1029-两地调度"><a href="#1029-两地调度" class="headerlink" title="1029. 两地调度"></a><a href="https://leetcode.cn/problems/two-city-scheduling/">1029. 两地调度</a></h1><p>解题思路：贪心 + 排序</p><p>怎么贪：</p><p>培养一个思维：我们不是单独拿一个城市，而是假设所有面试者都去B，那么挑出来去A的应该是代价最小的即按照 <code>cost[i][0] - cost[i][1]</code> 排升序</p><p>也就是 <code>cost[a][0] - cost[a][1] - (cost[b][0] - cost[b][1]) </code> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> {</span><br><span class="line">        Arrays.sort(costs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o1[<span class="number">1</span>] - (o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> costs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">splitN</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">aSum</span> <span class="operator">=</span> <span class="number">0</span>, bSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; splitN; i++) {</span><br><span class="line">            aSum += costs[i][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; i++) {</span><br><span class="line">            bSum += costs[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> aSum + bSum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">涉及排序解法的题目集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数组" scheme="http://ruobingw.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="http://ruobingw.com/tags/Array/"/>
    
    <category term="Sort" scheme="http://ruobingw.com/tags/Sort/"/>
    
    <category term="排序" scheme="http://ruobingw.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Basic-Calculator-Topics</title>
    <link href="http://ruobingw.com/2023/10/03/Basic-Calculator-Topics/"/>
    <id>http://ruobingw.com/2023/10/03/Basic-Calculator-Topics/</id>
    <published>2023-10-03T23:51:58.000Z</published>
    <updated>2023-10-05T17:46:11.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-shi--24fe4/">Labuladong-实现基础计算器</a></p></blockquote><table><thead><tr><th><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></td></tr><tr><td><a href="https://leetcode.cn/problems/basic-calculator-iii/">772. 基本计算器 III</a></td></tr></tbody></table><p>主要借助栈（加减乘除） + 递归（括号）</p><p>加一个<code>preSign '+'</code></p><p>即：</p><p><code>+</code> <code>-</code> 数 直接入栈</p><p><code>* /</code> 借用栈的性质，将计算结果入栈</p><p><code>(</code> <code>)</code> 使用递归先计算括号内的数，将结果入栈</p><p><img src="/2023/10/03/Basic-Calculator-Topics/Basic-Calculator-push-stack-1.jpeg" alt="Basic-Calculator-push-stack-1"></p><h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (cArr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">'+'</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cArr.length;) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cArr[i])) {</span><br><span class="line">                num = num * <span class="number">10</span> + (cArr[i] - <span class="string">'0'</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ((!Character.isDigit(cArr[i]) &amp;&amp; cArr[i] != <span class="string">' '</span>) || i == cArr.length - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) {</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) {</span><br><span class="line">                    stack.push(-<span class="number">1</span> * num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek * num);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek / num);</span><br><span class="line">                }</span><br><span class="line">                sign = cArr[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            sum += stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">基础计算器专题类问题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="计算器" scheme="http://ruobingw.com/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    
    <category term="Basic-Calculator" scheme="http://ruobingw.com/tags/Basic-Calculator/"/>
    
    <category term="Stack" scheme="http://ruobingw.com/tags/Stack/"/>
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://ruobingw.com/2023/10/01/%E6%95%B0%E7%BB%84/"/>
    <id>http://ruobingw.com/2023/10/01/%E6%95%B0%E7%BB%84/</id>
    <published>2023-10-02T03:44:58.000Z</published>
    <updated>2023-10-05T20:20:44.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 - Array"></a>数组 - Array</h1><blockquote><ul><li><a href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></li><li><a href="/2023/10/04/%E6%8E%92%E5%BA%8F/" title="排序">排序</a></li></ul></blockquote><h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></h1><p>非常有意思的情况划分题：</p><blockquote><p>参考：<br><a href="https://leetcode.cn/problems/insert-interval/solutions/472435/shou-hua-tu-jie-57-cha-ru-qu-jian-fen-cheng-3ge-ji/">笨猪爆破组</a></p></blockquote><p>核心在于：</p><ol><li>推入前段不重叠部分</li><li>更新重叠部分再推入</li><li>推入后段不重叠部分</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) {</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; retList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLeft</span> <span class="operator">=</span> newInterval[<span class="number">0</span>], newRight = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 加入左边不重叠的</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (right &lt; newLeft) {</span><br><span class="line">                retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{left, right});</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新重叠范围</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &gt; newRight) <span class="keyword">break</span>;</span><br><span class="line">            newLeft = Math.min(left, newLeft);</span><br><span class="line">            newRight = Math.max(right, newRight);</span><br><span class="line">        }</span><br><span class="line">        retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{newLeft, newRight});</span><br><span class="line">        <span class="comment">// 加入右边不重叠部分</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left, right});</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[retList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.length; i++) {</span><br><span class="line">            ret[i] = retList.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1366-通过投票对团队排名"><a href="#1366-通过投票对团队排名" class="headerlink" title="1366. 通过投票对团队排名"></a><a href="https://leetcode.cn/problems/rank-teams-by-votes/">1366. 通过投票对团队排名</a></h1><p>直接排序即可，主要检查对于Comparator的应用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rankTeams</span><span class="params">(String[] votes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> votes.length, m = votes[<span class="number">0</span>].length();</span><br><span class="line">        Map&lt;Character, <span class="type">int</span>[]&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String vote : votes) {</span><br><span class="line">            <span class="type">char</span>[] cArr = vote.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">                <span class="type">int</span>[] cur = hm.getOrDefault(cArr[i], <span class="keyword">new</span> <span class="title class_">int</span>[cArr.length]);</span><br><span class="line">                cur[i]++;</span><br><span class="line">                hm.put(cArr[i], cur);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        List&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hm.entrySet());</span><br><span class="line">        Collections.sort(ls, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e1, Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e2)</span> {</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e1Key</span> <span class="operator">=</span> e1.getKey();</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e2Key</span> <span class="operator">=</span> e2.getKey();</span><br><span class="line">                <span class="type">int</span>[] e1Value = e1.getValue();</span><br><span class="line">                <span class="type">int</span>[] e2Value = e2.getValue();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> e1Value.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> e1Value[i], second = e2Value[i];</span><br><span class="line">                    <span class="keyword">if</span> (first == second) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> second - first;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> e1Key - e2Key;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, <span class="type">int</span>[]&gt; ele : ls) {</span><br><span class="line">            sb.append(ele.getKey());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">涉及数组的题目集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数组" scheme="http://ruobingw.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="http://ruobingw.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>DataBricks</title>
    <link href="http://ruobingw.com/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://ruobingw.com/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2023-09-19T17:27:48.000Z</published>
    <updated>2023-10-02T03:48:38.097Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>本篇文章援引：</p><blockquote><p>一亩三分地 - <a href="https://www.1point3acres.com/bbs/space-uid-764814.html">newgpu</a></p><p><a href="https://www.1point3acres.com/bbs/thread-851795-1-1.html"> 谈谈Databricks和云计算</a></p><p><a href="https://www.1point3acres.com/bbs/thread-855806-1-1.html"> 谈谈Databricks和云计算（二）</a></p><p><a href="https://cloud.tencent.com/developer/article/2191426">腾讯数据湖与湖仓一体架构实践</a></p></blockquote></div><h1 id="Data-Warehouse"><a href="#Data-Warehouse" class="headerlink" title="Data Warehouse"></a>Data Warehouse</h1><p>Running on cluster. </p><p>A place to store structured data.</p><p>Source: offline ETL pipline to insert by batch</p><p>goal is to make data scientist to run SQL query</p><p>特点：</p><ol><li>It is a distributed database hence it has a lot features that database own</li><li>Structured data</li></ol><h2 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h2><p>managed cloud data warehouse</p><p>data warehouse on cloud</p><h1 id="databricks-and-data-lakehouse"><a href="#databricks-and-data-lakehouse" class="headerlink" title="databricks and data lakehouse"></a>databricks and data lakehouse</h1><p>datalake -&gt; data lakehouse</p><p>No need for schema: friendly to semi-structured and non structured data</p><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h2 id="delta-lake"><a href="#delta-lake" class="headerlink" title="delta lake"></a>delta lake</h2><p>stores data itself and its metadata. </p><p>metadata is for ACID transactions and support for a schema with a supporting write-ahead log for data rolling back when necessary </p><p>Data can be stored on the top of S3, like object storage. Delta Lake imports metadata for ACID transactions and schema. These ACID transactions and schema are necessary for SQL workload</p><h2 id="Databricks-SQL"><a href="#Databricks-SQL" class="headerlink" title="Databricks SQL"></a>Databricks SQL</h2><p>Photon execution engine.</p><h2 id="Databricks-Runtime"><a href="#Databricks-Runtime" class="headerlink" title="Databricks Runtime"></a>Databricks Runtime</h2><p>Create machine -&gt; a tuned spark cluster, and spark is ready to go</p><h2 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h2><p>Connect to a cluster that the user have access to. Use scala, python, sql or R to run the spark command and do the manipulation with the data on top of S3</p>]]></content>
    
    
    <summary type="html">记录下databricks的面试</summary>
    
    
    
    <category term="面经" scheme="http://ruobingw.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://ruobingw.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树 - Minimum Spanning Tree - MST</title>
    <link href="http://ruobingw.com/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://ruobingw.com/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2023-09-13T02:06:41.000Z</published>
    <updated>2023-09-13T02:17:11.440Z</updated>
    
    <content type="html"><![CDATA[<p>最小生成树算法主要有： </p><ul><li>Kruskal 算法</li><li>Prim 算法</li></ul><h1 id="什么是最小生成树-MST"><a href="#什么是最小生成树-MST" class="headerlink" title="什么是最小生成树 MST"></a>什么是最小生成树 MST</h1><p><strong>先说「树」和「图」的根本区别：树不会包含环，图可以包含环</strong>。</p><p>什么是图的「生成树」呢，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。</p><p><img src="/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/MST_0.png" alt="MST_0"></p><p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。</p><p><strong>最小生成树: 所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」</strong>。</p><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><p>MST 要保证边：</p><p>1、包含图中的所有节点。</p><p>2、形成的结构是树结构（即不存在环）。</p><p>3、权重和最小。</p><p>其中 1， 2可以用并查集来做：</p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><blockquote><p> 详见：<a href="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a> 习题261</p></blockquote><p>对于3:</p><p>用到了贪心思路：</p><p>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 <code>mst</code> 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 <code>mst</code> 集合；否则，这条边不是最小生成树的一部分，不要把它加入 <code>mst</code> 集合。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>To be write…</p><p>1135</p><p>1584</p>]]></content>
    
    
    <summary type="html">了解一下最小生成树</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="并查集" scheme="http://ruobingw.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="http://ruobingw.com/tags/UnionFind/"/>
    
    <category term="最小生成树" scheme="http://ruobingw.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="minimum spanning tree" scheme="http://ruobingw.com/tags/minimum-spanning-tree/"/>
    
    <category term="Kruscal" scheme="http://ruobingw.com/tags/Kruscal/"/>
    
    <category term="Prim" scheme="http://ruobingw.com/tags/Prim/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://ruobingw.com/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://ruobingw.com/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2023-09-10T15:55:03.000Z</published>
    <updated>2023-09-13T02:06:30.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集-解决的问题"><a href="#并查集-解决的问题" class="headerlink" title="并查集 - 解决的问题"></a>并查集 - 解决的问题</h1><ol><li><p>快速的支持以下的操作：（近乎 O(1)）</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol></li><li><p>基本原理: 每一个集合都用一颗树来表示。树根的标号就是整个集合的编号。每个节点存储他的父节点， p[x] 表示x的父节点</p><ol><li><p>用树（不一定是二叉树）的形式来维护集合：</p></li><li><p>集合的根结点为集合编号</p></li><li><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E9%9B%86%E5%90%88.png" alt="uf_集合"></p></li></ol></li><li><p>问题1：</p><ol><li>如何判断树根：<ul><li><code>if (p[x] == x)</code> 根节点的parent是他自己</li></ul></li></ol></li><li><p>问题2: </p><ol><li>如何求x的集合编号：<ul><li><code>while (p[x] ≠ x) x = p[x]</code></li></ul></li></ol></li><li><p>问题3: </p><ol><li>如何合并两个集合：<ul><li>把其中一个集合当成另一个集合的儿子；</li><li>p[x] = y (px 是 x的集合编号， py是y的集合编号）</li><li><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88.png" alt="uf_合并集合"></li></ul></li></ol></li></ol><p>思考：插入需要树的高度的复杂度 → 并查集的优化：路经压缩</p><p>当第一次x节点后，当前路径上经过的所有点都直接指向根节点，因此近乎 O(1)</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9.png" alt="uf_路经压缩"></p><p>并且同时维护节点数量：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    {</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"C"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (a != b)</span><br><span class="line">            {</span><br><span class="line">                p[a] = b;</span><br><span class="line">                cnt[b] += cnt[a];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q1"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            cout &lt;&lt; cnt[<span class="built_in">find</span>(a)] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>java 代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">            parent[x] = find(parent[x]); <span class="comment">// 这里是用了路经压缩</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h1><p>union很好理解，找到两个根，将其中一个根的parent设置成另一个根的儿子</p><p>主要是find，这里使用了路经压缩：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">        parent[x] = find(parent[x]); <span class="comment">// 这里用了路经压缩, find返回了最上面的根，然后当前栈层就会接上这个根</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 2 -&gt; 3 3 -&gt; 3</span><br><span class="line">4 -&gt; 4</span><br><span class="line">5 -&gt; 6 6 -&gt; 6</span><br><span class="line"></span><br><span class="line">所以是 1-&gt;2-&gt;3; 4-&gt;4; 6-&gt;6; 三个集合</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>那么用 <code>1-&gt;2-&gt;3</code>举例子：1的父节点是2，2的父节点是3，而3是其自己的父节点。</p><p>如果我们调用<code>find(1)</code>：</p><ol><li><code>parent[1]</code> 是 2，不等于1，所以我们要递归地找<code>find(2)</code>。</li><li><code>parent[2]</code> 是 3，不等于2，所以我们要递归地找<code>find(3)</code>。</li><li><code>parent[3]</code> 是 3，等于3，所以返回3。</li></ol><p>在这个过程中，我们还会更新<code>parent[1]</code>和<code>parent[2]</code>都为3，因为3是1和2的代表。这就是路径压缩的优化，确保每个节点都直接指向其代表，从而使得后续的查找操作更快。</p><p>等于说：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9_2.jpeg" alt="uf_路经压缩_2"></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/description/#">200. 岛屿数量</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n * m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                        parent[i * m + j] = i * m + j;</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + dx[dir], newY = j + dy[dir];</span><br><span class="line">                        <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp; grid[newX][newY] == <span class="string">'1'</span>) {</span><br><span class="line">                            uf.union(</span><br><span class="line">                                i * m + j, newX * m + newY</span><br><span class="line">                            );</span><br><span class="line">                        };</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721. 账户合并"></a><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        UnionFind(List&lt;List&lt;String&gt;&gt; accounts) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> accounts.size();</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="keyword">if</span> (rootQ == rootP) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(accounts);</span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="keyword">if</span> (!emailToId.containsKey(curEmail)) {</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    uf.union(i, emailToId.get(curEmail));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> uf.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id, emails);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet()){</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));</span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323.无向图中连通分量的数目"></a><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/description/">323.无向图中连通分量的数目</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            count = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count--;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261.以图判树"></a><a href="https://leetcode.cn/problems/graph-valid-tree/description/">261.以图判树</a></h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集:"></a>并查集:</h3><blockquote><p>树满足两个性质：</p><ol><li>n 个节点 n - 1条边 </li><li>无环</li></ol></blockquote><p>如果一个联通块下相连了两个节点，那么成环：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_1.png" alt="lc_261_1"></p><p>这种无环：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_2.png" alt="lc_261_2"></p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="comment">// 如果一个联通块下相连了两个节点，那么成环</span></span><br><span class="line">        <span class="comment">// 树满足两个性质：1. n 个节点 n - 1条边 2. 无环</span></span><br><span class="line">        <span class="comment">// 1. n 个节点 n - 1条边</span></span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有无环就是判断两个联通块是否又被尝试链接，如果是，那么就有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!uf.isConnected(p, q)) {</span><br><span class="line">                uf.union(p, q);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS-Visited"><a href="#DFS-Visited" class="headerlink" title="DFS + Visited"></a>DFS + Visited</h3><p>比较困难的地方在于如何能够判断环即如何使用visited数组，由于这是个无向图，那么比如 <code>0 &lt;-&gt; 1</code> 节点0在遍历邻居1后，邻居1还会遍历它的邻居0，所以会被visited阻止，解决办法是传入一个parent变量，从而可以追踪目前的父节点。当当前节点的邻居和父节点为同一节点时跳过。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        buildGraph(n);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], b = edges[i][<span class="number">1</span>];</span><br><span class="line">            add(a, b);</span><br><span class="line">            add(b, a);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>, -<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">boolean</span> v : visited) { <span class="comment">// Checks if all nodes are visited</span></span><br><span class="line">            <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">        graph.get(from).add(to);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        List&lt;Integer&gt; neighbours = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neig : neighbours) {</span><br><span class="line">            <span class="keyword">if</span> (neig == parent) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(neig, cur)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">理解一下并查集</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="并查集" scheme="http://ruobingw.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="http://ruobingw.com/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra</title>
    <link href="http://ruobingw.com/2023/09/07/Dijkstra/"/>
    <id>http://ruobingw.com/2023/09/07/Dijkstra/</id>
    <published>2023-09-07T14:30:04.000Z</published>
    <updated>2023-09-08T12:40:23.885Z</updated>
    
    
    <summary type="html">理解一下Dijkstra</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>链式前向星-LinkedForwardStar</title>
    <link href="http://ruobingw.com/2023/09/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    <id>http://ruobingw.com/2023/09/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</id>
    <published>2023-09-02T21:48:00.000Z</published>
    <updated>2023-09-08T16:19:50.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式前向星-Linked-Forward-Star"><a href="#链式前向星-Linked-Forward-Star" class="headerlink" title="链式前向星 - (Linked) Forward Star"></a>链式前向星 - (Linked) Forward Star</h1><p>它是一种存图的方式，是优化过的<strong>邻接表</strong>的表达方式</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>为了方便，我们约定 k 为点数，m 为边数。</strong></p><p>邻接矩阵：适用于边数较多的<strong>「稠密图」</strong>使用，当边数量接近点的数量的平方，即 <strong>「m ≈ n^2」</strong> 时，可定义为<strong>「稠密图」</strong>。</p><p>邻接表：适用于边数较少的<strong>「稀疏图」</strong>使用，当边数量接近点的数量，即 <strong>「m ≈ n」</strong> 时，可定义为<strong>「稀疏图」</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> {</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>idx</code> 是用来对边进行编号的，然后对存图用到的几个数组作简单解释：</p><ul><li><code>he</code> 数组：存储是某个节点所对应的边的集合（链表）的头结点；</li><li><code>e</code> 数组：由于访问某一条边指向的节点；</li><li><code>ne</code> 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边；</li><li><code>w</code> 数组：用于记录某条边的权重为多少。</li></ul><p>因此当我们想要遍历所有由 <code>a</code> 点发出的边时，可以使用如下方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i]) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i], c = w[i]; <span class="comment">// 存在由 a 指向 b 的边，权重为 c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自己整理的java版本：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedForwardStar</span> {</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>[] edge = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    LinkedForwardStar() {</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span> {</span><br><span class="line">        edge[tot] = b; <span class="comment">// 设置边的终点</span></span><br><span class="line">        next[tot] = head[a]; <span class="comment">// 设置该边的下一条边</span></span><br><span class="line">        weight[tot] = w; <span class="comment">// 设置该边的权重</span></span><br><span class="line">        head[a] = tot; <span class="comment">// 更新节点 u 的出边起始位置</span></span><br><span class="line">        tot++; <span class="comment">// 增加边数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseFrom</span><span class="params">(<span class="type">int</span> a)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Traversing from node "</span> + a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[a]; i != -<span class="number">1</span>; i = next[i]) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weight[i];</span><br><span class="line">            System.out.println(a + <span class="string">" -&gt; "</span> + v + <span class="string">" weight: "</span> + w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LinkedForwardStar</span> <span class="variable">lfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedForwardStar</span>();</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 遍历从各个节点出去的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            lfs.traverseFrom(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p><a href="https://mp.weixin.qq.com/s/2Ba8-NI7lQh2_MvMpg-CZg">图论 - 存图方式 - 三叶</a></p><p>非链式前向星的建图方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) {</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">理解一下链式前向星</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="邻接表" scheme="http://ruobingw.com/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>从二叉树到回溯到DP</title>
    <link href="http://ruobingw.com/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/"/>
    <id>http://ruobingw.com/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/</id>
    <published>2023-08-20T20:12:52.000Z</published>
    <updated>2023-10-19T03:38:36.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>暂略，已经练习很多了</p><p>见 <a href="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a> 中包含所有二叉树</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：<br><a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵茶山艾府 - 回溯 - [14 - 16]</a></p><p>自己之前也收集过：见 <a href="/2023/04/20/%E5%9B%9E%E6%BA%AF/" title="回溯">回溯</a> </p></div><blockquote><p>回溯有一个增量构造答案的过程，这个过程通常使用递归来实现。选 “a”, “b”, “c” 选 “ad” …</p></blockquote><blockquote><p>递归： 考虑好边界条件以及和非边界条件写对即可。剩下交给数学归纳法</p></blockquote><p>回溯/动归三问：-&gt; 主要是为了写对 <strong>边界条件以及和非边界条件</strong></p><ul><li><p>当前操作是什么？</p></li><li><p>子问题是什么？</p></li><li><p>下一个子问题是什么？</p></li></ul><h2 id="子集型"><a href="#子集型" class="headerlink" title="子集型"></a>子集型</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以有两种思路：</p><p>站在输入的角度：</p><p>枚举第 i 个元素 你是<strong>选/不选</strong></p><blockquote><p>ps: 01背包与此相似</p></blockquote><p>每个数都可以在子集中，也可以不在子集中</p><p>此时：<strong>叶子结点是答案</strong></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E8%BE%93%E5%85%A5%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_输入角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作 <ol><li>枚举第 i 个数<strong>选/不选</strong></li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= i + 1的数字中构造子集</li></ol></li></ol><p>站在<strong>答案</strong>角度：</p><p>枚举第一个数选择谁，第二个数选择谁，</p><p>此时：<strong>每个节点都是答案</strong></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E7%AD%94%E6%A1%88%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_答案角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作 <ol><li>枚举答案的第一个数选什么第二个数选什么…</li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= j + 1的数字中构造子集</li></ol></li></ol><h2 id="组合型"><a href="#组合型" class="headerlink" title="组合型"></a>组合型</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>子集 + 剪枝 = 组合型问题</p><p>下图（左选两个数，右选三个数）</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E7%BB%84%E5%90%88%E5%9E%8B%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D1.png" alt="组合型回溯-剪枝1"></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/77_%E6%80%9D%E8%B7%AF.png" alt="77_思路"></p><blockquote><p>为什么从大到小枚举呢？</p></blockquote><p>假设我们需要选 3 个数，现在已经选了1个了，即 k = 3, m = 1; 我们还需要选择 d = k - m -&gt; 3 - 1 = 2 个数</p><p>由于是从大到小枚举，那么我们如果 i &lt; d; 即要选的数为[1,1] 也就是1的话那么是无论如何都没办法选出来两个数 k = 2 的（这是因为题目的范围是[1,n]）所以从大到小会比较容易剪枝</p><blockquote><p>正序枚举怎么做呢？</p></blockquote><p><code>k - path.size()</code> 是 我们还需要几个</p><p>我们要判断的就是还需要的能否被正确的提供，当前我们剩余的个数是 <code>n - i + 1</code></p><p>因此如果需要的不能被满足，直接提前截止即可 <code> if (k - path.size() &gt; n - cur + 1) return;</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于组合型和子集型回溯有两种思考路径：</p><ul><li>选或不选 - 输入视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></li></ul></li><li>枚举选哪个 - 输出视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">分割回文串</a></li></ul></li></ul><h2 id="排列型"><a href="#排列型" class="headerlink" title="排列型"></a>排列型</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%8E%92%E5%88%97%E5%9E%8B%E5%9B%9E%E6%BA%AF.png" alt="排列型回溯"></p><p>和组合的区别就在于<code>[2, 1]</code> 和 <code>[1, 2]</code>在组合中被认定为一种，但是排列中则是两种不同的</p><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：</p><p>灵茶山艾府：</p><p><a href="https://www.bilibili.com/video/BV1Xj411K7oF/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">从记忆化搜索到<strong>递推</strong></a></p><p><a href="https://www.bilibili.com/video/BV1AM4y1x7r4/?spm_id_from=333.999.0.0">选或不选 vs 枚举选哪个</a></p></div><p>主要还是<br>状态定义 + 状态转移</p><p>可以借用子集型回溯中的</p><p>选或不选 / 选哪个</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E5%90%AF%E5%8F%91.png" alt="dp_启发"></p><h2 id="从上至下-记忆化搜索"><a href="#从上至下-记忆化搜索" class="headerlink" title="从上至下 - 记忆化搜索"></a>从上至下 - 记忆化搜索</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.png" alt="dp_记忆化搜索"></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2_2.png" alt="dp_记忆化搜索_2"></p><h2 id="从下而上-递推"><a href="#从下而上-递推" class="headerlink" title="从下而上 - 递推"></a>从下而上 - 递推</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E9%80%92%E5%BD%92%E5%88%B0%E9%80%92%E6%8E%A8.png" alt="dp_递归到递推"></p><h1 id="回溯例题"><a href="#回溯例题" class="headerlink" title="回溯例题"></a>回溯例题</h1><h2 id="子集型-1"><a href="#子集型-1" class="headerlink" title="子集型"></a>子集型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17. 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</span><br><span class="line">78. 子集 https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/</span><br><span class="line">131. 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</span><br><span class="line">784. 字母大小写全排列 https://leetcode.cn/problems/letter-case-permutation/</span><br><span class="line">1601. 最多可达成的换楼请求数目 https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/</span><br><span class="line">2397. 被列覆盖的最多行数 https://leetcode.cn/problems/maximum-rows-covered-by-columns/</span><br><span class="line">306. 累加数 https://leetcode.cn/problems/additive-number/ </span><br><span class="line">2698. 求一个整数的惩罚数 https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/</span><br></pre></td></tr></tbody></table></figure><h2 id="组合型-1"><a href="#组合型-1" class="headerlink" title="组合型"></a>组合型</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">77. 组合 https://leetcode.cn/problems/combinations/solutions/2071017/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-65lh/</span><br><span class="line">216. 组合总和 III https://leetcode.cn/problems/combination-sum-iii/solutions/2071013/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-feme/</span><br><span class="line">22. 括号生成 https://leetcode.cn/problems/generate-parentheses/solutions/2071015/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-wcdw/</span><br><span class="line">301. 删除无效的括号 https://leetcode.cn/problems/remove-invalid-parentheses/</span><br></pre></td></tr></tbody></table></figure><h2 id="排列型-1"><a href="#排列型-1" class="headerlink" title="排列型"></a>排列型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">46. 全排列 https://leetcode.cn/problems/permutations/solutions/2079585/hui-su-bu-hui-xie-tao-lu-zai-ci-jing-que-6hrh/</span><br><span class="line">51. N 皇后 https://leetcode.cn/problems/n-queens/solutions/2079586/hui-su-tao-lu-miao-sha-nhuang-hou-shi-pi-mljv/</span><br><span class="line">52. N 皇后 II（直接用 51 题代码搞定）https://leetcode.cn/problems/n-queens-ii/solution/hui-su-miao-sha-nhuang-hou-yi-ge-shi-pin-l41</span><br></pre></td></tr></tbody></table></figure><h1 id="子集型："><a href="#子集型：" class="headerlink" title="子集型："></a>子集型：</h1><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String[] hm = <span class="keyword">new</span> <span class="title class_">String</span>[] {</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">"abc"</span>,</span><br><span class="line">        <span class="string">"def"</span>,</span><br><span class="line">        <span class="string">"ghi"</span>,</span><br><span class="line">        <span class="string">"jkl"</span>,</span><br><span class="line">        <span class="string">"mno"</span>,</span><br><span class="line">        <span class="string">"pqrs"</span>,</span><br><span class="line">        <span class="string">"tuv"</span>,</span><br><span class="line">        <span class="string">"wxyz"</span></span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>[] digitCharArr;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">        digitCharArr = digits.toCharArray();</span><br><span class="line">        n = digitCharArr.length;</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">innerRes</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (innerRes.length() != <span class="number">0</span>) res.add(innerRes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> digitCharArr[curIdx] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hm[idx].length(); i++) {</span><br><span class="line">            sb.append(hm[idx].charAt(i));</span><br><span class="line">            backtrack(curIdx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E6%80%9D%E8%B7%AF.jpeg" alt="78_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>);</span><br><span class="line">        backtrackChooseFromEnumeration(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 选或不选</span></span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        path.addLast(nums[curIdx]);</span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// not select</span></span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackChooseFromEnumeration</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 枚举选哪个</span></span><br><span class="line">        paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">innerIdx</span> <span class="operator">=</span> curIdx; innerIdx &lt; n; innerIdx++) {</span><br><span class="line">            path.addLast(nums[innerIdx]);</span><br><span class="line">            backtrackChooseFromEnumeration(innerIdx + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选或不选：</p><p>每一次抉择（backtrackSelectOrNot function中）都只有两种选择，选或者不选，并且这种情况下只有叶子结点为答案，因此需要判断是否为叶子结点，如果是的话才加入答案中</p><p>枚举选哪个：</p><p>每一次枚举（backtrackChooseFromEnumeration中）都可以选择curIdx之后的数，且所有的节点都为答案，因此无需判断直接加入，只需要做好递归的边界即可</p><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/131_%E6%80%9D%E8%B7%AF.jpeg" alt="131_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] sCharArr;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        sCharArr = s.toCharArray();</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="comment">// backtrackEnumerate(0);</span></span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选择这个逗号 （最后一个char (i - 1) 一定要选）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            backtrackSelectOrNot(start, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择这个逗号</span></span><br><span class="line">        <span class="comment">// 检查是否回文</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtrackSelectOrNot(i + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumerate</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="comment">// 枚举子串的终点</span></span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">                path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                backtrackEnumerate(i + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (sCharArr[left] == sCharArr[right]) {</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><p>两个难点：</p><ol><li>决策树如何画</li><li>如何将char 小写变大写，大写变小写</li></ol><p>问题1:</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/784_%E6%80%9D%E8%B7%AF.png" alt="784_思路"></p><p>问题2:</p><a href="/2023/04/15/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/" title="Java碎碎念">Java碎碎念</a><p><code>char[idx] ^= 1 &lt;&lt; 5</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 回溯</span></span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题其实可以不用恢复现场，因为我们需要的是叶子结点；但是我们需要先处理 <code>不转换当前char</code>再处理<code>转换当前char</code>由于回溯发生在不转换，即没有变化，那也就不需要回溯现场了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2397-被列覆盖的最多行数"><a href="#2397-被列覆盖的最多行数" class="headerlink" title="2397. 被列覆盖的最多行数"></a><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数</a></h1><p>这道题关键在于枚举列然后计算覆盖的行然后统计最大即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] matrix, matrixCopy;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRows</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        matrixCopy = <span class="keyword">new</span> <span class="title class_">int</span>[m][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            matrixCopy[i] = matrix[i].clone();</span><br><span class="line">        }</span><br><span class="line">        backtrack(<span class="number">0</span>, numSelect);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - startIdx &lt; numSelect) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (numSelect == <span class="number">0</span>) {</span><br><span class="line">            max = Math.max(max, countCovers());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            backtrack(i + <span class="number">1</span>, numSelect - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = matrixCopy[r][i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countCovers</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (count == n) ret++; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a><a href="https://leetcode.cn/problems/additive-number/">306. 累加数</a></h1><p>这道题自己的做法是枚举切割的起始点，能做但是比较复杂；</p><p>如果回溯返回boolean想要记录结果的话：</p><p><code>if (backtrack()) return true</code></p><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">numSelected</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    LinkedList&lt;BigInteger&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> backtrack(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cutIdx)</span> {</span><br><span class="line">        <span class="comment">// System.out.println(path + " " + cutIdx);</span></span><br><span class="line">        <span class="keyword">if</span> (cutIdx == n) {</span><br><span class="line">            <span class="keyword">return</span> path.size() &gt;= <span class="number">3</span> &amp;&amp; check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num.charAt(cutIdx) == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (check(path.get(path.size() - <span class="number">2</span>), </span><br><span class="line">                path.get(path.size() - <span class="number">1</span>), BigInteger.ZERO)) {</span><br><span class="line">                    path.addLast(BigInteger.ZERO);</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    path.removeLast();   </span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                path.addLast(BigInteger.ZERO);</span><br><span class="line">                <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();  </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cutIdx; i &lt; n; i++) {</span><br><span class="line">                <span class="type">BigInteger</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(num.substring(cutIdx, i + <span class="number">1</span>));</span><br><span class="line">                path.addLast(current);</span><br><span class="line">                <span class="keyword">if</span> (path.size() &gt;= <span class="number">3</span> &amp;&amp; !check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), current)) {</span><br><span class="line">                    path.removeLast();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (backtrack(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(BigInteger a, BigInteger b, BigInteger c)</span> {</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        <span class="keyword">return</span> sum.equals(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://leetcode.cn/problems/additive-number/solutions/1201929/gong-shui-san-xie-hui-su-gao-jing-du-jia-6o6b/">三叶的解法</a>是枚举结束点</p><p>并且这里教了如何使用高精度加法：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String _num)</span> {</span><br><span class="line">        num = _num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">return</span> m &gt;= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num.charAt(u) == <span class="string">'0'</span> ? u + <span class="number">1</span> : n;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> u; i &lt; max; i++) {</span><br><span class="line">            cur.add(<span class="number">0</span>, num.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">2</span> || check(list.get(m - <span class="number">2</span>), list.get(m - <span class="number">1</span>), cur)) {</span><br><span class="line">                list.add(cur);</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(List&lt;Integer&gt; a, List&lt;Integer&gt; b, List&lt;Integer&gt; c)</span> {</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size() || i &lt; b.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.size()) t += a.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; b.size()) t += b.get(i);</span><br><span class="line">            ans.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) ans.add(t);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> c.size() == ans.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.size() &amp;&amp; ok; i++) {</span><br><span class="line">            <span class="keyword">if</span> (c.get(i) != ans.get(i)) ok = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">作者：宫水三叶</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/additive-number/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><h1 id="2698-求一个整数的惩罚数"><a href="#2698-求一个整数的惩罚数" class="headerlink" title="2698. 求一个整数的惩罚数"></a><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">2698. 求一个整数的惩罚数</a></h1><p>这道题非常有意思，可以用两个指针来做到选或不选的思路：</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.jpeg" alt="2698_选或不选"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 选或不选</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, <span class="number">0</span>, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (end == square.length) {</span><br><span class="line">            <span class="keyword">return</span> i == sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; square.length - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, start, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sum += sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(square, end + <span class="number">1</span>, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        sum -= sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sumUp</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++){</span><br><span class="line">            x = x * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从答案的视角枚举</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E6%9E%9A%E4%B8%BE.jpeg" alt="2698_枚举"></p><p>其实就是枚举逗号位置</p><p>在start = 0 时候 i尝试 0, 1, 2, 3 也就是[0,0],[0, 1], [0,2],[0,3] 即temp = 1, 12, 129, 1296 sum = <code>此时的 temp</code></p><p>在start = 1 时候 i尝试 1, 2, 3 也就是[1, 1], [1,2],[1,3] 即temp = 2, 29, 296; sum = <code>start = 0 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 2 时候 i尝试 2, 3 也就是[2,2],[2,3] 即temp = 9, 96; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 3 时候 i尝试 3 也就是[3,3] 即temp = 6; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code>  + <code>start = 2 时候的temp</code>+ <code>此时的 temp</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == square.length) <span class="keyword">return</span> target == sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 开始枚举</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; square.length; i++) {</span><br><span class="line">            temp = temp * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">            sum = sum + temp;</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, i + <span class="number">1</span>, target)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            sum = sum - temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="子集型总结"><a href="#子集型总结" class="headerlink" title="子集型总结"></a>子集型总结</h1><p>一般可以从选和不选以及枚举选哪个来做；</p><p>碰到需要选择切点的，类似于306, 以及2698题，我们可以先通过把一个数变成一个string或者char[]来进行枚举。</p><p>另外枚举状态下的回溯就是无非是当前层然后深入下一层然后碰到递归终点返回之后会继续尝试</p><p>其达成的效果就是当前层穷举，下一层穷举…</p><p>所以这就是所谓的递归不要管他是如何深入的。只要知道做了什么事，怎么出去，完成当前scope下的任务即可</p><h1 id="组合型-2"><a href="#组合型-2" class="headerlink" title="组合型"></a>组合型</h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><p>无优化剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从大到小枚举剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(n);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - path.size()) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i - <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从小到大枚举</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k - path.size() &gt; n - cur + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrackEnumeration(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">9</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() != k) <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选</span></span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选</span></span><br><span class="line">        path.addLast(cur);</span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h1><p>依旧是使用了选和不选的操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Character&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        m = <span class="number">2</span> * n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> parenthesisSum, <span class="type">int</span> leftParenthesisCount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum == m) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : path) {</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            paths.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 选左括号</span></span><br><span class="line">        <span class="keyword">if</span> (leftParenthesisCount &lt; n) {</span><br><span class="line">            path.addLast(<span class="string">'('</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选左括号（选右括号）</span></span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum - leftParenthesisCount &lt; leftParenthesisCount) {</span><br><span class="line">            path.addLast(<span class="string">')'</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是这个树的构成是要计算左右可选的括号数量而不是盲目的选或者不选。</p><p>比如：我们一开始会选择左括号，当不选择左括号的时候（左括号数量满足数量），我们会去选择有括号，这时候是不选左括号的下分情况的选择右括号的情况：（右括号的数量 &lt; 左括号的数量）</p><h1 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301. 删除无效的括号"></a><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h1><p>暴力的穷举每一个括号看是选择还是不选择</p><p>答案加入到数组里后从中选择最长的就是满足要求的，将最长的加入答案</p><p>另外判断一个字符串的括号是否合法的函数也很有意思，可以多学习一下, 思路是用代表左括号的指针移动，碰到左括号右移，右括号左移，如果left == 0证明合法，否则比如左括号的idx &lt; 0则代表右括号&gt;左括号数量，不合法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        n = s.length();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> filterResult();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">filterResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 筛选出最长的有效括号字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            maxLen = Math.max(maxLen, str.length());</span><br><span class="line">        }</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            <span class="keyword">if</span> (str.length() == maxLen) {</span><br><span class="line">                set.add(str);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb.toString())) {</span><br><span class="line">                paths.add(sb.toString());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>) {</span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 选择当前的括号</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不选择当前的括号</span></span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String sb)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sb.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 右括号比左括号多，肯定无效</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果左括号的数量等于右括号的数量，才是一个有效的括号字符串</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排列型-2"><a href="#排列型-2" class="headerlink" title="排列型"></a>排列型</h1><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">boolean</span>[] numAppeared;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        numAppeared = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        System.out.println(idx + <span class="string">" "</span> + path);</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!numAppeared[i]) {</span><br><span class="line">                numAppeared[i] = <span class="literal">true</span>;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                backtrack(idx + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                numAppeared[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意的有两个点：</p><ol><li>backtrack中的for loop 是 <code>i: [0, n)</code> 因为我们每一次都要看从 0 开始的然后通过boolean[] 来判断是否加入答案</li><li>注意递归时候是 <code>(idx + 1)</code> 而不是 <code>(i + 1)</code> <ol><li><code>idx</code>应该表示的是当前的排列中已经放置了多少数字，或者说正在为哪个位置选择数字。然后选择的是 <code>[0, n]</code></li></ol></li></ol><h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>这道题有两种思维方式，首先是 <a href="https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-c26da/">labuladong</a>的比较好理解的，其次是<a href="https://www.bilibili.com/video/BV1mY411D7f6/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵神</a>的通过抽屉原理证明的全排列</p><p>其方法核心大差不差，主要是在构造上</p><p>核心：枚举每一行上的皇后的全排列，在不冲突的前提下进行构造</p><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><p>labuladong版本：</p><p>整体比较长，每一次都需要判断左上和右上角是否冲突</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chessRow : chessBoard) {</span><br><span class="line">            Arrays.fill(chessRow, <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backtracking(chessBoard, curRow, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curRow == n) {</span><br><span class="line">            <span class="comment">// 到叶子结点，将此时的棋盘加入答案</span></span><br><span class="line">            res.add(array2List(chessBoard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">curCol</span> <span class="operator">=</span> <span class="number">0</span>; curCol &lt; n; curCol++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(chessBoard, curRow, curCol)) {</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'Q'</span>;</span><br><span class="line">                backtracking(chessBoard, curRow + <span class="number">1</span>, n);</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> curCol)</span> {</span><br><span class="line">        <span class="comment">// 检查同一列是不是已经有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; curRow; r++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][curCol] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 \ 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol - <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; r--, c--) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 / 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; chessBoard[<span class="number">0</span>].length; r--, c++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span> {</span><br><span class="line">        List&lt;String&gt; transformedArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> chessBoard.length, c = chessBoard[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessBoard) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">                sb.append(chars[j]);</span><br><span class="line">            }</span><br><span class="line">            transformedArray.add(sb.toString());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transformedArray;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>灵神的第一个版本也需要判断：</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A7%A3%E6%B3%951.png" alt="N皇后_灵神_解法1"></p><p>但是加入了一点数学证明：即右上方的 r + c == 当前的 r + c 左上方的 r - c == 当前的 r - c:</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A1%8C%E5%88%97.png" alt="N皇后_灵神_行列"></p><p>从而发现我们可以通过开辟两个<code>boolean[]</code>来看r + c是否之前出现过如果出现过就说明当前位置无法放置皇后因为会冲突</p><p>修改过后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            List&lt;String&gt; board = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c : col) {</span><br><span class="line">                <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">                Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">                row[c] = <span class="string">'Q'</span>;</span><br><span class="line">                board.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">            }</span><br><span class="line">            paths.add(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="52-N-皇后-II"><a href="#52-N-皇后-II" class="headerlink" title="52. N 皇后 II"></a><a href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h2><p>只需要稍微更改下逻辑即可：这里我们返回计数而不是构造了一个答案</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="DP例题"><a href="#DP例题" class="headerlink" title="DP例题"></a>DP例题</h1><h1 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h1><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">198. 打家劫舍 https://leetcode.cn/problems/house-robber/solutions/2102725/ru-he-xiang-chu-zhuang-tai-ding-yi-he-zh-1wt1/</span><br><span class="line">70. 爬楼梯 https://leetcode.cn/problems/climbing-stairs/</span><br><span class="line">746. 使用最小花费爬楼梯 https://leetcode.cn/problems/min-cost-climbing-stairs/</span><br><span class="line">2466. 统计构造好字符串的方案数 https://leetcode.cn/problems/count-ways-to-build-good-strings/</span><br><span class="line">213. 打家劫舍 II https://leetcode.cn/problems/house-robber-ii/</span><br><span class="line">213. 打家劫舍 II 题解 https://leetcode.cn/problems/house-robber-ii/solution/jian-ji-xie-fa-zhi-jie-diao-yong-198-ti-qhvri/</span><br></pre></td></tr></tbody></table></figure><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><p>按照思路一步步来：</p><ol><li>回溯怎么写：<ol><li>当前操作：选或者不选当前这家偷</li><li>子问题和下一个子问题：<ol><li>如果之前偷了，那就是从 n - 2开始</li><li>如果之前不偷，那就是从 n - 1开始</li></ol></li></ol></li></ol><p>回溯代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里的回溯定义，返回了从 n - 1开始之前的打家劫舍的最大值</p><p>加入记忆化搜索：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] cache;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cache[i] != -<span class="number">1</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        cache[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改造为递推 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        dp[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i + <span class="number">2</span>] = Math.max(dp[i + <span class="number">1</span>], dp[i] + nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空间优化（由于 i + 2 只和i + 1 以及 i 有关）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>由于现在是环形那么我们就是在原版的198中增加了一些条件限制：</p><ul><li>如果选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>2</code>开始；因为是环形，偷了第<code>i = 0</code>个意味着不能偷<code>i = n - 1</code>，也就是 偷<code>n - 2</code><ul><li>因此问题变成从<code>nums[2]</code> 到 <code>nums[n−2]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li><li>如果<code>不</code>选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>1</code>开始；因为是环形，偷了第 <code>i = 1</code>个意味着不能偷<code>i = n - 2</code>，也就是 偷<code>n - 1</code><ul><li>因此问题变成从<code>nums[1]</code> 到 <code>nums[n−1]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robFromLC198(nums, <span class="number">2</span>, n - <span class="number">2</span>) + nums[<span class="number">0</span>], robFromLC198(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robFromLC198</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h1><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p><ul><li>爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶</li><li>爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</li></ul><p>所以我们得到公式 dp[n]=dp[n−1]+dp[n−2]<br>同时需要初始化 dp[0]=1 和 dp[1]=1<br>时间复杂度：O(n)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 来表示到第i层的最低开销 dp[cost.length] 就是 到最顶</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        Arrays.stream(dp).forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后是基于dp数组的空间优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> <span class="number">0</span>, dpi2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) {</span><br><span class="line">            minCost = Math.min(dpi1 + cost[i - <span class="number">1</span>], dpi2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = minCost;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后是这次写出来的版本：根本区别是我定义是到达这个位置的最小成本（初始化f0 = cost[0] f1 = cost[1]）而之前的是初始化为0</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> cost[<span class="number">0</span>], f1 = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> Math.min(f0, f1) + cost[i];</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.min(f0, f1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2466-统计构造好字符串的方案数"><a href="#2466-统计构造好字符串的方案数" class="headerlink" title="2466. 统计构造好字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h1><ol><li>题目中：请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。<ol><li>范围比较大，就是大概率dp问题</li></ol></li><li>这道题和 70 题类似思路是：<ol><li>dp定义：dp[i] 是当前长度为i的字符串数目<ol><li>所以答案是 dp[row] + … + dp[high]</li></ol></li><li>状态转移：和 70 题类似：<ol><li>70 是要么一次爬一级楼梯要么爬两级所以转移从 i - 1 以及 i - 2 得到</li><li>这道题是 转移从 zero 或者 one 得到 <ol><li>i - zero 为末尾加了 zero 个 零</li><li>i - one 为 末尾 加了 one 个 一</li></ol></li></ol></li><li>初始化 技巧：涉及到方案数我们可以列举Corner Case e.g.: 如果是空串，那么就是 <code>f[0] = 1</code>空串的字符串个数为1</li><li>取MOD</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= high; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) dp[i] = (dp[i] + dp[i - zero]) % MOD ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) dp[i] = (dp[i] + dp[i - one]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) {</span><br><span class="line">            ans = (ans + dp[i]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">输出：8</span><br></pre></td></tr></tbody></table></figure><p>我们有dp数组：1 2 4 8</p><ul><li><code>dp[1]</code> = 2 (可以由1个1组成 或者 由1个0)</li><li><code>dp[2]</code> = 4 (<code>1</code>0， <code>1</code>1，<code>0</code>1，<code>0</code>0）</li><li><code>dp[3]</code> = 8 (<code>10</code>0，<code>10</code>1，<code>11</code>0，<code>11</code>1，<code>01</code>0，<code>01</code>1，<code>00</code>0，<code>00</code>1)</li></ul><p>所以就是每一次都将<code>添加1或0后的形成的方案数</code>+ <code>之前的结果转移</code>得到</p>]]></content>
    
    
    <summary type="html">记录下二叉树到DP的练习过程以及思路总结</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="二叉树" scheme="http://ruobingw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="回溯" scheme="http://ruobingw.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="backtrack" scheme="http://ruobingw.com/tags/backtrack/"/>
    
  </entry>
  
  <entry>
    <title>周赛记录</title>
    <link href="http://ruobingw.com/2023/08/20/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://ruobingw.com/2023/08/20/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2023-08-20T18:34:53.000Z</published>
    <updated>2023-08-20T06:39:36.538Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>🐛🦆！（飘了）</p></div><h1 id="第-359-场周赛"><a href="#第-359-场周赛" class="headerlink" title="第 359 场周赛"></a>第 359 场周赛</h1>]]></content>
    
    
    <summary type="html">记录下周赛</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="周赛" scheme="http://ruobingw.com/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>面试经验集合</title>
    <link href="http://ruobingw.com/2023/08/16/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/"/>
    <id>http://ruobingw.com/2023/08/16/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/</id>
    <published>2023-08-16T15:06:02.000Z</published>
    <updated>2023-10-03T21:28:20.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>集合类</p><ol><li>collection list set queue<br>LinkedList arraylist 区别<br>LinkedBlockingQueue</li><li>Map hashmap linkedhashmap sortMap<br>cuccrenthashmap</li></ol><p>多线程</p><ol><li>用到那些多线程框架<br>newCachedThreadPool newFixedThreadPool newSingleThreadExecutor newScheduleThreadPool</li></ol><p>锁</p><ol><li>synchronized ReentrantLock 区别<br>lock</li><li>公平锁/非公平锁</li><li>可重入锁 synchronized</li><li>独享锁/共享锁</li><li>互斥锁/读写锁 ReentrantLock</li><li>乐观锁/悲观锁 区别？ CAS算法</li><li>分段锁 ConcurrentHashMap</li></ol><p>tpc三次握手和四次挥手</p><p>epoll和select区别</p><p>设计模式<br>主要用到那些<br>Singleton 工厂 代理模式</p><p>spring 中用到的动态代理<br>动态代理实现和种类，区别</p><p>jvm回收，java的类加载机制</p><p>微服务，服务注册发现</p><p>docker k8s</p><p>数据库<br>介绍下sql优化经验<br>数据库有哪些常用的引擎，主要区别，索引的实现原理<br>b数，b+数的区别</p><p>动态内容<br>HA+Nginx<br>mybatis 动态分页组件<br>zookeeper 应用场景，一致性hash运用<br>对java 高并发的rpc框架<br>本地缓存+分布式缓存</p><p>1、关于spring的aop的实现方法<br>2、关于分布式消息队列，分布式缓存<br>3、关于rpc方面<br>4、关于hashmap源码实现<br>5、关于Java异常的续承层次结构，讲述异常的续承关系<br>6、关于https握手过程<br>7、关于java数据库问题定位和性能调优<br>8、关于设计模式，uml，jvm 内存回收机制问题<br>9、java中重载和重写有什么区别？分别用什么关键字？<br>10、java线程如何启动？<br>11、java中加锁的方式有哪些，怎么个写法？<br>12、乐观锁和悲观锁解释一下<br>13、ORACLE中的SQL如何进行优化，都有哪些方式？<br>14、java中类的加载机制<br>15、介绍一下自己最近做的一个典型的项目<br>16、在项目中遇到了哪些问题，自己是如何解决的<br>17、说一下有哪些常用的设计模式<br>18、事务有哪些特性，在ORACLE中隔离有哪些级别<br>19、使用memcached是一个什么样的原理<br>20、如何存放数据到memcached集群中，介绍一下这个过程。跟进的问题，讲一下一致性哈希算法的实现原理。<br>21、JVM中堆是如何管理的，JVM的内存回收机制，介绍一下<br>22、数据库慢查询优化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//笔试题目: 无</span></span><br><span class="line"><span class="comment">// 一、基础</span></span><br><span class="line"><span class="comment">//1.面向对象的特征</span></span><br><span class="line"><span class="comment">//2.重载和重写的区别</span></span><br><span class="line"><span class="comment">//3.抽象类和接口的区别</span></span><br><span class="line"><span class="comment">//4.List和Set区别（Arraylist、LinkedList）</span></span><br><span class="line"><span class="comment">//5.HashMap（原理及实现）</span></span><br><span class="line"><span class="comment">//6.线程池的原理及实现（ThreadLocal）</span></span><br><span class="line"><span class="comment">//7.JVM运行时内存区域(内存溢出OOM问题)</span></span><br><span class="line"><span class="comment">//8.常见的设计模式？简单介绍1~2个</span></span><br><span class="line"><span class="comment">//9.MySQL个人简单总结（索引优化）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 二、代码</span></span><br><span class="line"><span class="comment">//1.饿汉式、懒汉式的单例模式Java代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Databricks-数据🧱"><a href="#Databricks-数据🧱" class="headerlink" title="Databricks 数据🧱"></a>Databricks 数据🧱</h1><a href="/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="DataBricks">DataBricks</a>]]></content>
    
    
    <summary type="html">记录下面试</summary>
    
    
    
    <category term="面经" scheme="http://ruobingw.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://ruobingw.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://ruobingw.com/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://ruobingw.com/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-12T01:58:16.000Z</published>
    <updated>2023-07-22T16:59:47.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>背包问题包含以下这些：<br><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E8%83%8C%E5%8C%85%E6%A6%82%E8%BF%B0.png" alt="背包概述"></p><p>主要需要掌握的是01背包以及完全背包</p><p>完全背包是01背包的演化，完全背包的物品数量无限</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>定义：</p><p>有 <code>n</code> 件物品和一个最多能背重量为<code>w</code>的背包。</p><p>第 <code>i</code>件物品的重量是<code>weight[i]</code>，可以得到的价值是<code>value[i]</code>。每件物品只能用一次</p><p>将哪些物品放入背包里物品价值总和最大。</p><p>暴力解法：对于每一个物品我们有两个选择，选或者不选，所以可以采用回溯法来搜索所有的情况时间复杂度为 O(2^n) n是物品数量</p><p>所以需要优化 穷举 + 求最值 -&gt; 动态规划</p><h3 id="题目假设"><a href="#题目假设" class="headerlink" title="题目假设"></a>题目假设</h3><p>背包最大重量为4，有如下的物品：</p><table><thead><tr><th>重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>目前最大价值为 4 * 15 = 60</p><h4 id="二维dp来解决01背包问题"><a href="#二维dp来解决01背包问题" class="headerlink" title="二维dp来解决01背包问题"></a>二维dp来解决01背包问题</h4><ol><li><p>分析dp数组含义</p><p><code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p></li><li><p>递推公式</p><p><code>dp[i][j]</code>能被转移过来的情况分成两种</p><p>如果不放物品，就是从<code>dp[i - 1][j]</code>转移而来，由于不放入新的重量所以其实重量就还是<code>dp[i - 1][j]</code> 可能的场景是：当物品i的重量超过了背包能够承载的容积，新的物品i无法放入其中</p><p>如果放物品，考虑<code>dp[i - 1][j - weight[i]]</code>含义为背包容量为 <code>j - weight[i]</code>时候的不放入i所能获得的最大价值，贪心一点，我们必须要腾出这部分的空间才行因为我们要保证背包是一直饱和的状态是当时的最优解。</p><p>在0-1背包问题中，<code>dp[i][j]</code>通常表示前i个物品填满背包容量为j的最大价值。<code>dp[i - 1][j - weight[i]]</code>表示的是在背包容量为<code>j-weight[i]</code>的时候，前<code>i-1</code>个物品的最大价值。之所以使用这个状态转移方程，是因为我们在考虑是否将第i个物品放入背包时，需要先确定在还没有放入第i个物品，并且背包容量为<code>j-weight[i]</code>时的最大价值。</p><p>这里的“j - weight[i]”是为了腾出第i个物品所需的空间，以便我们能够将其放入背包。之后，我们将该物品的价值<code>value[i]</code>加上<code>dp[i - 1][j - weight[i]]</code>，这样就能得到在将第i个物品放入背包的情况下，能够得到的最大价值。</p><p>简单来说，<code>dp[i - 1][j - weight[i]] + value[i]</code>就表示：在考虑放入第i个物品（即在已经腾出了第i个物品所需的空间后），我们能够得到的最大价值。如果不把这个空间腾出来，那我们就没有地方放这个物品。</p></li><li><p>初始化</p><p>我们首先要对一个二维的数组来进行初始化因此需要搞清楚 [i] 和 [j] 的含义</p><p>回想定义：<code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p><p>那么 <code>dp[i][0]</code>指的是如果背包容量j为0，表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为0的背包，价值总和最大为多少，那么明显是0</p><p>其次由于我们需要使用 <code>dp[i - 1][j]</code> 来作为其中一项来推导<code>dp[i][j]</code>因此我们需要初始化<code>dp[0][j]</code>即，存放编号0的各种容量的背包中能获得的最大价值那么会有两种情况：</p><p>当 <code>j &lt; weight[0]</code>的时候，<code>dp[0][j]</code> 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code> 应该是value[0]，因为背包容量放足够放编号0物品。</p></li></ol><p>​综上，对于上面的例子我们有：</p><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E5%88%9D%E5%A7%8B%E5%8C%961.png" alt="01背包初始化1"></p><p>对于其他的，由于都会被转化并且被覆盖新值，因此无论初始化成什么都可以</p><ol start="4"><li><p>确定遍历顺序</p><p>我们需要遍历是应该从物品[i]还是背包容积[j]开始</p><p>由于<code>dp[i][j]</code>所需要的数据就是左上角</p></li></ol><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F.png" alt="01背包遍历顺序"></p><p>所以无论从哪里开始都可以得到结果</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E7%BB%93%E6%9E%9C.jpeg" alt="01背包结果"></p><h4 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h4><p>由于<code>dp[i][j]</code>仅依赖于前一个物品的值（<code>dp[i - 1][j]</code> 和 <code>dp[i - 1][j - weight[i]]</code>），所以实际上我们并不需要维护一个二维数组，只需要一个一维数组就足够了。这个问题的特殊之处在于，<code>dp[i][j]</code>的值只依赖于<code>dp[i-1][*]</code>，即只依赖于前一个物品的状态。这给我们提供了一个优化空间，那就是我们其实不需要存储所有的i，也就是不需要存储所有物品的状态，只需要存储前一个物品的状态就足够了。这就是为什么我们可以省去一个维度的原因。我们使用一维数组dp[j]来替代二维数组<code>dp[i][j]</code>。在每一次的迭代中，dp[j]表示的都是在考虑当前物品，并且在背包容量为j的情况下，我们能获得的最大价值。换句话说，我们的一维数组dp[j]在每次迭代过程中，都相当于原来二维数组的<code>dp[i][j]</code>。</p><ol><li>dp数组含义：</li></ol><p>此时的含义就变为:</p><p>我们有容量为j的背包从前i个物品取能取到的最大价值</p><ol start="2"><li>转移方程递推公式：</li></ol><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>即：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>初始化：</li></ol><p>最初dp[0]容量为0的背包，那么最大价值一定为0</p><ol start="4"><li>遍历顺序</li></ol><p><strong>重点</strong>：在这个优化策略中，我们必须从大到小遍历j，这是因为dp[j - weight[i]]必须在dp[j]之前更新。原因是我们在每次迭代中都在复用上一轮迭代中的结果。为了确保这次迭代的结果不会影响到下一次迭代，我们需要从大到小遍历j。</p><p>具体地说，如果我们从小到大遍历j，考虑在计算dp[j]时，由于dp[j - weight[i]]可能在这个迭代过程中已经被更新过（因为j - weight[i] &lt; j），我们就会使用到这个物品i在多次的情况，这明显违反了我们的原始假设（每个物品只能用一次）。为了避免这个问题，我们选择从大到小遍历j，在计算dp[j]时，dp[j - weight[i]]对应的就是上一轮迭代的结果，也就是没有使用过物品i的情况。</p><p>例如，假设我们有物品的重量和价值分别为2和3，背包的容量为4，初始化dp数组为0。如果从小到大遍历j，计算过程如下：</p><ul><li>当j=2时，dp[2] = max(dp[2], dp[2-2] + 3) = 3</li><li>当j=3时，dp[3] = max(dp[3], dp[3-2] + 3) = 3</li><li>当j=4时，dp[4] = max(dp[4], dp[4-2] + 3) = 6</li></ul><p>在这个例子中，dp[4]的值为6，明显不对，因为我们的物品只有一个，但我们却计算得到了两个物品的价值，这就是因为在计算dp[4]时，dp[2]已经使用过当前物品，被更新为3了。</p><p>结论：从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></h1><p>第一个难点是如何转化为01背包问题：</p><p>这道题首先我们要等和，所以一个背包的容积就是 sum / 2</p><p>那么我们就是看是不是<strong>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p><blockquote><p>注意不能直接看除2是否能除尽，因为除2不代表有对应的子集比如[1,2,5]</p></blockquote><p><code>dp</code> 数组的定义：<code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</p><p>根据 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case:</span></span><br><span class="line">        <span class="comment">// 意思是当没有物品时背包永远不可能被装满</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= col; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 意思是当背包容量为0时，直接就是满的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= row; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= col; j++) {</span><br><span class="line">                <span class="comment">// 背包容量不够的情形：</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 没有办法再放入当前的物品, 结果就是如果之前的能刚好放进去，那么现在不放也可以刚好放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果我 i 刚好能放进去，那么我放入nums[i]也刚好能放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt;= row; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= col; j++) {</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " ");</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化：</p><p>相当于i直接就是每一层搞一次，但我们不用存储 i - 1的结果了，直接覆盖就可以了</p><p>Eg: [1,2,5]</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>t</td><td>f</td><td>f</td><td>f</td><td>f</td></tr><tr><td>1</td><td>t</td><td>t</td><td>f</td><td>f</td><td>f</td></tr><tr><td>2</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr><tr><td>3</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[col + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col; j &gt;= <span class="number">1</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];  </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// StringBuilder result = new StringBuilder();</span></span><br><span class="line">            <span class="comment">// for (boolean element : dp) {</span></span><br><span class="line">            <span class="comment">//     result.append(element).append(" ");</span></span><br><span class="line">            <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// // Remove the trailing space before printing</span></span><br><span class="line">            <span class="comment">// System.out.println(result.toString().trim());</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049.最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量 II</a></h1><p>和416类似，重点是要知道如何转换为01背包问题</p><p>对于石头问题，我们想要的是尽量让两边相等然后看差值。</p><p>那么就是有个容量为 sum/2的背包，里面能够装的最大的重量，就是尽可能让两边相等的解法。</p><p>所以就是：</p><p>对于容积为sum/2的背包，我们有 stones[i] 价值的，重量为stones[i]的石头，怎么放，价值最大：</p><p>常规的二维dp：</p><blockquote><p>注意labuladong和代码随想录不一样，labuladong的i从1开始然后 i - 1是对应的价值。而代码随想录从0开始，i就是对应的价值了</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[stones.length + <span class="number">1</span>][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sum / <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &gt; j) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 打印dp数组 </span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; stones.length; i++) { </span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= sum / 2; j++) { </span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " "); </span></span><br><span class="line">        <span class="comment">//     } </span></span><br><span class="line">        <span class="comment">//     System.out.println(); </span></span><br><span class="line">        <span class="comment">// } </span></span><br><span class="line">        <span class="keyword">return</span> sum - dp[stones.length][sum / <span class="number">2</span>] - dp[stones.length][sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化，注意遍历顺序，（虽然道理已经明白了，可是还是不太懂这个到底是怎么优化的。。。）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum / <span class="number">2</span>; j &gt;= stones[i - <span class="number">1</span>]; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] - dp[sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h1><p>本题的关键难点在于如何做好问题转化，即怎么把这个问题转换为01背包问题：</p><p>这是一个经典的子集和问题（subset sum problem）转化。原始问题是从数组 <code>nums</code> 中选取若干数，可以加上+或-号，使得它们的总和为 <code>target</code>。问题被转化为找出 <code>nums</code> 中有多少个子集 <code>A</code> 使得这个子集的和等于 <code>(target + sum(nums)) / 2</code>。</p><p>为什么要这样转化呢？我们来详细理解下。</p><p>原始方程是：<br>[ sum(A) - sum(B) = target ]</p><p>其中，<code>A</code> 是被加上 <code>+</code> 号的子集，<code>B</code> 是被加上 <code>-</code> 号的子集。</p><p>再加上以下方程：<br>[ sum(A) + sum(B) = sum(nums) ]</p><p>两边都加上 <code>sum(A)</code>：<br>[ 2 \times sum(A) = target + sum(nums) ]</p><p>从这个方程，我们得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]</p><p>这就将原始问题转化为一个子集和问题，即从 <code>nums</code> 中找到所有子集 <code>A</code>，其和为 <code>(target + sum(nums)) / 2</code>。这是一个经典的动态规划问题，通常使用一个二维数组 <code>dp</code> 来解决。<code>dp[i][j]</code> 表示使用前 <code>i</code> 个数字，能否组成和为 <code>j</code> 的子集。</p><p>那么为什么是<code>(target + sum(nums)) / 2</code> 而不是 target呢？</p><p>假设<code>nums: [1,2,3,4]</code> 和 <code>target:4</code> 。</p><p>首先，我们看转化的方法：</p><ol><li><p>从 <code>nums</code> 中选择数字，有的加上 <code>+</code> 号，有的加上 <code>-</code> 号，使其总和为 <code>target</code>。</p></li><li><p>使用转化方法，我们得到以下方程：<br>[ sum(A) - sum(B) = target ]<br>[ sum(A) + sum(B) = sum(nums) ]<br>代入第一个方程得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]<br>[ sum(A) = (4 + 10) / 2 = 7 ]</p></li></ol><p>所以，我们需要找到 <code>nums</code> 中子集和为7的所有情况。</p><p>以下是子集和为7的组合：</p><ol><li>[1,2,4]</li><li>[3,4]</li></ol><p>这些组合可以得到如下的表示达到 target 4：</p><ol><li>+1+2+4-3</li><li>+3+4-1-2</li></ol><p>现在，如果我们直接找出 <code>nums</code> 中的子集和为 <code>target=4</code> 的组合，我们得到：</p><ol><li>[1,3]</li><li>[4]</li></ol><p>这些组合表示了如何通过简单组合 <code>nums</code> 中的数字得到4，但没有表示如何通过加法和减法操作得到4。这就是为什么直接使用 <code>target</code> 作为背包容量是不准确的，因为你只能得到部分答案，而不能表示如何通过整个 <code>nums</code> 数组的加减操作得到目标值 <code>target</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>][subSetTotal + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 注意一下这里的初始化，dp[i][0]因为现在有可能性什么都不装即有一种装法，即从dp[0][0]转移而来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length + <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subSetTotal + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>二维变一维：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[subSetTotal + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> subSetTotal; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">记录背包问题的相关习题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="背包" scheme="http://ruobingw.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://ruobingw.com/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://ruobingw.com/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-06-24T22:37:03.000Z</published>
    <updated>2023-10-05T22:42:47.043Z</updated>
    
    <content type="html"><![CDATA[<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>📚 此文档包含以下几个部分：</p><ul><li><a href="/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/" title="最长公共子序列">最长公共子序列</a></li></ul></div><h1 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h1><p>动态规划问题的一般形式就是<strong>求最值</strong>。核心问题是<strong>穷举</strong>。</p><p>比如最长递增子序列，最小编辑距离这种问题</p><p>列出正确的状态转移方程，</p><p>判读是否具备最优子结构（即是否可以通过自问题的最值的道原问题的最值）</p><p>是否可以使用数据结构来优化穷举过程以避免不必要的计算。</p><p>一般包含以下三要素：</p><p>重叠子问题，最优子结构，状态转移方程</p><p>对于状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自顶向下递归的动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">状态<span class="number">1</span>, 状态<span class="number">2</span>, ...</span>):</span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 所有可能的选择:</span><br><span class="line">        <span class="comment"># 此时的状态已经因为做了选择而改变</span></span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></tbody></table></figure><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h1 id="自顶向下和自底向上"><a href="#自顶向下和自底向上" class="headerlink" title="自顶向下和自底向上"></a>自顶向下和自底向上</h1><p>以<a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a>为例：</p><h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><p>自顶向下就像是DFS/递归，把大问题逐渐分解规模，直到base case。从上到下，然后逐层返回答案。（注意图中含有剪枝操作，好处是可以讲原本 O(2^n)的算法简化为 O(n)</p><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B1.jpeg" alt="自顶向下1"></p><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B2.jpeg" alt="自顶向下2"></p><h2 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h2><p>就是从问题规模最小的问题（base case）往上推直到得到问题的答案</p><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A1.jpeg" alt="自底向上1"></p><h1 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h1><p>依旧用509斐波那契数举例子：</p><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-fib.png" alt="状态转移方程-fib"></p><p><code>f(n)</code> 的函数参数会不断变化，所以你把参数 <code>n</code> 想做一个状态，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 转移（相加）而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式</p><h1 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h1><p>子问题间必须相互独立 -&gt; 最优子结构</p><p>例子：比如我想考第一名那么每一科目都考第一就能总成绩第一，但是一般数学高的话语文就会低，这就违背了子问题间相互独立</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>以<a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>为样例：</p><p>按照：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><ol><li>明确 base case:<ol><li>剩余钱为0时即不需要任何其他的硬币，达到结果</li></ol></li><li>明确「状态」</li><li>状态：原问题和子问题中会变化的变量：amount</li><li>由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</li><li>明确「选择」<ol><li>每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li></ol></li><li>dp<ol><li>函数：<ol><li>自顶向下<ol><li>函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。</li><li>就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</li><li><strong><code>dp(n)</code> 表示，输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 所需的最少硬币数量</strong>。</li></ol></li></ol></li><li>数组：<ol><li>自底向上<ol><li><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</li></ol></li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  <span class="type">int</span>[] memo;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      memo = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">      Arrays.fill(memo, -<span class="number">999</span>);</span><br><span class="line">      <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (memo[amount] != -<span class="number">999</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">subAmount</span> <span class="operator">=</span> dp(coins, amount - coin);</span><br><span class="line">          <span class="keyword">if</span> (subAmount &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">          res = Math.min(res, subAmount + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">      memo[amount] = (res == Integer.MAX_VALUE) ? -<span class="number">1</span> : res;</span><br><span class="line">      <span class="keyword">return</span> memo[amount];</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 自底向上：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">      <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">      Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) {</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">              <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">              dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="如何debug"><a href="#如何debug" class="headerlink" title="如何debug"></a>如何debug</h1><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong> 然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>其实就是斐波那契数</p><p>f[x] = f[x - 1] + f[x - 2]</p><p>自顶向下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n +<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> floor)</span> {</span><br><span class="line">        <span class="keyword">if</span> (floor == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (floor &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[floor] != <span class="number">0</span>) <span class="keyword">return</span> memo[floor];</span><br><span class="line">        memo[floor] = dp(floor - <span class="number">2</span>) + dp(floor - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[floor];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(System.out::println);</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(System.out::println);</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 来表示到第i层的最低开销 dp[cost.length] 就是 到最顶</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空间优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> <span class="number">0</span>, dpi2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) {</span><br><span class="line">            minCost = Math.min(dpi1 + cost[i - <span class="number">1</span>], dpi2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = minCost;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><ol><li>确定 dp 函数的含义：<ol><li><code>dp[i][j]</code> 代表 从 起点出发， 到 <code>(i,j)</code> 的路径方案总数</li></ol></li><li>确定递推公式<ol><li>由于方向只能从 <code>上面</code> 以及 <code>左面</code> 所以 <code>dp[i][j]</code> 会由 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>转移而来。</li><li><code>dp[i - 1][j]</code> 是从(0, 0)的位置到(i - 1, j)有几条路径，<code>dp[i][j - 1]</code>同理。</li></ol></li><li>初始化<ol><li><code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。</li></ol></li><li>确定遍历顺序<ol><li>我们要保证转移的顺序，因此 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 必须先由<code>dp[i][j]</code>计算完成</li><li>发现顺序遍历就可以达到这个效果，因此顺序遍历</li></ol></li><li>举例推导dp数组</li></ol><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc62_%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BC.png" alt="lc62_举例推导"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自顶向下：（但是memo其实就是dp table了）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> dp(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 代表 (0, 0) 到 (0, 0) 有一条路径</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        memo[i][j] = dp(i - <span class="number">1</span>, j) + dp(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h1><p>总体和 62 差别不大，但是在初始化时以及转移方程需要特别处理一下：</p><ol><li>确定dp数组（dp table）以及下标的含义<ol><li><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</li></ol></li><li>确定递推公式<ol><li>递推公式和62.不同路径一样，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li><li>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）</li></ol></li><li>初始化<ol><li>这里的区分比较大，主要是由于在第一行和第一列如果有了障碍，那么这个障碍之后的全部都应为0</li></ol></li></ol><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc63_1.png" alt="lc63_1"></p><ol start="4"><li>确定遍历顺序<ol><li>一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，<code>dp[i - 1][j] 和 dp[i][j - 1]</code>一定是有数值。</li></ol></li><li>举例推导dp数组</li></ol><p><img src="/2023/06/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lc63_%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BC.png" alt="lc63_举例推导"></p><p>自底向上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自顶向下 （记忆化搜索）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="type">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        grid = obstacleGrid;</span><br><span class="line">        <span class="keyword">return</span> dp(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        memo[i][j] = dp(i - <span class="number">1</span>, j) + dp(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h1><p>这道题主要难在怎么分：</p><p>一开始思维方式是dfs，求出来所有组合，然后每一个组合都要相乘，比较最大值，但是显然这样我们需要非常大的空间来存储。</p><p>用<code>dp[n]</code>来表示整数为n时，我们能够得到的最大乘积。</p><p>转移方程比较难想：</p><p>比方说 <code>n = 4</code>，我们可以把 4 拆分成 <code>1 + 3, 2 + 2</code>，对应的乘积就是 <code>1 * 3, 2 * 2</code>。但此时我们直接比较 <code>1 * 3, 2 * 2</code> 的大小还不够，因为 <code>3, 2</code> 它们可能还会被分解成 <code>1 * 2, 1 * 1</code>，也就是说把 <code>n = 4</code> 进一步分解成 <code>1 * (1 * 2), 2 * (1 * 1)</code>，这两种可能也要纳入考虑。</p><p>到底需不需要进一步分解呢？不知道，所以我们都穷举一遍取最大值就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  integerBreak(<span class="number">4</span>)</span><br><span class="line">= max(<span class="number">1</span> * <span class="number">3</span>, <span class="number">1</span> * integerBreak(<span class="number">3</span>), <span class="number">2</span> * <span class="number">2</span>, <span class="number">2</span> * integerBreak(<span class="number">2</span>))</span><br><span class="line">= max(</span><br><span class="line">    <span class="number">1</span> * max(<span class="number">3</span>, integerBreak(<span class="number">3</span>)),</span><br><span class="line">    <span class="number">2</span> * max(<span class="number">2</span>, integerBreak(<span class="number">2</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>其实就是拿着刚分解完的结果以及未来要分解的结果求最大值。</p><p>再加上 memo 来消除重叠子问题：</p><p>自顶向下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[n] 为 把n拆分后的乘积最大的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            result = Math.max(</span><br><span class="line">                result, </span><br><span class="line">                i * Math.max(dp(n - i), n - i)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        memo[n] = result;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上：</p><p>整体思路是差不多的，都是考虑了两种情况：</p><p><code>dp[i]</code>要么从 <code>dp[i - j] * j</code> 转移而来 要么从 <code>(i - j) * j</code> 转移而来，</p><p>由于<code>dp[i]</code>之前已经被赋值，因此我们仍需要加入最大值判断</p><p>比较特殊的点在于初始化：</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1。</p><p>以及遍历顺序：</p><p><code>dp[i]</code> 是依靠 <code>dp[i - j]</code>的状态，所以遍历i一定是从前向后遍历，先有<code>dp[i - j]</code>再有<code>dp[i]</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 表示 i 拆分后能够获得的最大乘积</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) {</span><br><span class="line">                dp[i] = Math.max(</span><br><span class="line">                    dp[i],</span><br><span class="line">                    Math.max(</span><br><span class="line">                        dp[i - j] * j, (i - j) * j</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>见 <a href="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" title="背包问题">背包问题</a> 中包含背包问题的思路</p>]]></content>
    
    
    <summary type="html">记录动态规划的相关习题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://ruobingw.com/2023/06/09/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://ruobingw.com/2023/06/09/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2023-06-09T19:31:19.000Z</published>
    <updated>2023-09-11T23:39:04.458Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>此教程参考  <a href="https://cloud.tencent.com/developer/article/1684188">什么是计数排序？</a> 感谢支持！</p></div><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><p>计数排序（Counting Sort）是一种针对于<strong>特定范围</strong>之间的整数进行排序的算法。它通过统计给定数组中不同元素的数量（类似于哈希映射），然后对映射后的数组进行排序输出即可。</p>]]></content>
    
    
    <summary type="html">整理下计数排序的知识</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="排序" scheme="http://ruobingw.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://ruobingw.com/2023/06/01/%E8%B4%AA%E5%BF%83/"/>
    <id>http://ruobingw.com/2023/06/01/%E8%B4%AA%E5%BF%83/</id>
    <published>2023-06-02T03:11:50.000Z</published>
    <updated>2023-10-05T19:17:02.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h1><p>核心：从局部最优到全局最优</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>找出局部的最优解，从而推出全局最优解</p><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h1><p>两个贪心思路：</p><p>大饼干喂大胃口 或者 小饼干喂小胃口</p><p>自己的解法：贪心 + 排序 + 双指针</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length;) {</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt;= g[i]) {</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他解法：贪心 + 排序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 思路1：优先考虑饼干，小饼干先喂饱小胃口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length &amp;&amp; start &lt; g.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= g[start]) {</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 思路2：优先考虑胃口，先喂饱大胃口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> {</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> g.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">            <span class="keyword">if</span>(start &gt;= <span class="number">0</span> &amp;&amp; g[index] &lt;= s[start]) {</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h1><p>贪心思想：（假装）删除单调坡度上的节点从而使得局部峰值++</p><p>需要分三种情况：</p><ul><li>上下坡中有平坡<ul><li>[1,2,2,2,1], 此时应返回3</li></ul></li><li>数组首尾两端</li><li>单调坡中有平坡</li></ul><h2 id="上下坡中有平坡"><a href="#上下坡中有平坡" class="headerlink" title="上下坡中有平坡"></a>上下坡中有平坡</h2><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc376%E4%B8%8A%E4%B8%8B%E5%9D%A1%E4%B8%AD%E6%9C%89%E5%B9%B3%E5%9D%A1.png" alt="lc376上下坡中有平坡"></p><p>添加 <code>preDiff = 0</code> 即可解决问题</p><h2 id="数组首尾两端"><a href="#数组首尾两端" class="headerlink" title="数组首尾两端"></a>数组首尾两端</h2><p>题目要求如果只有两个元素，且两个元素不想等，此时长度为2。</p><p>解决方法：补全开头的元素 -&gt; preDiff 初始值为0</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc376%E6%95%B0%E7%BB%84%E9%A6%96%E5%B0%BE%E4%B8%A4%E7%AB%AF.png" alt="lc376数组首尾两端"></p><h2 id="单调坡中有平坡"><a href="#单调坡中有平坡" class="headerlink" title="单调坡中有平坡"></a>单调坡中有平坡</h2><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc376%E5%8D%95%E8%B0%83%E5%9D%A1%E4%B8%AD%E6%9C%89%E5%B9%B3%E5%9D%A1.png" alt="lc376单调坡中有平坡"></p><p>此时结果应为2不为3，如果我们按照以下的代码更新 <code>preDiff</code>就会出现问题，因为此时preDiff直接，实时地更新为curDiff：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) {</span><br><span class="line">                result++;</span><br><span class="line">            }</span><br><span class="line">            preDiff = curDiff; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解决方法：preDiff当且仅当摆动时才更新</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上我们有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 解决情况二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (checkWiggle(preDiff, curDiff)) {</span><br><span class="line">                result++;</span><br><span class="line">                <span class="comment">// preDiff 只在有摆动的时候更新，主要解决情况三：单调有平坡</span></span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkWiggle</span><span class="params">(<span class="type">int</span> preDiff, <span class="type">int</span> curDiff)</span> {</span><br><span class="line">      <span class="comment">// 解决情况1</span></span><br><span class="line">        <span class="keyword">if</span> (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span> || preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PS:本题也可以使用动态规划：（当前仅了解，tbc…）</p><ul><li>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</li><li>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</li></ul><p>转移方程为：</p><ul><li><code>dp[i][0] = max(dp[i][0], dp[j][1] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &lt; nums[i]</code>，表示将 nums[i]接到前面某个山谷后面，作为山峰。</li><li><code>dp[i][1] = max(dp[i][1], dp[j][0] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &gt; nums[i]</code>，表示将 nums[i]接到前面某个山峰后面，作为山谷。</li></ul><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="lc53最大子序和"></p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>连续和 + 当前数，如果连续和 &lt; 0 那么直接取当前数作为新的开始。因为连续和&lt;0必定会拖累当前数的值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            count += curNum;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) result = count; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>本题的贪心用法在于一个数学思想：</p><p>比如我们需要计算第三天卖出第零天买入能够产生的利润，那么就是 <code>profit[3] - profit[0]</code>. 巧妙的利用下数学性质：</p><p><code>profit[3] - profit[0] = proft[3] - profit[2] + profit[2] - profit[1] + profit[1] - profit[0]</code></p><p>也就是每一天的利润差额。</p><p>因此：</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc122_greedy.png" alt="lc122_greedy"></p><p>因此我们只需要收集两天股票差额为正数的利润就可以拿到最终全局的一个最大利润，即局部最优到全局最优。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">           <span class="type">int</span> <span class="variable">curProfit</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span> (curProfit &gt; <span class="number">0</span>) sum += curProfit;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><p>首先我们不需要实际的知道要跳到哪里，我们只需要知道覆盖范围即可，因为在这个最大范围中，不管怎么跳都可以跳到。</p><p>因此检查覆盖范围是否包含终点就是我们要的结果。</p><p>贪心思想：<strong>每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 每一次都选能走的最大的步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) {</span><br><span class="line">            cover = Math.max(cover, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>和上一道题的区别在于，此题需要计算能够到终点的步数。因此在继承了上一步的 <strong>覆盖范围</strong> 的思路上我们需要知道什么时候把返回值增加。</p><p>覆盖范围不变，当index到了当前能覆盖的最远距离时，返回值增加。因为当前覆盖的范围是无论如何都能达到的。</p><p>贪心思想：覆盖范围最大，使用的步数最少。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>, nextCover = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            nextCover = Math.max(nextCover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curCover) {</span><br><span class="line">                count++;</span><br><span class="line">                curCover = nextCover;</span><br><span class="line">                <span class="keyword">if</span> (nextCover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h1><p>贪心 + 分情况讨论</p><p><code>取反一个负数会使得结果变大，取反正数会使结果变小，取反 0 值对结果没有影响</code></p><p>如果想要把 nums[i] 替换为 -nums[i] 并且想要得到可能的最大和。那么我们应该尽量：</p><ol><li>更改负数，将负数变为正数</li><li>将正数的值小的数变为负数从而减少影响。</li></ol><p>因此需要按照绝对值的大小来进行降序排序。然后优先更改负数。如果k&lt;负数个数的情况直接返回结果，但如果 <em>K</em> 的值较大，那么我们不得不去修改非负数（即正数或者 0）了：</p><ul><li>如果数组中存在 0，那么我们可以对它进行多次修改，直到把剩余的修改次数用完；</li><li>如果数组中不存在 0 并且剩余的修改次数是偶数，由于对同一个数修改两次等价于不进行修改，因此我们也可以在不减小数组的和的前提下，把修改次数用完；</li><li>如果数组中不存在 0 并且剩余的修改次数是奇数，那么我们必然需要使用单独的一次修改将一个正数变为负数（剩余的修改次数为偶数，就不会减小数组的和）。为了使得数组的和尽可能大，我们就选择那个最小的正数。</li></ul><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>这道题可以用<a href="/2023/06/09/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/" title="计数排序">计数排序</a>来优化（June 9th： 还在学习计数排序）</p></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        Integer[] numsInt = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.sort(numsInt, (a, b) -&gt; Math.abs(b) - Math.abs(a));</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; numsInt.length &amp;&amp; k &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (numsInt[idx] &lt; <span class="number">0</span>) {</span><br><span class="line">                numsInt[idx] = -numsInt[idx]; </span><br><span class="line">                k--;</span><br><span class="line">            } </span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) numsInt[numsInt.length - <span class="number">1</span>] = -numsInt[numsInt.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : numsInt) result += a;        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h1><p>这道题的思路有点像跳跃游戏，同样需要看覆盖范围。</p><ol><li>若总油量 &gt; 总消耗，那么一定有办法绕一圈</li><li>记录一个curSum来跟踪当前油量和，如果curSum &lt; 0那么说明<strong>之前无论怎么走都无法达到当前的点i，因此从下一个点开始找，并且重置curSum</strong></li></ol><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc_%E5%8A%A0%E6%B2%B9%E7%AB%99.png" alt="lc_加油站"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h1><p>左右扫描两次 + 贪心</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc135_%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.png" alt="lc135_分发糖果"></p><p>单从左向右扫描就会导致单调递减的情况下出错，因此我们需要再从右向左扫描一遍。</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C2.png" alt="分发糖果2"></p><p>贪心：</p><p>取最大值从而满足当前的孩子的糖比左和右都大，从而满足题目条件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> {</span><br><span class="line">        <span class="type">int</span>[] candies = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">// Arrays.fill(candies, 1);</span></span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) {</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) {</span><br><span class="line">                candies[i - <span class="number">1</span>] = Math.max(candies[i - <span class="number">1</span>], candies[i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            ret += candies[i];</span><br><span class="line">        }</span><br><span class="line">        ret += candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h1><p>分类讨论 + 贪心</p><p>顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票面值只可能是 5 美元，10 美元和 20 美元三种</p><p>所以会有以下的情况：</p><ul><li>5 美元，由于柠檬水的价格也为 5 美元，因此我们直接收下即可。</li><li>10 美元，我们需要找回 5 美元，如果没有 5 美元面值的钞票，则无法正确找零。</li><li>20 美元，我们需要找回 15 美元，此时有两种组合方式，一种是一张 10 美元和 5 美元的钞票，一种是 3 张 5 美元的钞票，如果两种组合方式都没有，则无法正确找零。当可以正确找零时，两种找零的方式中我们更倾向于第一种，即如果存在 5 美元和 10 美元，我们就按第一种方式找零，否则按第二种方式找零，因为需要使用 5 美元的找零场景会比需要使用 10 美元的找零场景多，我们需要尽可能保留 5 美元的钞票。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) {</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) {</span><br><span class="line">                <span class="comment">// 此时只能找5块的</span></span><br><span class="line">                count[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 贪心：优先用10元，没10元的再用两个5元</span></span><br><span class="line">                <span class="keyword">if</span> (count[<span class="number">1</span>] &gt; <span class="number">0</span>) {</span><br><span class="line">                    count[<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    count[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    count[<span class="number">0</span>] -= <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                count[<span class="number">2</span>]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><ol><li>这道题类似于分糖果（135），有两个纬度需要考虑，但是一样的，我们一次只考虑一个。</li><li>若考虑K维度：<ol><li>按照k从小到大，当相等时h从小到大<ol><li>排序的结果一条都不满足，一个纬度都确定不下来</li></ol></li></ol></li><li>若考虑H维度：<ol><li>按照H从高到低，当相等时K从低到高，这样的身高相对顺序是被确定了的</li></ol></li></ol><p>因此我们考虑确定H维度：</p><p><strong>优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong>这是因为按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/LC_406.jpg" alt="LC_406"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) {</span><br><span class="line">        <span class="comment">// 确定一个维度再处理另一个纬度</span></span><br><span class="line">        <span class="comment">// 确定身高纬度：（因为如果确定的是K的维度，那么比如k按照升序排列，当相等时h按照升序排列，会发现没有按照k的要求得到一个排序的队列）</span></span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] person1, <span class="type">int</span>[] person2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">0</span>] - person1[<span class="number">0</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">1</span>] - person2[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) {</span><br><span class="line">            <span class="type">int</span>[] person = people[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> person[<span class="number">1</span>];</span><br><span class="line">            ret.add(position, person);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="区间调度，重叠类问题"><a href="#区间调度，重叠类问题" class="headerlink" title="区间调度，重叠类问题"></a>区间调度，重叠类问题</h1><h2 id="什么是区间调度问题"><a href="#什么是区间调度问题" class="headerlink" title="什么是区间调度问题"></a>什么是区间调度问题</h2><p>“区间调度”是一类常见的计算机科学问题，其主要目标是在给定一组区间时，找出最多的不相交区间。在这个问题中，区间通常以一对数字表示，例如 [a, b)，表示一个区间从 a 开始，到 b 结束。</p><p>具体的问题定义如下：</p><p>给定一个区间的集合，每个区间包括一个开始时间和一个结束时间。编写一个算法，找到最大的不相交区间的集合，即在这个集合中，任何两个区间都不会重叠。</p><p>例如，假设我们有以下区间：[1, 2], [2, 3], [3, 4], [1, 3]。最大的不相交区间的集合是 [1, 2], [2, 3], [3, 4]，因为我们可以安排这些区间，使得没有任何两个区间是重叠的。</p><p>注意，在解决这类问题时，一个常用的策略是贪心算法。我们首先将所有区间按照结束时间排序，然后每次选择结束时间最早的区间，并且这个区间不与已选择的区间重叠。这种方法能够确保我们总是选择最多的不相交区间。</p><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><p>对于区间调度问题，我们考虑如下的贪心思路：</p><ol><li>每次选择可选区间中开始最早的那个</li><li>每次选择可选区间中最短的那个</li><li>选择出现冲突最少的那个区间</li></ol><p>但是这些都不对，以下是反例：</p><ol><li><p>每次选择可选区间中开始最早的：</p><p>对于区间集合 = [[1,9], [2,5], [6,8]]</p><p>应该返回的结果是2，因为可以选中两个区间，即[2,5]和[6,8]。</p><p>但如果使用这种策略，实际返回的结果是1，因为它首先选择了开始最早的区间[1,9]，而错过了后面的两个区间。</p></li><li><p>每次选择最短的区间：</p><p>对于区间集合 = [[1,3], [2,4], [5,7], [6,9]]</p><p>应该返回的结果是2，因为可以选择两个不相交的区间，例如[1,3]和[5,7]或者[2,4]和[6,9]。</p><p>但如果使用这种策略，实际返回的结果是3，它选中了[1,3]，[2,4]和[6,9]，但其中[1,3]和[2,4]是冲突的。</p></li><li><p>每次选择出现冲突最少的区间：</p><p>对于区间集合 = [[1,4], [2,3], [5,6]]</p><p>应该返回的结果是2，因为可以选择两个不相交的区间，即[1,4]和[5,6]。</p><p>但如果使用这种策略，实际返回的结果是2，选中的区间是[2,3]和[5,6]，虽然结果数量是对的，但选中的区间并不是最优的，因为选择[1,4]和[5,6]可以覆盖更大的区域。</p></li></ol><p>所以，上述的三种贪心策略都不能保证得到最优答案。正确的贪心策略应该是：每次选择结尾最早的，且与当前已选区间不冲突的区间。</p><p>实现上可以分为以下三步：</p><ol><li>从排序好的（按照结束时间升序排列）选择区间右节点<code>xEnd</code></li><li>把与xEnd相交的区间删除（skip）</li><li>重复直至结束</li></ol><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc_%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6.gif" alt="lc_区间调度"></p><p>为什么选择区间右端点？</p><p><strong>由于我们事先排了序</strong>，不难发现所有与 <code>x</code> 相交的区间必然会与 <code>x</code> 的 <code>end</code> 相交；如果一个区间不想与 <code>x</code> 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）<code>x</code> 的 <code>end</code>：</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc_%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A62.jpeg" alt="lc_区间调度2"></p><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h2><p>核心在于：</p><ol><li><p>如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间</p></li><li><p>两个边界挨着的时候也可以使气球引爆</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] point1, <span class="type">int</span>[] point2)</span> {</span><br><span class="line">                <span class="comment">// return point1[1] - point2[1]; 为了应对 [[-2147483646,-2147483645],[2147483646,2147483647]] 不能这么写</span></span><br><span class="line">                <span class="keyword">if</span> (point1[<span class="number">1</span>] &gt; point2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">1</span>] &lt; point2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> findIntervals(points);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findIntervals</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">xEnd</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point : points) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> point[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt; xEnd) {</span><br><span class="line">                count++;</span><br><span class="line">                xEnd = point[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>找到最多不会重复的区间，原长度剪去就是剩下的至少需要去除的区间</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (interval1[<span class="number">1</span>] &gt; interval2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (interval1[<span class="number">1</span>] &lt; interval2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">noOverlappingCount</span> <span class="operator">=</span> findNotOverlaps(intervals);</span><br><span class="line">        <span class="keyword">return</span> intervals.length - noOverlappingCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findNotOverlaps</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= end) {</span><br><span class="line">                end = interval[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h2><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc763.png" alt="lc763"></p><p><strong>找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span>[] charPositions = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">27</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            charPositions[s.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            right = Math.max(charPositions[c - <span class="string">'a'</span>], right); <span class="comment">// 找到重叠区间的最右端点</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) {</span><br><span class="line">                res.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>按照右端点排序非常的麻烦，因为会出现：</p><p><code>[[2,3],[4,5],[6,7],[8,9],[1,10]]</code></p><p>这个样例需要返回 <code>[1,10]</code>，如果使用正常的正序遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">1</span>] &gt; arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">1</span>] == arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ret.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevLeft</span> <span class="operator">=</span> intervals[i - <span class="number">1</span>][<span class="number">0</span>], prevRight = intervals[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= prevRight) {</span><br><span class="line">                <span class="comment">// need to update interval;</span></span><br><span class="line">                <span class="type">int</span>[] removed = ret.remove(ret.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prevLeft &gt; left) {</span><br><span class="line">                    ret.add(intervals[i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    removed[<span class="number">1</span>] = right;</span><br><span class="line">                    ret.add(removed);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ret.add(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] retArr = <span class="keyword">new</span> <span class="title class_">int</span>[ret.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.size(); i++) {</span><br><span class="line">            retArr[i] = ret.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么会返回结果:</p><p><code>[[2,3],[4,5],[6,7],[1,10]]</code></p><p>所以我们需要倒序遍历，并将需要加入的不能合并的区间加入链表头，每一次取表头来和当前区间比较是否需要合并，递归处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">1</span>] &gt; arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">1</span>] == arr2[<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the end to sort will make this part harder: </span></span><br><span class="line">        <span class="comment">// eg test case: [[2,3],[4,5],[6,7],[8,9],[1,10]],</span></span><br><span class="line">        <span class="comment">// to solve this problem, we need to loop from the end:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> intervals.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) {</span><br><span class="line">            <span class="keyword">if</span> (ret.isEmpty()) {</span><br><span class="line">                ret.addFirst(intervals[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] last = ret.getFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevLeft</span> <span class="operator">=</span> last[<span class="number">0</span>], prevRight = last[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= prevLeft) {</span><br><span class="line">                <span class="comment">// need to update interval;</span></span><br><span class="line">                last[<span class="number">0</span>] = Math.min(prevLeft, left);</span><br><span class="line">                last[<span class="number">1</span>] = Math.max(prevRight, right);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ret.addFirst(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] retArr = <span class="keyword">new</span> <span class="title class_">int</span>[ret.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.size(); i++) {</span><br><span class="line">            retArr[i] = ret.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288. 删除被覆盖区间"></a><a href="https://leetcode.cn/problems/remove-covered-intervals/">1288. 删除被覆盖区间</a></h2><p>按照左端点升序排列后右端点按照降序排列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeCoveredIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (arr1[<span class="number">0</span>] &gt; arr2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (arr1[<span class="number">0</span>] &lt; arr2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">curLeft</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], curRight = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= curLeft &amp;&amp; right &gt;= curRight) {</span><br><span class="line">                <span class="comment">// 判断是否覆盖：</span></span><br><span class="line">                count++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= curLeft &amp;&amp; right &lt; curRight) {</span><br><span class="line">                <span class="comment">// 相交情况下，扩展当前区间</span></span><br><span class="line">                right = curRight;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (curLeft &gt; left &amp;&amp; curRight &gt; right) {</span><br><span class="line">              <span class="comment">// 完全不相交，更新left，right</span></span><br><span class="line">                left = curLeft;</span><br><span class="line">                right = curRight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986. 区间列表的交集"></a><a href="https://leetcode.cn/problems/interval-list-intersections/">986. 区间列表的交集</a></h2><p>分情况分析讨论题</p><p>这道题按照区间的重合可以区分为以下四种情况：</p><p>设两个列表的每个区间为 <code>[an, an+1]</code> <code>[bn, bn+1]</code>，那么如果这两个区间有交集，需满足 <code>b2 &gt;= a1 &amp;&amp; a2 &gt;= b1</code>，分下面四种情况：</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc986_%E6%83%85%E5%86%B5.jpeg" alt="lc986_情况"></p><p>如果有交集<code>[c1,c2]</code>那么我们有 <code>c1 = max(a1, b1), c2 = min(a2, b2)</code></p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc986_%E4%BA%A4%E9%9B%86.jpeg" alt="lc986_交集"></p><p>那么剩下的就是双指针问题了，当一个区间被作为交集使用过后，即，他是左边的区间时，指针移动</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] intervalIntersection(<span class="type">int</span>[][] firstList, <span class="type">int</span>[][] secondList) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstIdx</span> <span class="operator">=</span> <span class="number">0</span>, secondIdx = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (firstIdx &lt; firstList.length &amp;&amp; secondIdx &lt; secondList.length) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> firstList[firstIdx][<span class="number">0</span>], a2 = firstList[firstIdx][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> secondList[secondIdx][<span class="number">0</span>], b2 = secondList[secondIdx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (b1 &lt;= a2 &amp;&amp; b2 &gt;= a1) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> Math.max(a1, b1), c2 = Math.min(a2, b2);</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{c1, c2});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a2 &lt; b2) {</span><br><span class="line">                firstIdx++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                secondIdx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于区间调度问题，按照右端点排序的贪心思路解决。对于区间合并问题，按照左端点排序</p><p>按照左端点排序的目的是为了保证左端点的前后关系，这样我们就能保证一个区间的左端点一定不会大于其后面区间的左端点。这在处理一些需要关注<strong>区间的覆盖，或者合并等问题时会比较有用。</strong></p><p>按照右端点排序的目的则是为了保证右端点的前后关系，使得一个区间的右端点不会大于其后面区间的右端点。这在处理一些需要关注<strong>区间的交叉，或者选择不重叠区间</strong>的问题时会比较有用。</p><h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h1><p>这道题与其说是一道贪心题，它更像是一道按照规则的模拟题。贪心思想题现在了按照规则构造时候的模拟题</p><ol><li>先把数字转化成一个char[]</li></ol><p>我们对每一位进行贪心地修改：</p><p>由于我们想要数尽可能的大，所以我们要尽可能填充9，而填充9的位置就是第一个单调递减的位置：</p><p>12321 -&gt; 12999</p><p>3就是第一个需要变化的位置</p><p>但是会有一种情况：</p><p>1233321 -&gt; 那么这个时候我们就不能只简单的看n 和 n+1我们需要一个额外的变量来跟踪第一个max index：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[] nToChar = (n + <span class="string">""</span>).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>, idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nToChar.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (max &lt; nToChar[i]) {</span><br><span class="line">                max = nToChar[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nToChar[i] &gt; nToChar[i + <span class="number">1</span>]) {</span><br><span class="line">                nToChar[idx] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> idx + <span class="number">1</span>; j &lt; nToChar.length; j++) {</span><br><span class="line">                    nToChar[j] = <span class="string">'9'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(nToChar));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></h1><p>这是一道带有贪心思想的脑筋急转弯题，需要画图以及理解任务的调度：</p><p>贪心体现在：尽可能安排出现次数多的任务，然后将其他任务填充在次数多的任务的冷却期中。</p><p>假设我们有桶子：</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc621_%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0_1.png" alt="lc621_贪心构造_1"></p><p>我们需要执行4个任务，那么由于除了最后一个以外都有冷冻期，那么就会有：</p><p>(n + 1) * (m - 1) + 1</p><p>假设任务重复次数最多为max，若有tot个任务数量为 max 的任务：</p><blockquote><p>当任务总数不超过 (n+1)×(max⁡−1)+tot时，我们总能将其他任务插到空闲时间中去，不会引入额外的冻结时间（下左图）；而当任务数超过该值时，我们可以在将其横向添加每个 n+1 块的后面，同时不会引入额外的冻结时间（下右图）：</p><p>作者：宫水三叶<br>链接：<a href="https://leetcode.cn/problems/task-scheduler/description/">https://leetcode.cn/problems/task-scheduler/description/</a></p></blockquote><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc621_%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0_2.png" alt="lc621_贪心构造_2"></p><p>综上：</p><p>结果为<code> return Math.max(len, (n + 1) * (max - 1) + tot);</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tasks.length;</span><br><span class="line">        <span class="type">int</span>[] hm = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            hm[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">            max = Math.max(hm[i], max);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (hm[i] == max) tot++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(len, (n + <span class="number">1</span>) * (max - <span class="number">1</span>) + tot);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode.cn/problems/video-stitching/">1024. 视频拼接</a></h1><p>类区间调度的贪心题：</p><blockquote><p><strong>区间问题肯定按照区间的起点或者终点进行排序</strong></p><p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/jian-shi-p-4302c/">labuladong-剪视频</a></p></blockquote><p>将 <code>clips</code> 按照起点升序排序，起点相同的按照终点降序排序</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc1024_%E6%8E%92%E5%BA%8F_1.jpeg" alt="lc1024_排序_1"></p><p>然后比较所有起点小于 <code>clips[0][1]</code> 的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频</p><p><img src="/2023/06/01/%E8%B4%AA%E5%BF%83/lc1024_%E6%8E%92%E5%BA%8F_2.gif" alt="lc1024_排序_2"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> time)</span> {</span><br><span class="line">        Arrays.sort(clips, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] clip1, <span class="type">int</span>[] clip2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (clip1[<span class="number">0</span>] == clip2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> clip2[<span class="number">1</span>] - clip1[<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> clip1[<span class="number">0</span>] - clip2[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRight</span> <span class="operator">=</span> <span class="number">0</span>, rightMost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curRight) {</span><br><span class="line">            <span class="type">int</span>[] clip = clips[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                curRight = clip[<span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">if</span> (curRight &gt;= time) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// System.out.println(curRight + " " + rightMost);</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curRight) {</span><br><span class="line">                rightMost = Math.max(rightMost, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// System.out.println(rightMost);</span></span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (rightMost &gt;= time) <span class="keyword">return</span> res;</span><br><span class="line">            curRight = rightMost;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">贪心算法问题的集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="贪心" scheme="http://ruobingw.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>回溯之棋盘问题</title>
    <link href="http://ruobingw.com/2023/05/18/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
    <id>http://ruobingw.com/2023/05/18/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-18T09:05:41.000Z</published>
    <updated>2023-05-19T09:44:35.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h1><ol><li>构造树：</li></ol><p>一个 3 * 3 的棋盘，将搜索过程抽象为一棵树</p><p>二维矩阵中矩阵的<strong>高</strong>就是这棵树的<strong>高度</strong>，矩阵的<strong>宽</strong>就是树形结构中每一个节点的<strong>宽度</strong>。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong></p><ol start="2"><li>皇后的位置：<ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol></li></ol><p><img src="/2023/05/18/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/51_NQueen_tree.jpeg" alt="51_NQueen_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">  List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span>[] chessRow : chessBoard) {</span><br><span class="line">          Arrays.fill(chessRow, <span class="string">'.'</span>);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      backtracking(chessBoard, curRow, n);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> n)</span> {</span><br><span class="line">      <span class="keyword">if</span> (curRow == n) {</span><br><span class="line">          <span class="comment">// 到叶子结点，将此时的棋盘加入答案</span></span><br><span class="line">          res.add(array2List(chessBoard));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">curCol</span> <span class="operator">=</span> <span class="number">0</span>; curCol &lt; n; curCol++) {</span><br><span class="line">          <span class="keyword">if</span> (isValid(chessBoard, curRow, curCol)) {</span><br><span class="line">              chessBoard[curRow][curCol] = <span class="string">'Q'</span>;</span><br><span class="line">              backtracking(chessBoard, curRow + <span class="number">1</span>, n);</span><br><span class="line">              chessBoard[curRow][curCol] = <span class="string">'.'</span>;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> curCol)</span> {</span><br><span class="line">      <span class="comment">// 检查同一列是不是已经有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; curRow; r++) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][curCol] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 \ 是否有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol - <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; r--, c--) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 / 是否有Queen</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; chessBoard[<span class="number">0</span>].length; r--, c++) {</span><br><span class="line">          <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span> {</span><br><span class="line">      List&lt;String&gt; transformedArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> chessBoard.length, c = chessBoard[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessBoard) {</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">              sb.append(chars[j]);</span><br><span class="line">          }</span><br><span class="line">          transformedArray.add(sb.toString());</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> transformedArray;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h1><p>和N皇后不同的是，N皇后一旦确定某行中的位置，那么他就唯一确定了但是数独中数字会取决于之前的数字，会存在依赖关系，因此需要枚举每一个格子。</p><p><img src="/2023/05/18/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/lc37_tree.png" alt="lc37_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">boardRow</span> <span class="operator">=</span> <span class="number">9</span>, boardCol = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        backtracking(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> r, <span class="type">int</span> c)</span> {</span><br><span class="line">        <span class="keyword">if</span> (c == boardCol) {</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == boardRow) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[r][c] != <span class="string">'.'</span>) {</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, r, c + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">'1'</span>; num &lt;= <span class="string">'9'</span>; num++) {</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, r, c, num)) <span class="keyword">continue</span>;</span><br><span class="line">            board[r][c] = num;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(board, r, c + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">char</span> num)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="comment">// 判断行是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[r][i] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 判断列是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][c] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 判断 3 x 3 方框是否存在重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[(r/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(c/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">回溯算法的棋盘相关问题的集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="回溯" scheme="http://ruobingw.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>C++碎碎念</title>
    <link href="http://ruobingw.com/2023/05/18/C-%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://ruobingw.com/2023/05/18/C-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2023-05-18T07:11:15.000Z</published>
    <updated>2023-05-18T07:41:08.001Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>本文档用来记录一些C++知识，从而更好地应对就业寒冬 (就比如 “XX已死”)</p><p>卷不死就往死里卷 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></div><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="Coding-Style"><a href="#Coding-Style" class="headerlink" title="Coding Style"></a>Coding Style</h2><p>对于类和结构，通常使用 CamelCase；对于函数和变量，通常使用 snake_case。全局常量和宏常常全部大写，并用下划线分隔。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><ol><li><p>头文件区：<code>#include &lt;&gt;</code></p></li><li><p>命名空间：<code>using namespace std;</code></p><ol><li>保证不同命名空间中变量不冲突</li></ol></li><li><p>程序执行入口</p><ol><li><code>int main()</code></li></ol></li></ol>]]></content>
    
    
    <summary type="html">关于C++的一些语法知识</summary>
    
    
    
    <category term="Programming-Languages" scheme="http://ruobingw.com/categories/Programming-Languages/"/>
    
    
    <category term="C++" scheme="http://ruobingw.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>回溯之切割问题</title>
    <link href="http://ruobingw.com/2023/05/13/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://ruobingw.com/2023/05/13/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-14T03:20:28.000Z</published>
    <updated>2023-05-17T08:07:19.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><p>枚举切割的点来得到分割方案</p><p>只有树枝上的子串是回文串时才能继续往下走，最后如果能够走到空串节点，就说明整个 <code>s</code> 完成了切分，也就是得到了一个合法的答案。</p><p><img src="/2023/05/13/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87_lc131_tree.jpg" alt="分割回文_lc131_tree"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx &gt;= s.length()) {</span><br><span class="line">            <span class="comment">// base case，走到叶子节点</span></span><br><span class="line">            <span class="comment">// 即整个 s 被成功分割为若干个回文子串，记下答案</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> s.substring(startIdx, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(cur)) {</span><br><span class="line">                <span class="comment">// s[start..i] 是一个回文串，可以进行分割</span></span><br><span class="line">                <span class="comment">// 做选择，把 s[start..i] 放入路径列表中</span></span><br><span class="line">                path.add(cur);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>, e = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e) {</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(s) != str.charAt(e)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            s++;</span><br><span class="line">            e--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p>两个难点：</p><ol><li>将问题转化为切割问题从而用回溯法来解决<ol><li>如何造树</li></ol></li><li>边界的处理<ol><li>base case</li><li>判断子字符串是否合法</li></ol></li></ol><p>对于第一个问题：</p><p><img src="/2023/05/13/%E5%9B%9E%E6%BA%AF%E4%B9%8B%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/lc_93_%E5%A4%8D%E5%8E%9FIP_tres.png" alt="lc_93_复原IP_tres"></p><p>对于第二个问题:</p><ol><li>base case <ol><li>通过变量pointNum，记录添加逗点的数量。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointCount == <span class="number">3</span>) {  <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">  <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> (isValid(s, startIdx, s.length() - <span class="number">1</span>)) {</span><br><span class="line">        res.add(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>切割出来的子字符串是否合法<ol><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>综上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> {</span><br><span class="line">        backtracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIdx, <span class="type">int</span> pointCount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (pointCount == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIdx, s.length() - <span class="number">1</span>)) {</span><br><span class="line">                res.add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIdx, i)) {</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">"."</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointCount++;</span><br><span class="line">              <span class="comment">// 注意这里是 i + 2 由于加了一个 "."</span></span><br><span class="line">                backtracking(s, i + <span class="number">2</span>, pointCount);</span><br><span class="line">                pointCount--;</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">记录回溯算法的切割相关问题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="回溯" scheme="http://ruobingw.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
