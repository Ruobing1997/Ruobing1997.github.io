<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin&#39;s Blog</title>
  
  <subtitle>Welcome to my blog</subtitle>
  <link href="http://ruobingw.com/atom.xml" rel="self"/>
  
  <link href="http://ruobingw.com/"/>
  <updated>2023-11-17T23:12:38.814Z</updated>
  <id>http://ruobingw.com/</id>
  
  <author>
    <name>Ruobing Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Code-Refactor</title>
    <link href="http://ruobingw.com/2023/11/17/Code-Refactor/"/>
    <id>http://ruobingw.com/2023/11/17/Code-Refactor/</id>
    <published>2023-11-17T22:32:40.000Z</published>
    <updated>2023-11-17T23:12:38.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code-Smells"><a href="#Code-Smells" class="headerlink" title="Code Smells"></a>Code Smells</h1><p>需要避免这些</p><h2 id="Bloaters"><a href="#Bloaters" class="headerlink" title="Bloaters:"></a>Bloaters:</h2><p>Code, methods and classes that have invreased to such gargantuan proportions that are hard to work with. They accumulate over time as the program evolves</p><h3 id="Long-Method"><a href="#Long-Method" class="headerlink" title="Long Method"></a>Long Method</h3><p>A method contains too many lines of code</p><p>(Method that is longer than ten lines should take care about it)</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>一般情况下加入原本方法比添加新方法看起来要简单一些并且方法的长度是逐渐增长的，因此是不容易被一次发现的。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><p>As a rule of thumb, <strong>if you feel the need to comment on something inside a method</strong>, you should <strong>take this code and put it in a new method.</strong></p><h5 id="Extract-Method"><a href="#Extract-Method" class="headerlink" title="Extract Method"></a>Extract Method</h5><p>合并逻辑相通的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// code fragment that can be grouped together</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> {</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print details.</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Move this code to a separate new method (or function) and replace the old code with a call to the method.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> {</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> {</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Reduce-local-variables-and-parameters-before-extracting-a-method"><a href="#Reduce-local-variables-and-parameters-before-extracting-a-method" class="headerlink" title="Reduce local variables and parameters before extracting a method"></a>Reduce local variables and parameters before extracting a method</h5><p>If local variables and parameters interfere with extracting a method, use </p><ul><li><strong>Replace Temp with Query</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// place the result of an expression in a local variable for later use in your code.</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateTotal</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> quantity * itemPrice;</span><br><span class="line">  <span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) {</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="comment">// Move the entire expression to a separate method and return the result from it. Query the method instead of using a variable. Incorporate the new method in other methods, if necessary.</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateTotal</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) {</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="type">double</span> <span class="title function_">basePrice</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> quantity * itemPrice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Introduce Parameter Object</strong></li></ul><p>Methods contain a repeating group of parameters:</p><p>![Introduce Parameter Object - Before](/2023/11/17/Code-Refactor/Introduce Parameter Object - Before.png)</p><p>Replace these parameters with an object:</p><p>![Introduce Parameter Object - After](/2023/11/17/Code-Refactor/Introduce Parameter Object - After.png)</p><ul><li><strong>Preserve Whole Object</strong>.</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: Several values are from an object and then pass them as parameters to a method:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> daysTempRange.getLow();</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> daysTempRange.getHigh();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">withinPlan</span> <span class="operator">=</span> plan.withinRange(low, high);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good: Pass the whole object</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">withinPlan</span> <span class="operator">=</span> plan.withinRange(daysTempRange);</span><br></pre></td></tr></tbody></table></figure><h5 id="Replace-Method-with-Method-Object"><a href="#Replace-Method-with-Method-Object" class="headerlink" title="Replace Method with Method Object"></a>Replace Method with Method Object</h5><p>If none of the previous recipes help, try moving the entire method to a separate object via <strong>Replace Method with Method Object</strong>.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: A long method in which the local variables are so intertwined that you can't apply Extract Method.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">double</span> primaryBasePrice;</span><br><span class="line">    <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// Perform long computation.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Transform the method into a separate class so that the local variables become fields of the class. Then you can split the method into several methods within the same class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PriceCalculator</span>(<span class="built_in">this</span>).compute();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriceCalculator</span> {</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PriceCalculator</span><span class="params">(Order order)</span> {</span><br><span class="line">    <span class="comment">// Copy relevant information from the</span></span><br><span class="line">    <span class="comment">// order object.</span></span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Perform long computation.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Conditionals-and-Loops"><a href="#Conditionals-and-Loops" class="headerlink" title="Conditionals and Loops"></a>Conditionals and Loops</h5><p><code>if判断</code>和<code>loop</code>可以尝试放在一个单独的方法中</p><p>For conditionals, use <strong>Decompose Conditional</strong>. </p><p>If loops are in the way, try <strong>Extract Method</strong>.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: complex conditional (if-then/else or switch).</span></span><br><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) {</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Decompose the complicated parts of the conditional into separate methods: the condition, then and else.</span></span><br><span class="line"><span class="keyword">if</span> (isSummer(date)) {</span><br><span class="line">  charge = summerCharge(quantity);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: Code fragment that can be grouped together.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printProperties</span><span class="params">(List users)</span> {</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">    result += users.get(i).getName();</span><br><span class="line">    result += <span class="string">" "</span>;</span><br><span class="line">    result += users.get(i).getAge();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Good: Move this code to a separate new method (or function) and replace the old code with a call to the method.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printProperties</span><span class="params">(List users)</span> {</span><br><span class="line">  <span class="keyword">for</span> (User user : users) {</span><br><span class="line">    System.out.println(getProperties(user));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String <span class="title function_">getProperties</span><span class="params">(User user)</span>  {</span><br><span class="line">  <span class="keyword">return</span> user.getName() + <span class="string">" "</span> + user.getAge();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>更多的方法带来的性能差是可以忽略的且更易读的代码能够带来更好的结构化以及潜在优化</p><h3 id="Large-Class"><a href="#Large-Class" class="headerlink" title="Large Class"></a>Large Class</h3><p>Class that contains many fields/method/lines of code</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>和 Long Method 类似，只管认为加field比加class要容易的多</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>When a class is wearing too many (functional) hats, think about splitting it up.</p>]]></content>
    
    
    <summary type="html">代码重构</summary>
    
    
    
    <category term="工程类" scheme="http://ruobingw.com/categories/%E5%B7%A5%E7%A8%8B%E7%B1%BB/"/>
    
    
    <category term="代码重构" scheme="http://ruobingw.com/tags/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="http://ruobingw.com/2023/11/01/Trie%E6%A0%91/"/>
    <id>http://ruobingw.com/2023/11/01/Trie%E6%A0%91/</id>
    <published>2023-11-01T18:29:12.000Z</published>
    <updated>2023-11-17T23:33:30.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>Trie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。</p><p>其核心是使用<strong>「边」</strong>来代表有无字符，使用<strong>「点」</strong>来记录是否为<strong>「单词结尾」</strong>以及<strong>「其后续字符串的字符是什么」</strong></p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/">https://leetcode.cn/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/</a></p><p>解决的问题：</p><p>快速的查找字符串以及存储字符串：</p><p><img src="/2023/11/01/Trie%E6%A0%91/trie_eg_1.png" alt="trie_eg_1"></p><p>星号代表标记来作为这是一个单词的结尾，说明单词形成了</p><p>一般形式：都是小写字母，都是大写字母，都是数字；一般范围都会比较小</p><h1 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h1><p>假设 word</p><ol><li>从根结点开始，遍历单词 <code>word</code>，并看当前字母<code>word[i]</code>是否出现过<ol><li>没有 -&gt; 创建一个</li><li>有 -&gt; 遍历到点上</li></ol></li><li>在单词结尾打一个标记</li></ol><h1 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node[] charactersArr;</span><br><span class="line">        <span class="type">boolean</span> isCompleteWord;</span><br><span class="line"></span><br><span class="line">        Node() {</span><br><span class="line">            charactersArr = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="built_in">this</span>.isCompleteWord = isCompleteWord;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> {</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) p.charactersArr[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        p.isCompleteWord = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.isCompleteWord;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> curr - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.charactersArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.charactersArr[idx];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h1 id="1268-搜索推荐系统"><a href="#1268-搜索推荐系统" class="headerlink" title="1268. 搜索推荐系统"></a><a href="https://leetcode.cn/problems/search-suggestions-system/">1268. 搜索推荐系统</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">suggestedProducts</span><span class="params">(String[] products, String searchWord)</span> {</span><br><span class="line">        Arrays.sort(products);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.length; i++) {</span><br><span class="line">            tr.insert(products[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; searchWord.length(); i++) {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span>[] idxes = tr.search(searchWord.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> idxes[<span class="number">0</span>], r = idxes[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= Math.min(l + <span class="number">2</span>, r) &amp;&amp; l != -<span class="number">1</span>; j++) list.add(products[j]);</span><br><span class="line">            ans.add(list);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node[] charArr = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node root;</span><br><span class="line">        Map&lt;Node, Integer&gt; char2MinIdx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Node, Integer&gt; char2MaxIdx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Trie() {</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String product, <span class="type">int</span> wordIdx)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rootP</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; product.length(); i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> product.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (rootP.charArr[idx] == <span class="literal">null</span>) {</span><br><span class="line">                    rootP.charArr[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                    char2MinIdx.put(rootP.charArr[idx], wordIdx);</span><br><span class="line">                }</span><br><span class="line">                char2MaxIdx.put(rootP.charArr[idx], wordIdx);</span><br><span class="line">                rootP = rootP.charArr[idx];</span><br><span class="line">            }</span><br><span class="line">            rootP.isCompleted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] search(String target) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rootP</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length(); i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> target.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (rootP.charArr[idx] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">                l = char2MinIdx.get(rootP.charArr[idx]);</span><br><span class="line">                r = char2MaxIdx.get(rootP.charArr[idx]);</span><br><span class="line">                rootP = rootP.charArr[idx];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {l, r};</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">字典树的定义以及运用</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="字典树" scheme="http://ruobingw.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Design-Pattern</title>
    <link href="http://ruobingw.com/2023/10/24/Design-Pattern/"/>
    <id>http://ruobingw.com/2023/10/24/Design-Pattern/</id>
    <published>2023-10-24T18:39:54.000Z</published>
    <updated>2023-11-17T22:33:33.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Behavioral-Pattern"><a href="#Behavioral-Pattern" class="headerlink" title="Behavioral Pattern"></a>Behavioral Pattern</h1><p><img src="/2023/10/24/Design-Pattern/Mediator_Structure.png" alt="Mediator_Structure"></p><h1 id="Structural-Pattern"><a href="#Structural-Pattern" class="headerlink" title="Structural Pattern"></a>Structural Pattern</h1><h2 id="Adapter-Pattern"><a href="#Adapter-Pattern" class="headerlink" title="Adapter Pattern"></a>Adapter Pattern</h2><p>使一个老的方案通过<code>adapter</code>来实现新的方案</p><p><img src="/2023/10/24/Design-Pattern/adapter_guru_1.png" alt="adapter_guru_1"></p><h2 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h2><p>当想要整合老旧方案到一个新的方案时，在不修改老方案的内容的情况下，使用adapter：</p><p>A special object that converts the interface of one object so that another object can understand it.</p><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><p><strong>Decorator</strong>  lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</p><p><img src="/2023/10/24/Design-Pattern/decorator-2x.png" alt="decorator-2x"></p><p>四个组成：</p><ol><li>Componenet Interface<ol><li>interface for the objects that will have additional features added to them.</li></ol></li><li>Concrete Component <ol><li>basic implementation of the component interface.</li></ol></li><li>Decorator<ol><li>abstract class implementing the component interface and holding a reference to a component object.</li></ol></li><li>Concrete Decorators<ol><li>These are implementations of the decorator that add specific behaviors or states to the component.</li></ol></li></ol><h2 id="解决的问题：-1"><a href="#解决的问题：-1" class="headerlink" title="解决的问题："></a>解决的问题：</h2>]]></content>
    
    
    <summary type="html">记录各种 Design Pattern</summary>
    
    
    
    <category term="工程类" scheme="http://ruobingw.com/categories/%E5%B7%A5%E7%A8%8B%E7%B1%BB/"/>
    
    
    <category term="设计模式" scheme="http://ruobingw.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Design Pattern" scheme="http://ruobingw.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>八股文</title>
    <link href="http://ruobingw.com/2023/10/24/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://ruobingw.com/2023/10/24/%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2023-10-24T18:15:59.000Z</published>
    <updated>2023-11-17T23:37:29.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark-vs-MapReduce"><a href="#Spark-vs-MapReduce" class="headerlink" title="Spark vs MapReduce:"></a>Spark vs MapReduce:</h1><p>All are used in big data processing, but Spark uses in-memory while map reduce uses disk-based processing.</p><p>For spark, it has other features including lazy evaluation, computations are not executed until like saving or counting is performed. And the data structure in Spark is RDD. Resilient Distributed datasets. These are immutable and can be processed in parallel acroos a cluster. Unlike MapReduce’s linear data flow model. Spark uses DAGs.</p><p>For MapReduce, it is a two phase processing; First map and then reduce. At the map phase, proces and transforms the input data into k-v pairs and in the reduce phase, aggregate and combiens output of the map phase to produce results.</p><p>So, Spark is faster and ease to use. And mapreduce is reliable for a linear and large-scale data processing tasks.</p><h1 id="Mutex-vs-Semaphore"><a href="#Mutex-vs-Semaphore" class="headerlink" title="Mutex vs Semaphore"></a>Mutex vs Semaphore</h1><p>Mutex is used to provide mutual exclusion, i.e., to ensure that only one thread can access a resource (like a variable or section of code) at a time. Locking Mechanism: When a thread locks a mutex, other threads attempting to lock it are blocked until the mutex is unlocked. Ownership: A mutex has the concept of ownership. Only the thread that has acquired a mutex can release it. Use Case: Ideal for protecting shared data/resources in a scenario where only one thread should access the data at a time.</p><p>Semaphores are used to control access to a resource that has a limited number of instances. Counting Mechanism: A semaphore maintains a count, which is decremented by a thread that acquires the semaphore and incremented when a thread releases it.</p><p>No Ownership: Unlike mutexes, semaphores don’t have a specific ownership. Any thread can release a semaphore, not necessarily the one that acquired it.</p><p>Types: There are binary semaphores (which are similar to mutexes) and counting semaphores (which allow multiple accesses up to a set limit).</p><p>Use Case: Useful for limiting access to a resource pool, like database connections.</p><h1 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h1><p>SQL: structured schema with tables, rows and columns. Data is orgranized into well-defined structures. SQL database provide strong consistency, ensuring the data remains in a valid state at all times. ACID transcations are used to maintain data integrity.</p><p>NoSQL are non-relational and handle various data formats, like semi-structured and unstructured data. About consistency, it offers various consistency models, including eventual consistency. It use BASE (Basically Available, Soft state, Eventually consistent) semantics instead of ACID.</p><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache:"></a>Cache:</h1><p>LRU Least Recently Used</p><p>FIFO </p><p>LFU Least Frequently Used</p><h1 id="Malloc-Free-Realloc-Calloc"><a href="#Malloc-Free-Realloc-Calloc" class="headerlink" title="Malloc Free Realloc Calloc"></a>Malloc Free Realloc Calloc</h1><p>When call <strong>malloc</strong>, it requests a block of memory of the specified size from the heap. In a segregated free list with a better-fit algorithm, malloc will search the segregated free lists to find a block that closely matches the requested size (but is slightly larger to avoid fragmentation).</p><p><strong>free</strong> is used to deallocate memory previously allocated by malloc, realloc, or calloc. When you call free, it marks the corresponding block of memory as free in the segregated free list.</p><p>In a better-fit algorithm, free may involve coalescing (merging) adjacent free blocks to prevent memory fragmentation and to maintain the list of free blocks efficiently</p><p><strong>realloc</strong> is used to resize a previously allocated block of memory. It can be used to make a block of memory larger or smaller. When you call realloc, it may perform one of the following actions:</p><p>If the requested size is smaller than the current block’s size, it may split the block, marking part of it as free and returning a pointer to the remaining portion. If the requested size is larger than the current block’s size, it may search for a larger free block in the segregated free list. If found, it may move the data to the new block and return a pointer to it. In a better-fit algorithm, realloc will try to find the best-fit block that minimizes waste and fragmentation.</p><p><strong>calloc</strong> stands for “contiguous allocation.” It is used to allocate and initialize multiple blocks of memory, typically for arrays or data structures. When call calloc, it allocates a block of memory that can hold a specified number of elements, with each element of a specified size.</p><p><strong>First fit / next fit:</strong> search linearly starting from some location, and pick the first block that fits.</p><p>Next Fit is similar to First Fit but starts searching for free memory from the location where the previous allocation ended. This can help reduce fragmentation compared to First Fit. <strong>Best Fit</strong> searches for the smallest available block of memory that can accommodate a request. This minimizes waste but can lead to fragmentation and is less efficient than other algorithms.</p><p><strong>Segregated free list</strong> is to maintain separate lists of free memory blocks, each list containing blocks of a specific size range. This allows the allocator to quickly locate a suitable free block for a requested memory allocation size without searching through all free blocks</p><h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><p>It extends the available physical RAM (Random Access Memory) by temporarily transferring data from RAM to disk storage.</p><p>each process running on a computer system believes it has a complete and dedicated address space that spans from 0 to the maximum address supported by the architecture (e.g., 2^32 addresses in a 32-bit system or 2^64 addresses in a 64-bit system). This illusion is created by the memory management unit (MMU) and the page table. In detail, when a program running on the CPU accesses memory, it uses virtual memory addresses rather than physical addresses. These virtual addresses are translated into physical addresses by the memory management unit (MMU) hardware. For page table, it is is a data structure used by the operating system to map virtual addresses to physical addresses. It keeps track of which pages are currently in RAM and which are stored on disk. It is like as a form of a cache. Page table entries (PTEs) typically store information about the mapping, including whether the page is in RAM (a cache hit in a sense) or needs to be fetched from secondary storage (similar to a cache miss).</p><h1 id="Stack-vs-Heap"><a href="#Stack-vs-Heap" class="headerlink" title="Stack vs Heap"></a>Stack vs Heap</h1><p>The stack is used for static memory allocation, which includes local variables and function calls.</p><p>Size and Allocation: The stack has a limited size, and memory is allocated in a last-in, first-out (LIFO) manner.</p><p>Speed: Allocation and deallocation on the stack are fast since it involves only moving the stack pointer.</p><p>Lifespan: Variables on the stack exist only within the scope of the function that created them.</p><p>Automatic Management: The compiler automatically manages the stack.</p><p>The heap is used for dynamic memory allocation, where the size and lifetime of variables or objects are not known at compile time.</p><p>Size and Allocation: The heap can typically grow dynamically, limited only by the system’s available memory.</p><p>Speed: Allocation and deallocation on the heap are slower as they require more complex bookkeeping.</p><p>Lifespan: Memory on the heap remains allocated until it’s explicitly freed, often by the programmer.</p><p>Manual Management: In languages like C and C++, programmers must manually manage heap memory, leading to complexities like memory leaks and dangling pointers.</p><h1 id="Microservices-why-not-and-why"><a href="#Microservices-why-not-and-why" class="headerlink" title="Microservices - why not and why"></a>Microservices - why not and why</h1><p>Modularity: Microservices allow for breaking down complex applications into smaller, manageable, and independent units. This modular structure makes it easier to understand, develop, and test the application.</p><p>Scalability: Different microservices can be scaled independently, allowing for more efficient resource use. For instance, a component with high demand can be scaled separately without having to scale the entire application.</p><p>Flexibility in Technology: Each microservice can potentially be written in a different programming language or use different data storage technologies, depending on what is best suited for its purpose.</p><p>Faster Deployment and Time to Market: Since microservices can be deployed independently, new features can be brought to market more quickly and with less risk.</p><p>Resilience: A failure in one microservice does not necessarily bring down the whole application, making the application more robust and resilient.</p><p>But:</p><p>Complexity in Coordination: Microservices introduce challenges in communication and coordination between various services. Managing multiple interdependent services can be more complex than managing a monolithic architecture.</p><p>Network Latency: Inter-service communication over the network can introduce latency, which might impact performance.</p><p>Data Management Complexity: Maintaining data consistency and integrity across services can be challenging, especially with each microservice managing its own database.</p><p>Difficulty in Testing: Testing a microservices-based application can be more complex compared to a monolithic application due to the number of services and their interactions.</p><h1 id="Container-vs-Virtual-Machine"><a href="#Container-vs-Virtual-Machine" class="headerlink" title="Container vs Virtual Machine"></a>Container vs Virtual Machine</h1><p>They used to create isolated environments for running applications, but they operate differently and serve different purposes in the world of computing. </p><p>VM: run on top of physical server and a hypervisor, like VMware. Each VM includes all necessary bunaries and libraries and entire guest OS. So VM is larger.</p><p>Container:share the host system’s kernel but package the application and its dependencies (libraries, binaries, etc.) into a container image. Lightweight</p><p>They coexist and leveraging the strengths of each technology</p><h1 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h1><p>RestAPI is a web service implementation that adheres to the REST architectural constraints. And REST is a set of principles that define how Web standards.</p><p>RestAPI include: Stateless Communication: Each request from client to server must contain all the information needed to understand and process the request. And it has to have a client-server architecture, it needs to use HTTP methods like GET POST PUT DELETE. It should be defined as cacheable or not, and it uses a layered system. Other alternatives are liek GraphQL which uses multiple endpoints to retrieve different data to perform operations. And gRPC which is especially useful for microservice architecture</p><h1 id="Website-DNS"><a href="#Website-DNS" class="headerlink" title="Website DNS:"></a>Website DNS:</h1><p>First check the cache in the browser to see if it has a record of the IP address;</p><p>If not, it will do a DNS Query, it wil first go to a local DNS cache, and then reach to internet service providers DNS server, if still not get the IP address, the request will be forwarded to higher-level DNS until the IP is found.</p><p>Once got the IP, our hardware will use ARP to find the MAC address of the gateway router, And then the browser will start like TCP with, of course, handshaking. SYN, SYN-ACK, ACK; And then sending HTTP, if it is HTTPS, it will do some verification and server gives the response after processing the request with some status code as well as contents like HTML, and then the Browser render the page</p><h1 id="Network-Layer"><a href="#Network-Layer" class="headerlink" title="Network Layer:"></a>Network Layer:</h1><p>OSI Model: 7 layers: Physical, Data link, network, transport, session, presentation, application;</p><p>Physical: transmission and reception of unstructured raw data between a device and a physical transmission medium</p><p>DataLink: node-to-node data transfer</p><p>Network: Device addressing, routers operate at this layer</p><p>Transport: transfer data between hosts</p><p>Session: Manage sessions between end-user apps</p><p>Presentation: Data encryption</p><p>Application: interacts with the software application</p><p>TCP/IP:</p><p>Link layer, internet layer, transport layer, application layer</p><p>Link (physical and data link)</p><p>Internet: network</p><p>Transport: transport</p><p>Application: Session, presentation, application</p><h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><p>HTTP/2 so, it uses TCP for the transport layer, with protocol buffers at the presentation layer.</p><h1 id="Cloud-v-s-Cloud-Native"><a href="#Cloud-v-s-Cloud-Native" class="headerlink" title="Cloud v.s. Cloud Native"></a>Cloud v.s. Cloud Native</h1><p>“cloud” refers to the computational infrastructure and services available over the internet, “cloud native” refers to a methodology and design philosophy to build and run applications that harness the full potential of cloud computing.</p><p>I usually heard SAAS, PAAS, iaaS</p><p>FaaS</p><p>FaaS, or Function as a Service, is a category of cloud computing services that allows developers to execute and manage individual functions in response to events without the need to manage the infrastructure. This is a subset of serverless computing. It is event driven, like I need to have SQS + SNS + Lamba function to make the SNS trigger the function. It is stateless, short-lived and able to auto scale.</p><h1 id="Docker-vs-K8s"><a href="#Docker-vs-K8s" class="headerlink" title="Docker vs K8s"></a>Docker vs K8s</h1><p>Docker is a platform that allows us to build, ship, and run applications inside containers. Containers encapsulate an application and its dependencies into a single, consistent unit, making it easy to move across different environments.</p><p>Kubernetes is a container orchestration platform designed to automate the deployment, scaling, and management of containerized applications.</p><p>Docker is about creating and running individual containers.</p><p>Kubernetes is about coordinating clusters of containers, ensuring they work in harmony with one another.</p><h1 id="Container-v-s-Virtual-Machine"><a href="#Container-v-s-Virtual-Machine" class="headerlink" title="Container v.s. Virtual Machine"></a>Container v.s. Virtual Machine</h1><p>Containers:</p><p>OS-level virtualization.</p><p>Lightweight and fast.</p><p>Share the host’s OS kernel.</p><p>Best for microservices and cloud-native applications.</p><p>Virtual Machines:</p><p>Hardware-level virtualization.</p><p>Heavier, with their own full OS stacks.</p><p>Stronger isolation due to separate kernels.</p><p>Best for strong isolation needs and varied OS requirements on the same host.</p><p> containers can run inside VMs, leveraging the strengths of both technologies.</p><h1 id="进程-vs-线程-vs-协程"><a href="#进程-vs-线程-vs-协程" class="headerlink" title="进程 vs 线程 vs 协程"></a>进程 vs 线程 vs 协程</h1><blockquote><p><a href="https://www.cnblogs.com/Survivalist/p/11527949.html">进程 vs 线程 vs 协程</a></p></blockquote><p>Process contains Thread contains Coroutines</p><p>Process between each other are independent, while thread in a process share the memory space, like code, data, stack, and space resources like signals</p><p>Thread and Coroutine: Thread needs locks to make the data consistent while coroutine does not, we can simply check the state in the coroutine;</p><p>包含关系如下：</p><p><img src="/2023/10/24/%E5%85%AB%E8%82%A1%E6%96%87/Thread-Process-Coroutine.png" alt="Thread-Process-Coroutine"></p>]]></content>
    
    
    <summary type="html">记录准备过的八股文</summary>
    
    
    
    <category term="八股" scheme="http://ruobingw.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="面经" scheme="http://ruobingw.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="八股文" scheme="http://ruobingw.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>前后缀分解</title>
    <link href="http://ruobingw.com/2023/10/22/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"/>
    <id>http://ruobingw.com/2023/10/22/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/</id>
    <published>2023-10-22T04:44:33.000Z</published>
    <updated>2023-10-22T04:50:13.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一个prefix数组 一个 suffix 数组</p><p>在<code>idx = i</code>处可以使用<code>prefix</code> 和 <code>suffix</code>的一些性质，比如乘积，或者在<code>i</code>上左边的最小值，右边的最小值</p><p>本质是为了快速的在当前<code>i</code>上能够利用信息避免重复计算 </p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>初见使用在了<a href="https://leetcode.cn/contest/weekly-contest-368/">leetcode 368 周赛</a> Q2:</p><h1 id="元素和最小的山形三元组-II"><a href="#元素和最小的山形三元组-II" class="headerlink" title="元素和最小的山形三元组 II"></a><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/">元素和最小的山形三元组 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] rightMin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        leftMin[<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            leftMin[i] = Math.min(leftMin[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        rightMin[n - <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            rightMin[i] = Math.min(rightMin[i + <span class="number">1</span>], nums[i + <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; leftMin[i] &amp;&amp; nums[i] &gt; rightMin[i]) {</span><br><span class="line">                minSum = Math.min(minSum, nums[i] + leftMin[i] + rightMin[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minSum == Integer.MAX_VALUE ? -<span class="number">1</span> : minSum;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;一个prefix数组 一个 suffix 数组&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;idx = i&lt;/code&gt;处可以使用&lt;code&gt;prefix&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>摩尔投票</title>
    <link href="http://ruobingw.com/2023/10/20/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"/>
    <id>http://ruobingw.com/2023/10/20/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/</id>
    <published>2023-10-21T02:44:03.000Z</published>
    <updated>2023-10-21T03:21:09.702Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247488987&amp;idx=1&amp;sn=6087b1909fea1d24f15353515eee8d93&amp;chksm=fd9cbec4caeb37d235ccad8d59724177784036a60525fa5e7b738267e9a84a572b1545528391&amp;token=1288276346&amp;lang=zh_CN#rd">三叶</a></p></blockquote><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。</span><br><span class="line"></span><br><span class="line">输入：[1,2,5,9,5,9,5,5,5]</span><br><span class="line">输出：5</span><br></pre></td></tr></tbody></table></figure><p><strong>摩尔投票 ：在集合中寻找可能存在的多数元素，这一元素在输入的序列重复出现并占到了序列元素的一半以上；在第一遍遍历之后应该再进行一个遍历以统计第一次算法遍历的结果出现次数，确定其是否为众数；如果一个序列中没有占到多数的元素，那么第一次的结果就可能是无效的随机元素。</strong></p><p><strong>换句话说，每次将两个不同的元素进行「抵消」，如果最后有元素剩余，则「可能」为元素个数大于总数一半的那个。</strong></p><p>具体的，我们定义一个变量 来保存那个可能为主要元素的值， 用来记录该值的出现次数。然后在遍历数组 过程中执行如下逻辑：</p><ul><li>如果 为 ：说明之前出现过的 已经被抵消完了，更新一下 为当前值，出现次数为 ：<code>x = nums[i], cnt = 1</code>；</li><li>如果 不为 ：说明之前统计的 还没被抵消完，这是根据 与 是否相等进行计算即可：<code>cnt += nums[i] == x ? 1 : -1</code>。</li></ul><p>当处理完 之后，我们得到了一个<strong>「可能」</strong>的主要元素。注意只是可能，因为我们在处理过程中只使用了 <code>x</code> 和 <code>cnt</code> 来记录，我们是无法确定最后剩下的 是经过多次抵消后剩余的主要元素，还是只是不存在主要元素的数组中的无效随机元素。</p><p>因此我们需要再进行一次遍历，检查这个<strong>「可能」</strong>的主要元素 的出现次数是否超过总数一半。</p><p>O(1) 找众数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) {</span><br><span class="line">                x = i;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cnt += x == i ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) <span class="keyword">if</span> (x == i) cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; n / <span class="number">2</span> ? x : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">摩尔投票！</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数组" scheme="http://ruobingw.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="http://ruobingw.com/tags/Array/"/>
    
    <category term="摩尔投票" scheme="http://ruobingw.com/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>Re:从1500分开始的竞赛生活</title>
    <link href="http://ruobingw.com/2023/10/11/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/"/>
    <id>http://ruobingw.com/2023/10/11/Re-%E4%BB%8E1500%E5%88%86%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AB%9E%E8%B5%9B%E7%94%9F%E6%B4%BB/</id>
    <published>2023-10-11T16:49:38.000Z</published>
    <updated>2023-11-17T23:52:40.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要在这里练习</p><p><a href="https://huxulm.github.io/lc-rating/#/zen">https://huxulm.github.io/lc-rating/#/zen</a></p></div><h1 id="1500-1600"><a href="#1500-1600" class="headerlink" title="1500 - 1600"></a>1500 - 1600</h1><blockquote><p>学会从题干假设结论，然后尝试验证结论（写一个）或者数学证明</p></blockquote><h2 id="2507-使用质因数之和替换后可以取到的最小值-1500"><a href="#2507-使用质因数之和替换后可以取到的最小值-1500" class="headerlink" title="2507. 使用质因数之和替换后可以取到的最小值 - 1500"></a><a href="https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/">2507. 使用质因数之和替换后可以取到的最小值</a> - 1500</h2><p>这道题主要是怎么分解质因数，属于数学题。</p><p>用一个外置的while 循环来判断是否结束，然后从 cur 开始分解，分解从2作为因数开始分解，然后更新 min</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestValue</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">nChange</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (nChange != count) {</span><br><span class="line">            nChange = count;</span><br><span class="line">            cur = count;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= cur; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (cur % i == <span class="number">0</span>) {</span><br><span class="line">                        cur /= i;</span><br><span class="line">                        count += i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            min = Math.min(min, count);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1525-字符串的好分割数目-1500"><a href="#1525-字符串的好分割数目-1500" class="headerlink" title="1525. 字符串的好分割数目 - 1500"></a><a href="https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/">1525. 字符串的好分割数目</a> - 1500</h2><p>前后缀分解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSplits</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChar.length;</span><br><span class="line">        <span class="type">int</span>[] leftCount = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightCount = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        Set&lt;Character&gt; left = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; right = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxRight</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            left.add(sChar[i]);</span><br><span class="line">            leftCount[idxLeft] = left.size();</span><br><span class="line">            idxLeft++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            right.add(sChar[i]);</span><br><span class="line">            rightCount[idxRight] = right.size();</span><br><span class="line">            idxRight--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(leftCount).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="comment">// Arrays.stream(rightCount).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (leftCount[i] == rightCount[i]) count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="915-分割数组-1501"><a href="#915-分割数组-1501" class="headerlink" title="915. 分割数组 - 1501"></a><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a> - 1501</h2><p>利用题中性质：<code>left</code> 中的每个元素都小于或等于 <code>right</code> 中的每个元素。 &lt;-&gt;  等价于找 left 最大 &lt;= right 最小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionDisjoint</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// left 每个元素都小于或等于 right 中的每个元素</span></span><br><span class="line">        <span class="comment">// 等价于找 left 最大 &lt;= right 最小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightMin = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) {</span><br><span class="line">                max = nums[i];</span><br><span class="line">            }</span><br><span class="line">            leftMax[i] = max;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) {</span><br><span class="line">                min = nums[i];</span><br><span class="line">            }</span><br><span class="line">            rightMin[i - <span class="number">1</span>] = min;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(leftMax).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">        <span class="comment">// Arrays.stream(rightMin).forEach(a -&gt; System.out.print(a + " "));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (leftMax[i] &lt;= rightMin[i]) {</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1090-受标签影响的最大值-1501"><a href="#1090-受标签影响的最大值-1501" class="headerlink" title="1090. 受标签影响的最大值 - 1501"></a><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a> - 1501</h2><p>dp做法：（超时）这里忽略了memo的声明需要三重循环，即使是ptthon的@cache也会超时，记忆化在这里并不适用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] values;</span><br><span class="line">    <span class="type">int</span>[] labels;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> numWanted;</span><br><span class="line">    <span class="type">int</span> useLimit;</span><br><span class="line">    Map&lt;Integer, Integer&gt; selectedNumsCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestValsFromLabels</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span>[] labels, <span class="type">int</span> numWanted, <span class="type">int</span> useLimit)</span> {</span><br><span class="line">        <span class="built_in">this</span>.values = values;</span><br><span class="line">        <span class="built_in">this</span>.labels = labels;</span><br><span class="line">        <span class="built_in">this</span>.n = values.length;</span><br><span class="line">        <span class="built_in">this</span>.numWanted = numWanted;</span><br><span class="line">        <span class="built_in">this</span>.useLimit = useLimit;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span> {</span><br><span class="line">        <span class="comment">// System.out.println("ini: " + idx + " " + sum + " " + numWanted + " " + useLimit);</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= n) {</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (memo[idx] != -666) return memo[idx];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resNot</span> <span class="operator">=</span> dp(idx + <span class="number">1</span>, sum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println("not select: " + idx + " " + resNot);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[idx];</span><br><span class="line">        <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> labels[idx];</span><br><span class="line">        <span class="keyword">if</span> (numWanted == <span class="number">0</span>) <span class="keyword">return</span> resNot;</span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.getOrDefault(label, -<span class="number">1</span>) == useLimit) <span class="keyword">return</span> resNot; </span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.containsKey(label)){</span><br><span class="line">            selectedNumsCount.put(label, selectedNumsCount.get(label) + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            selectedNumsCount.put(label, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        numWanted--;</span><br><span class="line">        sum = sum + value;</span><br><span class="line">        <span class="comment">// System.out.println("pre: " + sum + " " + resNot);</span></span><br><span class="line">        <span class="comment">// System.out.println(selectedNumsCount);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resSelected</span> <span class="operator">=</span> dp(idx + <span class="number">1</span>, sum);</span><br><span class="line">        <span class="comment">// System.out.println("after: " + sum + " " + resSelected);</span></span><br><span class="line">        sum = sum - value;</span><br><span class="line">        numWanted++;</span><br><span class="line">        <span class="keyword">if</span> (selectedNumsCount.get(label) &gt; <span class="number">1</span>) {</span><br><span class="line">            selectedNumsCount.put(label, selectedNumsCount.get(label) - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            selectedNumsCount.remove(label);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// System.out.println(idx + " " + resNot + " " + resSelected);</span></span><br><span class="line">        <span class="comment">// memo[idx] = Math.max(resNot, resSelected);</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(resNot, resSelected);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正确做法：排序 + 计数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestValsFromLabels</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span>[] labels, <span class="type">int</span> numWanted, <span class="type">int</span> useLimit)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span>[][] pairs = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            pairs[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]{values[i], labels[i]};</span><br><span class="line">        }</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (numWanted &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> pairs[i][<span class="number">0</span>], l = pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(l, <span class="number">0</span>) &lt; useLimit) {</span><br><span class="line">                cnt.merge(l, <span class="number">1</span>, Integer::sum);</span><br><span class="line">                numWanted--;</span><br><span class="line">                ans += v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1750-删除字符串两端相同字符后的最短长度-1502"><a href="#1750-删除字符串两端相同字符后的最短长度-1502" class="headerlink" title="1750. 删除字符串两端相同字符后的最短长度 - 1502"></a><a href="https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/">1750. 删除字符串两端相同字符后的最短长度</a> - 1502</h2><p>双指针直接模拟：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLength</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (cArr[left] == cArr[right]) {</span><br><span class="line">                <span class="type">char</span> <span class="variable">curDup</span> <span class="operator">=</span> cArr[left];</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right &amp;&amp; cArr[left] == curDup) {</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; left &lt;= right &amp;&amp; cArr[right] == curDup) {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// System.out.println(left + " " + right);</span></span><br><span class="line">                min = Math.min(min, right - left + <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2730-找到最长的半重复子字符串-1502"><a href="#2730-找到最长的半重复子字符串-1502" class="headerlink" title="2730. 找到最长的半重复子字符串 - 1502"></a><a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/">2730. 找到最长的半重复子字符串</a> - 1502</h2><p>滑动窗口:</p><p>当出现重复次数 &gt; 1时，缩短窗口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSemiRepetitiveSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sameCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; n; right++) {</span><br><span class="line">            <span class="keyword">if</span> (cArr[right] == cArr[right - <span class="number">1</span>]) {</span><br><span class="line">                sameCount++;</span><br><span class="line">                <span class="keyword">if</span> (sameCount &gt; <span class="number">1</span>) {</span><br><span class="line">                    left += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; cArr[left] != cArr[left - <span class="number">1</span>]) {</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                    sameCount--;</span><br><span class="line">                }</span><br><span class="line">            } </span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2708-一个小组的最大实力值-1502"><a href="#2708-一个小组的最大实力值-1502" class="headerlink" title="2708. 一个小组的最大实力值 - 1502"></a><a href="https://leetcode.cn/problems/maximum-strength-of-a-group/">2708. 一个小组的最大实力值</a> - 1502</h2><p>由于数据规模比较小，可以直接爆搜：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">10</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; ls = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxStrength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 选或不选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (ls.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">curMax</span> <span class="operator">=</span> ls.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ls.size(); i++) {</span><br><span class="line">                curMax *= ls.get(i);</span><br><span class="line">            }</span><br><span class="line">            max = Math.max(max, curMax);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前数</span></span><br><span class="line">        dfs(idx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        ls.add(nums[idx]);</span><br><span class="line">        dfs(idx + <span class="number">1</span>);</span><br><span class="line">        ls.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>O(n)</em>: 每一次都取当前的最大和最小，最小的可能是负数，负数和负数相乘能得到一个正数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxStrength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> max;</span><br><span class="line">            max = Math.max(max, Math.max(nums[i], Math.max(min * nums[i], max * nums[i])));</span><br><span class="line">            min = Math.min(min, Math.min(nums[i], Math.min(min * nums[i], temp * nums[i])));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2358-分组的最大数量-1503"><a href="#2358-分组的最大数量-1503" class="headerlink" title="2358. 分组的最大数量 - 1503"></a><a href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">2358. 分组的最大数量</a> - 1503</h2><p>这是一道数学题：</p><p>排序之后分组</p><p>第一组一个数，第二组两个数，第三组三个数… </p><p>那么一定满足要求：</p><ul><li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li><li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）</li></ul><p>这是因为 </p><p>假设 <code>排序后</code>分组：</p><p>a | b, c | d, e, f | …</p><p>a &lt; b &lt; c &lt; d &lt; e &lt; f</p><p>则有</p><p>b + c &lt;= d + e</p><p>因此两个条件都可以满足</p><p>是用数学公式：</p><p>1 + 2 + 3 + … + x &lt;= n</p><p>(1 + x) * x / 2 &lt;= n</p><p>x + x^2 - 2n &lt;= 0</p><p>解一元二次方程</p><p>x^2 + x - 2n &lt;= 0</p><p>(-b + sqrt(b^2 - 4ac)) / 2</p><p>向下取整 因此 x 为：</p><p><code>(-1 + (int) Math.sqrt((double) (1 + 8 * grades.length))) / 2</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGroups</span><span class="params">(<span class="type">int</span>[] grades)</span> {</span><br><span class="line">        <span class="comment">// 数学证明 + 贪心</span></span><br><span class="line">        <span class="keyword">return</span> (-<span class="number">1</span> + (<span class="type">int</span>) Math.sqrt((<span class="type">double</span>) (<span class="number">1</span> + <span class="number">8</span> * grades.length))) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2661-找出叠涂元素-1503"><a href="#2661-找出叠涂元素-1503" class="headerlink" title="2661. 找出叠涂元素 - 1503"></a><a href="https://leetcode.cn/problems/first-completely-painted-row-or-column/">2661. 找出叠涂元素</a> - 1503</h2><p>预处理行列，将每一个数代表的位置存储在哈希表中，在遍历<code>arr</code>的过程中快速找到对应行列从而使用<code>行列计算数组</code>「rowCnt」「Colnt」更新来快速找到重叠的元素，第一次碰到的元素一定是下标最小的， 注意m和n <code>rowCnt[x] &gt;= n || colCnt[y] &gt;= m</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstCompleteIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[][] mat)</span> {</span><br><span class="line">        Map&lt;Integer, <span class="type">int</span>[]&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                hm.put(mat[i][j], <span class="keyword">new</span> <span class="title class_">int</span>[]{i, j});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] rowCnt = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] colCnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="type">int</span>[] xy = hm.get(arr[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> xy[<span class="number">0</span>], y = xy[<span class="number">1</span>];</span><br><span class="line">            rowCnt[x]++;</span><br><span class="line">            colCnt[y]++;</span><br><span class="line">            <span class="comment">// System.out.println(x + " " + y + " " + rowCnt[x] + " " + colCnt[y]);</span></span><br><span class="line">            <span class="keyword">if</span> (rowCnt[x] &gt;= n || colCnt[y] &gt;= m) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2527-查询数组-Xor-美丽值-1550"><a href="#2527-查询数组-Xor-美丽值-1550" class="headerlink" title="2527. 查询数组 Xor 美丽值 - 1550"></a><a href="https://leetcode.cn/problems/find-xor-beauty-of-array/">2527. 查询数组 Xor 美丽值</a> - 1550</h2><p>位运算题目，涉及到详细的数学证明：</p><blockquote><p>参考<br>作者：我爱志方小姐<br>链接：<a href="https://leetcode.cn/problems/find-xor-beauty-of-array/">https://leetcode.cn/problems/find-xor-beauty-of-array/</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(a | a) &amp; a     (b | a) &amp; a     (c | a) &amp; a</span><br><span class="line">(a | a) &amp; b     (b | a) &amp; b     (c | a) &amp; b</span><br><span class="line">(a | a) &amp; c     (b | a) &amp; c     (c | a) &amp; c</span><br><span class="line"></span><br><span class="line">(a | b) &amp; a     (b | b) &amp; a     (c | b) &amp; a</span><br><span class="line">(a | b) &amp; b     (b | b) &amp; b     (c | b) &amp; b</span><br><span class="line">(a | b) &amp; c     (b | b) &amp; c     (c | b) &amp; c</span><br><span class="line"></span><br><span class="line">(a | c) &amp; a     (b | c) &amp; a     (c | c) &amp; a</span><br><span class="line">(a | c) &amp; b     (b | c) &amp; b     (c | c) &amp; b</span><br><span class="line">(a | c) &amp; c     (b | c) &amp; c     (c | c) &amp; c</span><br></pre></td></tr></tbody></table></figure><p>根据 按位或 的 对称性，即 x | y = y | x，我们不难发现上面的分块矩阵是一个 对称矩阵，也就是说所有元素的 异或 等于对角线元素的 异或，我们保留 对角线元素(块)，得到如下 3 x 3 矩阵：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a | a) &amp; a     (b | b) &amp; a     (c | c) &amp; a</span><br><span class="line">(a | a) &amp; b     (b | b) &amp; b     (c | c) &amp; b</span><br><span class="line">(a | a) &amp; c     (b | b) &amp; c     (c | c) &amp; c</span><br></pre></td></tr></tbody></table></figure><p>由于 <code>a | a = a</code>, <code>a &amp; a = a</code>，我们将上面的矩阵再化简一下，有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a       b &amp; a     c &amp; a</span><br><span class="line">a &amp; b       b       c &amp; b</span><br><span class="line">a &amp; c     b &amp; c       c</span><br></pre></td></tr></tbody></table></figure><p>再根据 <code>按位与</code> 运算的 <code>对称性</code>，即 <code>x &amp; y = y &amp; x</code>，我们不难发现，这又是一个 <code>对称矩阵</code>，所有元素的 <code>异或</code> 等于对角线元素的 <code>异或</code>，即：</p><p><code>a ^ b ^ c</code></p><p>因此，我们有如下结论：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums 的 <span class="keyword">xor</span> 美丽值即为 nums 所有元素的异或值。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">xorBeauty</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Arrays.stream(nums).reduce(<span class="number">0</span>, (sub, cur) -&gt; sub ^ cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2780-合法分割的最小下标-1550"><a href="#2780-合法分割的最小下标-1550" class="headerlink" title="2780. 合法分割的最小下标 - 1550"></a><a href="https://leetcode.cn/problems/minimum-index-of-a-valid-split/">2780. 合法分割的最小下标</a> - 1550</h2><p>方法1：两个哈希表</p><p>一个哈希表记录每一个元素的总数，一个哈希表记录当前遍历过程中出现的元素次数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumIndex</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        Map&lt;Integer, Integer&gt; hmAll = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            hmAll.put(num, hmAll.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        Map&lt;Integer, Integer&gt; hmCur = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.get(i);</span><br><span class="line">            hmCur.put(num, hmCur.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (hmCur.get(num) * <span class="number">2</span> &gt; i + <span class="number">1</span> &amp;&amp; (hmAll.get(num) - hmCur.get(num)) * <span class="number">2</span> &gt; nums.size() - i - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法2：数学推理 + 摩尔投票 </p><p><strong>证明</strong>：分割出的两个数组的支配元素就是原数组的支配元素。</p><p>分割出的两个数组的支配元素就是原数组的支配元素。</p><p>设这两个数组的支配元素为 y（题目要求支配元素相同），那么对于第一个数组有</p><p><code>freq_1(y) * 2 &gt; i+1</code></p><p>对于第二个数组有</p><p><code>freq_2(y) * 2 &gt; n - i - 1</code></p><p>由于这两个数组合并之后就是原数组，所以</p><p><code>freq(y) * 2 = freq_1(y) * 2 + freq_2(y) * 2 &gt; (i+1) + (n-i-1) = n</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumIndex</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> mooreVote(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">modeTot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (num == mode) modeTot++; </span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">modeCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.get(i);</span><br><span class="line">            <span class="keyword">if</span> (num == mode) modeCnt++;</span><br><span class="line">            <span class="keyword">if</span> (modeCnt * <span class="number">2</span> &gt; i + <span class="number">1</span> &amp;&amp; (modeTot - modeCnt) * <span class="number">2</span> &gt; n - <span class="number">1</span> - i) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mooreVote</span><span class="params">(List&lt;Integer&gt; nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums.get(<span class="number">0</span>), cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (x != nums.get(i)) {</span><br><span class="line">                cnt -= <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) {</span><br><span class="line">                x = nums.get(i);</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">countX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (num == x) {</span><br><span class="line">                countX++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (countX &gt; nums.size() / <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1600-1900"><a href="#1600-1900" class="headerlink" title="1600 - 1900"></a>1600 - 1900</h1><h2 id="2316-统计无向图中无法互相到达点对数-1604"><a href="#2316-统计无向图中无法互相到达点对数-1604" class="headerlink" title="2316. 统计无向图中无法互相到达点对数 - 1604"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a> - 1604</h2><p>自我认为一道非常好的题，可以使用DFS，并查集来解题：</p><p>一开始尝试使用了DFS枚举然后去除，暴力超时</p><p>后采用并查集，通过计算乘法原理 O(N^2)</p><p>进行数学优化，直接相乘除二即可，O(N + M)</p><blockquote><a href="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;LinkedList&lt;Integer&gt;&gt; go = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span>[] size;</span><br><span class="line">        UF(<span class="type">int</span> n) {</span><br><span class="line">            <span class="built_in">this</span>.count = n;</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ]; <span class="comment">// 相当于把 rooQ 的parent指定为rootP, 所以rootP的size需要加上rootQ的size</span></span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[cur] != cur) {</span><br><span class="line">                parent[cur] = find(parent[cur]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[cur];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countPairs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            go.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], to = edges[i][<span class="number">1</span>];</span><br><span class="line">            uf.union(from, to);</span><br><span class="line">        }</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> uf.find(i);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(p)) list.add(uf.size[p]);</span><br><span class="line">            set.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ele : list) {</span><br><span class="line">            res += (<span class="type">long</span>) ele * (n - ele);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1900-2100"><a href="#1900-2100" class="headerlink" title="1900 - 2100"></a>1900 - 2100</h1><h2 id="2919-使数组变美的最小增量运算数-2031"><a href="#2919-使数组变美的最小增量运算数-2031" class="headerlink" title="2919. 使数组变美的最小增量运算数 - 2031"></a><a href="https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/">2919. 使数组变美的最小增量运算数</a> - 2031</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">long</span>[][] memo;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minIncrementOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// int n = nums.length;</span></span><br><span class="line">        <span class="comment">// this.k = k;</span></span><br><span class="line">        <span class="comment">// memo = new long[n][3];</span></span><br><span class="line">        <span class="comment">// this.nums = nums;</span></span><br><span class="line">        <span class="comment">// for (long[] m : memo) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(m, -1);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp(n - 1, 0);</span></span><br><span class="line">        <span class="comment">// 1:1 翻译成 递推</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">select</span> <span class="operator">=</span> dp[i][<span class="number">0</span>] + Math.max(k - nums[i], <span class="number">0</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">notSelect</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">2</span>) {</span><br><span class="line">                    notSelect = dp[i][j + <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = Math.min(select, notSelect);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> left)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][left] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][left];</span><br><span class="line">        <span class="comment">// 选</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> dp(idx - <span class="number">1</span>, <span class="number">0</span>) + Math.max(k - nums[idx], <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 不选</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">2</span>) {</span><br><span class="line">            res = Math.min(res, dp(idx - <span class="number">1</span>, left + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        memo[idx][left] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">记录下为了周赛的难度练习</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="周赛" scheme="http://ruobingw.com/tags/%E5%91%A8%E8%B5%9B/"/>
    
    <category term="难度练习" scheme="http://ruobingw.com/tags/%E9%9A%BE%E5%BA%A6%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://ruobingw.com/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://ruobingw.com/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-10-05T22:43:02.000Z</published>
    <updated>2023-10-05T23:25:50.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>对于两个字符串求子序列的问题，都是用两个指针 <code>i</code> 和 <code>j</code> 分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--93b6b/">labuladong-最长公共子序列</a></p></blockquote><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><p><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>定义<code>dp(s1, i, s2, j)</code>为<code>s1[i...]</code> 和 <code>s2[j...]</code>的最长公共子序列长度</p><p>goal: <code>dp(s1, 0, s2, 0)</code> 从零开始的最长公共子序列长度</p><p>base case: <code>i == len(s1)</code> 或 <code>j == len(s2)</code> 由于相当于没有string，所以最长公共子序列长度为0</p><p>状态转移：</p><p>在选的情况下，即charAt[i] == charAt[j]时，状态转移：</p><p><img src="/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E9%80%89.jpeg" alt="状态转移_选"></p><p>在不选的情况下可以从三种情况转移：</p><p><img src="/2023/10/05/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB_%E4%B8%8D%E9%80%89.jpeg" alt="状态转移"></p><p><strong>但是其实只有情况一和情况二，因为情况三被情况一cover了</strong></p><h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>模板题</p><p>代码：</p><p>自顶向下的递归解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String text1, text2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> {</span><br><span class="line">        m = text1.length();</span><br><span class="line">        n = text2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.text1 = text1;</span><br><span class="line">        <span class="built_in">this</span>.text2 = text2;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自底向上的迭代解法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span></span><br><span class="line">        <span class="comment">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span></span><br><span class="line">        <span class="comment">// base case: dp[0][..] = dp[..][0] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">                <span class="comment">// 现在 i 和 j 从 1 开始，所以要减一</span></span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><p>变换一下思路，我们要的就是让他们成为他们的公共子序列，问的是需要到达公共子序列所需要的步数:</p><p>即 <code>word1.length - LCS.length + word2.length - LCS.length</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String word1, word2;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        m = word1.length();</span><br><span class="line">        n = word2.length();</span><br><span class="line">        <span class="comment">// 初始化 memo 为了消除重复子问题</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.word1 = word1;</span><br><span class="line">        <span class="built_in">this</span>.word2 = word2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lcsLength</span> <span class="operator">=</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (m - lcsLength) + (n - lcsLength);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == m || j == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) {</span><br><span class="line">            memo[i][j] = dp(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(i + <span class="number">1</span>, j),</span><br><span class="line">                dp(i, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于两个字符串求子序列的问题，都是用两个指针 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 分别在两个字符串上移动，大概率是动态规划思路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://labu</summary>
      
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="LCS" scheme="http://ruobingw.com/tags/LCS/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://ruobingw.com/2023/10/04/%E6%8E%92%E5%BA%8F/"/>
    <id>http://ruobingw.com/2023/10/04/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-10-04T16:24:09.000Z</published>
    <updated>2023-10-05T17:42:09.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1029-两地调度"><a href="#1029-两地调度" class="headerlink" title="1029. 两地调度"></a><a href="https://leetcode.cn/problems/two-city-scheduling/">1029. 两地调度</a></h1><p>解题思路：贪心 + 排序</p><p>怎么贪：</p><p>培养一个思维：我们不是单独拿一个城市，而是假设所有面试者都去B，那么挑出来去A的应该是代价最小的即按照 <code>cost[i][0] - cost[i][1]</code> 排升序</p><p>也就是 <code>cost[a][0] - cost[a][1] - (cost[b][0] - cost[b][1]) </code> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> {</span><br><span class="line">        Arrays.sort(costs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o1[<span class="number">1</span>] - (o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> costs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">splitN</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">aSum</span> <span class="operator">=</span> <span class="number">0</span>, bSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; splitN; i++) {</span><br><span class="line">            aSum += costs[i][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; i++) {</span><br><span class="line">            bSum += costs[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> aSum + bSum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">涉及排序解法的题目集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数组" scheme="http://ruobingw.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="http://ruobingw.com/tags/Array/"/>
    
    <category term="Sort" scheme="http://ruobingw.com/tags/Sort/"/>
    
    <category term="排序" scheme="http://ruobingw.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Basic-Calculator-Topics</title>
    <link href="http://ruobingw.com/2023/10/03/Basic-Calculator-Topics/"/>
    <id>http://ruobingw.com/2023/10/03/Basic-Calculator-Topics/</id>
    <published>2023-10-03T23:51:58.000Z</published>
    <updated>2023-10-05T17:46:11.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-shi--24fe4/">Labuladong-实现基础计算器</a></p></blockquote><table><thead><tr><th><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></td></tr><tr><td><a href="https://leetcode.cn/problems/basic-calculator-iii/">772. 基本计算器 III</a></td></tr></tbody></table><p>主要借助栈（加减乘除） + 递归（括号）</p><p>加一个<code>preSign '+'</code></p><p>即：</p><p><code>+</code> <code>-</code> 数 直接入栈</p><p><code>* /</code> 借用栈的性质，将计算结果入栈</p><p><code>(</code> <code>)</code> 使用递归先计算括号内的数，将结果入栈</p><p><img src="/2023/10/03/Basic-Calculator-Topics/Basic-Calculator-push-stack-1.jpeg" alt="Basic-Calculator-push-stack-1"></p><h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">char</span>[] cArr = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (cArr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">'+'</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cArr.length;) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cArr[i])) {</span><br><span class="line">                num = num * <span class="number">10</span> + (cArr[i] - <span class="string">'0'</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ((!Character.isDigit(cArr[i]) &amp;&amp; cArr[i] != <span class="string">' '</span>) || i == cArr.length - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) {</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) {</span><br><span class="line">                    stack.push(-<span class="number">1</span> * num);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek * num);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(peek / num);</span><br><span class="line">                }</span><br><span class="line">                sign = cArr[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            sum += stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">基础计算器专题类问题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="计算器" scheme="http://ruobingw.com/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    
    <category term="Basic-Calculator" scheme="http://ruobingw.com/tags/Basic-Calculator/"/>
    
    <category term="Stack" scheme="http://ruobingw.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://ruobingw.com/2023/10/01/%E6%95%B0%E7%BB%84/"/>
    <id>http://ruobingw.com/2023/10/01/%E6%95%B0%E7%BB%84/</id>
    <published>2023-10-02T03:44:58.000Z</published>
    <updated>2023-10-22T04:44:24.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 - Array"></a>数组 - Array</h1><blockquote><ul><li><a href="/2023/04/05/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></li><li><a href="/2023/10/04/%E6%8E%92%E5%BA%8F/" title="排序">排序</a></li><li><a href="/2023/10/20/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/" title="摩尔投票">摩尔投票</a></li><li><a href="/2023/10/22/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/" title="前后缀分解">前后缀分解</a></li></ul></blockquote><h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></h1><p>非常有意思的情况划分题：</p><blockquote><p>参考：<br><a href="https://leetcode.cn/problems/insert-interval/solutions/472435/shou-hua-tu-jie-57-cha-ru-qu-jian-fen-cheng-3ge-ji/">笨猪爆破组</a></p></blockquote><p>核心在于：</p><ol><li>推入前段不重叠部分</li><li>更新重叠部分再推入</li><li>推入后段不重叠部分</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) {</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; retList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLeft</span> <span class="operator">=</span> newInterval[<span class="number">0</span>], newRight = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 加入左边不重叠的</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (right &lt; newLeft) {</span><br><span class="line">                retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{left, right});</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新重叠范围</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left &gt; newRight) <span class="keyword">break</span>;</span><br><span class="line">            newLeft = Math.min(left, newLeft);</span><br><span class="line">            newRight = Math.max(right, newRight);</span><br><span class="line">        }</span><br><span class="line">        retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]{newLeft, newRight});</span><br><span class="line">        <span class="comment">// 加入右边不重叠部分</span></span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; n; idx++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[idx][<span class="number">0</span>], right = intervals[idx][<span class="number">1</span>];</span><br><span class="line">            retList.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left, right});</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[retList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.length; i++) {</span><br><span class="line">            ret[i] = retList.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1366-通过投票对团队排名"><a href="#1366-通过投票对团队排名" class="headerlink" title="1366. 通过投票对团队排名"></a><a href="https://leetcode.cn/problems/rank-teams-by-votes/">1366. 通过投票对团队排名</a></h1><p>直接排序即可，主要检查对于Comparator的应用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rankTeams</span><span class="params">(String[] votes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> votes.length, m = votes[<span class="number">0</span>].length();</span><br><span class="line">        Map&lt;Character, <span class="type">int</span>[]&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String vote : votes) {</span><br><span class="line">            <span class="type">char</span>[] cArr = vote.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">                <span class="type">int</span>[] cur = hm.getOrDefault(cArr[i], <span class="keyword">new</span> <span class="title class_">int</span>[cArr.length]);</span><br><span class="line">                cur[i]++;</span><br><span class="line">                hm.put(cArr[i], cur);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        List&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hm.entrySet());</span><br><span class="line">        Collections.sort(ls, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Character, <span class="type">int</span>[]&gt;&gt;(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e1, Map.Entry&lt;Character, <span class="type">int</span>[]&gt; e2)</span> {</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e1Key</span> <span class="operator">=</span> e1.getKey();</span><br><span class="line">                <span class="type">Character</span> <span class="variable">e2Key</span> <span class="operator">=</span> e2.getKey();</span><br><span class="line">                <span class="type">int</span>[] e1Value = e1.getValue();</span><br><span class="line">                <span class="type">int</span>[] e2Value = e2.getValue();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> e1Value.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> e1Value[i], second = e2Value[i];</span><br><span class="line">                    <span class="keyword">if</span> (first == second) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> second - first;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> e1Key - e2Key;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, <span class="type">int</span>[]&gt; ele : ls) {</span><br><span class="line">            sb.append(ele.getKey());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">涉及数组的题目集合</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数组" scheme="http://ruobingw.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="http://ruobingw.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>DataBricks</title>
    <link href="http://ruobingw.com/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://ruobingw.com/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2023-09-19T17:27:48.000Z</published>
    <updated>2023-11-17T23:34:34.008Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>本篇文章援引：</p><blockquote><p>一亩三分地 - <a href="https://www.1point3acres.com/bbs/space-uid-764814.html">newgpu</a></p><p><a href="https://www.1point3acres.com/bbs/thread-851795-1-1.html"> 谈谈Databricks和云计算</a></p><p><a href="https://www.1point3acres.com/bbs/thread-855806-1-1.html"> 谈谈Databricks和云计算（二）</a></p><p><a href="https://cloud.tencent.com/developer/article/2191426">腾讯数据湖与湖仓一体架构实践</a></p></blockquote></div><h1 id="Data-Warehouse"><a href="#Data-Warehouse" class="headerlink" title="Data Warehouse"></a>Data Warehouse</h1><p>Running on cluster. </p><p>A place to store structured data.</p><p>Source: offline ETL pipline to insert by batch</p><p>goal is to make data scientist to run SQL query</p><p>特点：</p><ol><li>It is a distributed database hence it has a lot features that database own</li><li>Structured data</li></ol><h2 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h2><p>managed cloud data warehouse</p><p>data warehouse on cloud</p><h1 id="databricks-and-data-lakehouse"><a href="#databricks-and-data-lakehouse" class="headerlink" title="databricks and data lakehouse"></a>databricks and data lakehouse</h1><p>datalake -&gt; data lakehouse</p><p>No need for schema: friendly to semi-structured and non structured data</p><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h2 id="delta-lake"><a href="#delta-lake" class="headerlink" title="delta lake"></a>delta lake</h2><p>stores data itself and its metadata. </p><p>metadata is for ACID transactions and support for a schema with a supporting write-ahead log for data rolling back when necessary </p><p>Data can be stored on the top of S3, like object storage. Delta Lake imports metadata for ACID transactions and schema. These ACID transactions and schema are necessary for SQL workload</p><h2 id="Databricks-SQL"><a href="#Databricks-SQL" class="headerlink" title="Databricks SQL"></a>Databricks SQL</h2><p>Photon execution engine.</p><h2 id="Databricks-Runtime"><a href="#Databricks-Runtime" class="headerlink" title="Databricks Runtime"></a>Databricks Runtime</h2><p>Create machine -&gt; a tuned spark cluster, and spark is ready to go</p><h2 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h2><p>Connect to a cluster that the user have access to. Use scala, python, sql or R to run the spark command and do the manipulation with the data on top of S3</p>]]></content>
    
    
    <summary type="html">记录下databricks的面试</summary>
    
    
    
    <category term="面经" scheme="http://ruobingw.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="八股" scheme="http://ruobingw.com/categories/%E9%9D%A2%E7%BB%8F/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="面经" scheme="http://ruobingw.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树 - Minimum Spanning Tree - MST</title>
    <link href="http://ruobingw.com/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://ruobingw.com/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2023-09-13T02:06:41.000Z</published>
    <updated>2023-09-13T02:17:11.440Z</updated>
    
    <content type="html"><![CDATA[<p>最小生成树算法主要有： </p><ul><li>Kruskal 算法</li><li>Prim 算法</li></ul><h1 id="什么是最小生成树-MST"><a href="#什么是最小生成树-MST" class="headerlink" title="什么是最小生成树 MST"></a>什么是最小生成树 MST</h1><p><strong>先说「树」和「图」的根本区别：树不会包含环，图可以包含环</strong>。</p><p>什么是图的「生成树」呢，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。</p><p><img src="/2023/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/MST_0.png" alt="MST_0"></p><p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。</p><p><strong>最小生成树: 所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」</strong>。</p><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><p>MST 要保证边：</p><p>1、包含图中的所有节点。</p><p>2、形成的结构是树结构（即不存在环）。</p><p>3、权重和最小。</p><p>其中 1， 2可以用并查集来做：</p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><blockquote><p> 详见：<a href="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a> 习题261</p></blockquote><p>对于3:</p><p>用到了贪心思路：</p><p>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 <code>mst</code> 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 <code>mst</code> 集合；否则，这条边不是最小生成树的一部分，不要把它加入 <code>mst</code> 集合。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>To be write…</p><p>1135</p><p>1584</p>]]></content>
    
    
    <summary type="html">了解一下最小生成树</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="并查集" scheme="http://ruobingw.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="http://ruobingw.com/tags/UnionFind/"/>
    
    <category term="最小生成树" scheme="http://ruobingw.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="minimum spanning tree" scheme="http://ruobingw.com/tags/minimum-spanning-tree/"/>
    
    <category term="Kruscal" scheme="http://ruobingw.com/tags/Kruscal/"/>
    
    <category term="Prim" scheme="http://ruobingw.com/tags/Prim/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://ruobingw.com/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://ruobingw.com/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2023-09-10T15:55:03.000Z</published>
    <updated>2023-10-20T18:33:25.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集-解决的问题"><a href="#并查集-解决的问题" class="headerlink" title="并查集 - 解决的问题"></a>并查集 - 解决的问题</h1><ol><li><p>快速的支持以下的操作：（近乎 O(1)）</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol></li><li><p>基本原理: 每一个集合都用一颗树来表示。树根的标号就是整个集合的编号。每个节点存储他的父节点， p[x] 表示x的父节点</p><ol><li><p>用树（不一定是二叉树）的形式来维护集合：</p></li><li><p>集合的根结点为集合编号</p></li><li><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E9%9B%86%E5%90%88.png" alt="uf_集合"></p></li></ol></li><li><p>问题1：</p><ol><li>如何判断树根：<ul><li><code>if (p[x] == x)</code> 根节点的parent是他自己</li></ul></li></ol></li><li><p>问题2: </p><ol><li>如何求x的集合编号：<ul><li><code>while (p[x] ≠ x) x = p[x]</code></li></ul></li></ol></li><li><p>问题3: </p><ol><li>如何合并两个集合：<ul><li>把其中一个集合当成另一个集合的儿子；</li><li>p[x] = y (px 是 x的集合编号， py是y的集合编号）</li><li><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88.png" alt="uf_合并集合"></li></ul></li></ol></li></ol><p>思考：插入需要树的高度的复杂度 → 并查集的优化：路经压缩</p><p>当第一次x节点后，当前路径上经过的所有点都直接指向根节点，因此近乎 O(1)</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9.png" alt="uf_路经压缩"></p><p>并且同时维护节点数量：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    {</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    {</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"C"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (a != b)</span><br><span class="line">            {</span><br><span class="line">                p[a] = b;</span><br><span class="line">                cnt[b] += cnt[a];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q1"</span>)</span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            cout &lt;&lt; cnt[<span class="built_in">find</span>(a)] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>java 代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">            parent[x] = find(parent[x]); <span class="comment">// 这里是用了路经压缩</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里的可以增加一个size数组，用来表示每一个联通块的大小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> {</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    UF(<span class="type">int</span> n) {</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ]; <span class="comment">// 相当于把 rooQ 的parent指定为rootP, 所以rootP的size需要加上rootQ的size</span></span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parent[cur] != cur) {</span><br><span class="line">            parent[cur] = find(parent[cur]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> parent[cur];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h1><p>union很好理解，找到两个根，将其中一个根的parent设置成另一个根的儿子</p><p>主要是find，这里使用了路经压缩：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">        parent[x] = find(parent[x]); <span class="comment">// 这里用了路经压缩, find返回了最上面的根，然后当前栈层就会接上这个根</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 2 -&gt; 3 3 -&gt; 3</span><br><span class="line">4 -&gt; 4</span><br><span class="line">5 -&gt; 6 6 -&gt; 6</span><br><span class="line"></span><br><span class="line">所以是 1-&gt;2-&gt;3; 4-&gt;4; 6-&gt;6; 三个集合</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>那么用 <code>1-&gt;2-&gt;3</code>举例子：1的父节点是2，2的父节点是3，而3是其自己的父节点。</p><p>如果我们调用<code>find(1)</code>：</p><ol><li><code>parent[1]</code> 是 2，不等于1，所以我们要递归地找<code>find(2)</code>。</li><li><code>parent[2]</code> 是 3，不等于2，所以我们要递归地找<code>find(3)</code>。</li><li><code>parent[3]</code> 是 3，等于3，所以返回3。</li></ol><p>在这个过程中，我们还会更新<code>parent[1]</code>和<code>parent[2]</code>都为3，因为3是1和2的代表。这就是路径压缩的优化，确保每个节点都直接指向其代表，从而使得后续的查找操作更快。</p><p>等于说：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/uf_%E8%B7%AF%E7%BB%8F%E5%8E%8B%E7%BC%A9_2.jpeg" alt="uf_路经压缩_2"></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/description/#">200. 岛屿数量</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n * m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                        parent[i * m + j] = i * m + j;</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + dx[dir], newY = j + dy[dir];</span><br><span class="line">                        <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp; grid[newX][newY] == <span class="string">'1'</span>) {</span><br><span class="line">                            uf.union(</span><br><span class="line">                                i * m + j, newX * m + newY</span><br><span class="line">                            );</span><br><span class="line">                        };</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721. 账户合并"></a><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        UnionFind(List&lt;List&lt;String&gt;&gt; accounts) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> accounts.size();</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="keyword">if</span> (rootQ == rootP) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(accounts);</span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="keyword">if</span> (!emailToId.containsKey(curEmail)) {</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    uf.union(i, emailToId.get(curEmail));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> uf.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id, emails);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet()){</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));</span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323.无向图中连通分量的数目"></a><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/description/">323.无向图中连通分量的数目</a></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            count = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count--;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261.以图判树"></a><a href="https://leetcode.cn/problems/graph-valid-tree/description/">261.以图判树</a></h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集:"></a>并查集:</h3><blockquote><p>树满足两个性质：</p><ol><li>n 个节点 n - 1条边 </li><li>无环</li></ol></blockquote><p>如果一个联通块下相连了两个节点，那么成环：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_1.png" alt="lc_261_1"></p><p>这种无环：</p><p><img src="/2023/09/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/lc_261_2.png" alt="lc_261_2"></p><blockquote><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">        <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        UnionFind(<span class="type">int</span> n) {</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) {</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p), rootQ = find(q);</span><br><span class="line">            <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="comment">// 如果一个联通块下相连了两个节点，那么成环</span></span><br><span class="line">        <span class="comment">// 树满足两个性质：1. n 个节点 n - 1条边 2. 无环</span></span><br><span class="line">        <span class="comment">// 1. n 个节点 n - 1条边</span></span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有无环就是判断两个联通块是否又被尝试链接，如果是，那么就有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], q = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!uf.isConnected(p, q)) {</span><br><span class="line">                uf.union(p, q);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS-Visited"><a href="#DFS-Visited" class="headerlink" title="DFS + Visited"></a>DFS + Visited</h3><p>比较困难的地方在于如何能够判断环即如何使用visited数组，由于这是个无向图，那么比如 <code>0 &lt;-&gt; 1</code> 节点0在遍历邻居1后，邻居1还会遍历它的邻居0，所以会被visited阻止，解决办法是传入一个parent变量，从而可以追踪目前的父节点。当当前节点的邻居和父节点为同一节点时跳过。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> != edges.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        buildGraph(n);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> edges[i][<span class="number">0</span>], b = edges[i][<span class="number">1</span>];</span><br><span class="line">            add(a, b);</span><br><span class="line">            add(b, a);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>, -<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">boolean</span> v : visited) { <span class="comment">// Checks if all nodes are visited</span></span><br><span class="line">            <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> {</span><br><span class="line">        graph.get(from).add(to);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        List&lt;Integer&gt; neighbours = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neig : neighbours) {</span><br><span class="line">            <span class="keyword">if</span> (neig == parent) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(neig, cur)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">理解一下并查集</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="并查集" scheme="http://ruobingw.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="http://ruobingw.com/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra</title>
    <link href="http://ruobingw.com/2023/09/07/Dijkstra/"/>
    <id>http://ruobingw.com/2023/09/07/Dijkstra/</id>
    <published>2023-09-07T14:30:04.000Z</published>
    <updated>2023-09-08T12:40:23.885Z</updated>
    
    
    <summary type="html">理解一下Dijkstra</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>链式前向星-LinkedForwardStar</title>
    <link href="http://ruobingw.com/2023/09/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    <id>http://ruobingw.com/2023/09/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</id>
    <published>2023-09-02T21:48:00.000Z</published>
    <updated>2023-09-08T16:19:50.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式前向星-Linked-Forward-Star"><a href="#链式前向星-Linked-Forward-Star" class="headerlink" title="链式前向星 - (Linked) Forward Star"></a>链式前向星 - (Linked) Forward Star</h1><p>它是一种存图的方式，是优化过的<strong>邻接表</strong>的表达方式</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>为了方便，我们约定 k 为点数，m 为边数。</strong></p><p>邻接矩阵：适用于边数较多的<strong>「稠密图」</strong>使用，当边数量接近点的数量的平方，即 <strong>「m ≈ n^2」</strong> 时，可定义为<strong>「稠密图」</strong>。</p><p>邻接表：适用于边数较少的<strong>「稀疏图」</strong>使用，当边数量接近点的数量，即 <strong>「m ≈ n」</strong> 时，可定义为<strong>「稀疏图」</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> {</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>idx</code> 是用来对边进行编号的，然后对存图用到的几个数组作简单解释：</p><ul><li><code>he</code> 数组：存储是某个节点所对应的边的集合（链表）的头结点；</li><li><code>e</code> 数组：由于访问某一条边指向的节点；</li><li><code>ne</code> 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边；</li><li><code>w</code> 数组：用于记录某条边的权重为多少。</li></ul><p>因此当我们想要遍历所有由 <code>a</code> 点发出的边时，可以使用如下方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i]) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i], c = w[i]; <span class="comment">// 存在由 a 指向 b 的边，权重为 c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自己整理的java版本：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedForwardStar</span> {</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>[] edge = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    LinkedForwardStar() {</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span> {</span><br><span class="line">        edge[tot] = b; <span class="comment">// 设置边的终点</span></span><br><span class="line">        next[tot] = head[a]; <span class="comment">// 设置该边的下一条边</span></span><br><span class="line">        weight[tot] = w; <span class="comment">// 设置该边的权重</span></span><br><span class="line">        head[a] = tot; <span class="comment">// 更新节点 u 的出边起始位置</span></span><br><span class="line">        tot++; <span class="comment">// 增加边数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseFrom</span><span class="params">(<span class="type">int</span> a)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Traversing from node "</span> + a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[a]; i != -<span class="number">1</span>; i = next[i]) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weight[i];</span><br><span class="line">            System.out.println(a + <span class="string">" -&gt; "</span> + v + <span class="string">" weight: "</span> + w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LinkedForwardStar</span> <span class="variable">lfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedForwardStar</span>();</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        lfs.add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        lfs.add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 遍历从各个节点出去的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            lfs.traverseFrom(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p><a href="https://mp.weixin.qq.com/s/2Ba8-NI7lQh2_MvMpg-CZg">图论 - 存图方式 - 三叶</a></p><p>非链式前向星的建图方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) {</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">理解一下链式前向星</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="数据结构" scheme="http://ruobingw.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://ruobingw.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="邻接表" scheme="http://ruobingw.com/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>从二叉树到回溯到DP</title>
    <link href="http://ruobingw.com/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/"/>
    <id>http://ruobingw.com/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/</id>
    <published>2023-08-20T20:12:52.000Z</published>
    <updated>2023-10-25T06:58:48.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>暂略，已经练习很多了</p><p>见 <a href="/2023/04/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a> 中包含所有二叉树</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：<br><a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵茶山艾府 - 回溯 - [14 - 16]</a></p><p>自己之前也收集过：见 <a href="/2023/04/20/%E5%9B%9E%E6%BA%AF/" title="回溯">回溯</a> </p></div><blockquote><p>回溯有一个增量构造答案的过程，这个过程通常使用递归来实现。选 “a”, “b”, “c” 选 “ad” …</p></blockquote><blockquote><p>递归： 考虑好边界条件以及和非边界条件写对即可。剩下交给数学归纳法</p></blockquote><p>回溯/动归三问：-&gt; 主要是为了写对 <strong>边界条件以及和非边界条件</strong></p><ul><li><p>当前操作是什么？</p></li><li><p>子问题是什么？</p></li><li><p>下一个子问题是什么？</p></li></ul><h2 id="子集型"><a href="#子集型" class="headerlink" title="子集型"></a>子集型</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以有两种思路：</p><p>站在输入的角度：</p><p>枚举第 i 个元素 你是<strong>选/不选</strong></p><blockquote><p>ps: 01背包与此相似</p></blockquote><p>每个数都可以在子集中，也可以不在子集中</p><p>此时：<strong>叶子结点是答案</strong></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E8%BE%93%E5%85%A5%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_输入角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作 <ol><li>枚举第 i 个数<strong>选/不选</strong></li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= i + 1的数字中构造子集</li></ol></li></ol><p>站在<strong>答案</strong>角度：</p><p>枚举第一个数选择谁，第二个数选择谁，</p><p>此时：<strong>每个节点都是答案</strong></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E7%AD%94%E6%A1%88%E8%A7%92%E5%BA%A6_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.png" alt="78_答案角度_选或不选"></p><p>回溯三问：</p><ol><li>当前操作 <ol><li>枚举答案的第一个数选什么第二个数选什么…</li></ol></li><li>子问题<ol><li>从下标 &gt;= i 的数字中构造子集</li></ol></li><li>下一个子问题<ol><li>从下标 &gt;= j + 1的数字中构造子集</li></ol></li></ol><h2 id="组合型"><a href="#组合型" class="headerlink" title="组合型"></a>组合型</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>子集 + 剪枝 = 组合型问题</p><p>下图（左选两个数，右选三个数）</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E7%BB%84%E5%90%88%E5%9E%8B%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D1.png" alt="组合型回溯-剪枝1"></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/77_%E6%80%9D%E8%B7%AF.png" alt="77_思路"></p><blockquote><p>为什么从大到小枚举呢？</p></blockquote><p>假设我们需要选 3 个数，现在已经选了1个了，即 k = 3, m = 1; 我们还需要选择 d = k - m -&gt; 3 - 1 = 2 个数</p><p>由于是从大到小枚举，那么我们如果 i &lt; d; 即要选的数为[1,1] 也就是1的话那么是无论如何都没办法选出来两个数 k = 2 的（这是因为题目的范围是[1,n]）所以从大到小会比较容易剪枝</p><blockquote><p>正序枚举怎么做呢？</p></blockquote><p><code>k - path.size()</code> 是 我们还需要几个</p><p>我们要判断的就是还需要的能否被正确的提供，当前我们剩余的个数是 <code>n - i + 1</code></p><p>因此如果需要的不能被满足，直接提前截止即可 <code> if (k - path.size() &gt; n - cur + 1) return;</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于组合型和子集型回溯有两种思考路径：</p><ul><li>选或不选 - 输入视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></li></ul></li><li>枚举选哪个 - 输出视角<ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">分割回文串</a></li></ul></li></ul><h2 id="排列型"><a href="#排列型" class="headerlink" title="排列型"></a>排列型</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%8E%92%E5%88%97%E5%9E%8B%E5%9B%9E%E6%BA%AF.png" alt="排列型回溯"></p><p>和组合的区别就在于<code>[2, 1]</code> 和 <code>[1, 2]</code>在组合中被认定为一种，但是排列中则是两种不同的</p><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>主要参考：</p><p>灵茶山艾府：</p><p><a href="https://www.bilibili.com/video/BV1Xj411K7oF/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">从记忆化搜索到<strong>递推</strong></a></p><p><a href="https://www.bilibili.com/video/BV1AM4y1x7r4/?spm_id_from=333.999.0.0">选或不选 vs 枚举选哪个</a></p></div><p>主要还是<br>状态定义 + 状态转移</p><p>可以借用子集型回溯中的</p><p>选或不选 / 选哪个</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E5%90%AF%E5%8F%91.png" alt="dp_启发"></p><h2 id="从上至下-记忆化搜索"><a href="#从上至下-记忆化搜索" class="headerlink" title="从上至下 - 记忆化搜索"></a>从上至下 - 记忆化搜索</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.png" alt="dp_记忆化搜索"></p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2_2.png" alt="dp_记忆化搜索_2"></p><h2 id="从下而上-递推"><a href="#从下而上-递推" class="headerlink" title="从下而上 - 递推"></a>从下而上 - 递推</h2><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/dp_%E9%80%92%E5%BD%92%E5%88%B0%E9%80%92%E6%8E%A8.png" alt="dp_递归到递推"></p><h1 id="回溯例题"><a href="#回溯例题" class="headerlink" title="回溯例题"></a>回溯例题</h1><h2 id="子集型-1"><a href="#子集型-1" class="headerlink" title="子集型"></a>子集型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">17. 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</span><br><span class="line">78. 子集 https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/</span><br><span class="line">131. 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</span><br><span class="line">784. 字母大小写全排列 https://leetcode.cn/problems/letter-case-permutation/</span><br><span class="line">1601. 最多可达成的换楼请求数目 https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/</span><br><span class="line">2397. 被列覆盖的最多行数 https://leetcode.cn/problems/maximum-rows-covered-by-columns/</span><br><span class="line">306. 累加数 https://leetcode.cn/problems/additive-number/ </span><br><span class="line">2698. 求一个整数的惩罚数 https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/</span><br></pre></td></tr></tbody></table></figure><h2 id="组合型-1"><a href="#组合型-1" class="headerlink" title="组合型"></a>组合型</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">77. 组合 https://leetcode.cn/problems/combinations/solutions/2071017/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-65lh/</span><br><span class="line">216. 组合总和 III https://leetcode.cn/problems/combination-sum-iii/solutions/2071013/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-feme/</span><br><span class="line">22. 括号生成 https://leetcode.cn/problems/generate-parentheses/solutions/2071015/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-wcdw/</span><br><span class="line">301. 删除无效的括号 https://leetcode.cn/problems/remove-invalid-parentheses/</span><br></pre></td></tr></tbody></table></figure><h2 id="排列型-1"><a href="#排列型-1" class="headerlink" title="排列型"></a>排列型</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">46. 全排列 https://leetcode.cn/problems/permutations/solutions/2079585/hui-su-bu-hui-xie-tao-lu-zai-ci-jing-que-6hrh/</span><br><span class="line">51. N 皇后 https://leetcode.cn/problems/n-queens/solutions/2079586/hui-su-tao-lu-miao-sha-nhuang-hou-shi-pi-mljv/</span><br><span class="line">52. N 皇后 II（直接用 51 题代码搞定）https://leetcode.cn/problems/n-queens-ii/solution/hui-su-miao-sha-nhuang-hou-yi-ge-shi-pin-l41</span><br></pre></td></tr></tbody></table></figure><h1 id="子集型："><a href="#子集型：" class="headerlink" title="子集型："></a>子集型：</h1><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String[] hm = <span class="keyword">new</span> <span class="title class_">String</span>[] {</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">"abc"</span>,</span><br><span class="line">        <span class="string">"def"</span>,</span><br><span class="line">        <span class="string">"ghi"</span>,</span><br><span class="line">        <span class="string">"jkl"</span>,</span><br><span class="line">        <span class="string">"mno"</span>,</span><br><span class="line">        <span class="string">"pqrs"</span>,</span><br><span class="line">        <span class="string">"tuv"</span>,</span><br><span class="line">        <span class="string">"wxyz"</span></span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>[] digitCharArr;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">        digitCharArr = digits.toCharArray();</span><br><span class="line">        n = digitCharArr.length;</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">innerRes</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (innerRes.length() != <span class="number">0</span>) res.add(innerRes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> digitCharArr[curIdx] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hm[idx].length(); i++) {</span><br><span class="line">            sb.append(hm[idx].charAt(i));</span><br><span class="line">            backtrack(curIdx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/78_%E6%80%9D%E8%B7%AF.jpeg" alt="78_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>);</span><br><span class="line">        backtrackChooseFromEnumeration(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 选或不选</span></span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        path.addLast(nums[curIdx]);</span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// not select</span></span><br><span class="line">        backtrackSelectOrNot(curIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackChooseFromEnumeration</span><span class="params">(<span class="type">int</span> curIdx)</span> {</span><br><span class="line">        <span class="comment">// 枚举选哪个</span></span><br><span class="line">        paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span> (curIdx == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">innerIdx</span> <span class="operator">=</span> curIdx; innerIdx &lt; n; innerIdx++) {</span><br><span class="line">            path.addLast(nums[innerIdx]);</span><br><span class="line">            backtrackChooseFromEnumeration(innerIdx + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选或不选：</p><p>每一次抉择（backtrackSelectOrNot function中）都只有两种选择，选或者不选，并且这种情况下只有叶子结点为答案，因此需要判断是否为叶子结点，如果是的话才加入答案中</p><p>枚举选哪个：</p><p>每一次枚举（backtrackChooseFromEnumeration中）都可以选择curIdx之后的数，且所有的节点都为答案，因此无需判断直接加入，只需要做好递归的边界即可</p><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/131_%E6%80%9D%E8%B7%AF.jpeg" alt="131_思路"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] sCharArr;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        sCharArr = s.toCharArray();</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="comment">// backtrackEnumerate(0);</span></span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选择这个逗号 （最后一个char (i - 1) 一定要选）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            backtrackSelectOrNot(start, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择这个逗号</span></span><br><span class="line">        <span class="comment">// 检查是否回文</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtrackSelectOrNot(i + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumerate</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="comment">// 枚举子串的终点</span></span><br><span class="line">        <span class="keyword">if</span> (start == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(start, i)) {</span><br><span class="line">                path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                backtrackEnumerate(i + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (sCharArr[left] == sCharArr[right]) {</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><p>两个难点：</p><ol><li>决策树如何画</li><li>如何将char 小写变大写，大写变小写</li></ol><p>问题1:</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/784_%E6%80%9D%E8%B7%AF.png" alt="784_思路"></p><p>问题2:</p><a href="/2023/04/15/Java%E7%A2%8E%E7%A2%8E%E5%BF%B5/" title="Java碎碎念">Java碎碎念</a><p><code>char[idx] ^= 1 &lt;&lt; 5</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 回溯</span></span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题其实可以不用恢复现场，因为我们需要的是叶子结点；但是我们需要先处理 <code>不转换当前char</code>再处理<code>转换当前char</code>由于回溯发生在不转换，即没有变化，那也就不需要回溯现场了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] cArr;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> {</span><br><span class="line">        n = s.length();</span><br><span class="line">        cArr = s.toCharArray();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (startIdx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">String</span>(cArr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(cArr[startIdx])) {</span><br><span class="line">            backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cArr[startIdx] ^= <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        backtrack(startIdx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2397-被列覆盖的最多行数"><a href="#2397-被列覆盖的最多行数" class="headerlink" title="2397. 被列覆盖的最多行数"></a><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数</a></h1><p>这道题关键在于枚举列然后计算覆盖的行然后统计最大即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] matrix, matrixCopy;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRows</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        matrixCopy = <span class="keyword">new</span> <span class="title class_">int</span>[m][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            matrixCopy[i] = matrix[i].clone();</span><br><span class="line">        }</span><br><span class="line">        backtrack(<span class="number">0</span>, numSelect);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIdx, <span class="type">int</span> numSelect)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n - startIdx &lt; numSelect) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (numSelect == <span class="number">0</span>) {</span><br><span class="line">            max = Math.max(max, countCovers());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            backtrack(i + <span class="number">1</span>, numSelect - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; m; r++) {</span><br><span class="line">                matrix[r][i] = matrixCopy[r][i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countCovers</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (count == n) ret++; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a><a href="https://leetcode.cn/problems/additive-number/">306. 累加数</a></h1><p>这道题自己的做法是枚举切割的起始点，能做但是比较复杂；</p><p>如果回溯返回boolean想要记录结果的话：</p><p><code>if (backtrack()) return true</code></p><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">numSelected</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    LinkedList&lt;BigInteger&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> backtrack(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cutIdx)</span> {</span><br><span class="line">        <span class="comment">// System.out.println(path + " " + cutIdx);</span></span><br><span class="line">        <span class="keyword">if</span> (cutIdx == n) {</span><br><span class="line">            <span class="keyword">return</span> path.size() &gt;= <span class="number">3</span> &amp;&amp; check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num.charAt(cutIdx) == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (check(path.get(path.size() - <span class="number">2</span>), </span><br><span class="line">                path.get(path.size() - <span class="number">1</span>), BigInteger.ZERO)) {</span><br><span class="line">                    path.addLast(BigInteger.ZERO);</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    path.removeLast();   </span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                path.addLast(BigInteger.ZERO);</span><br><span class="line">                <span class="keyword">if</span> (backtrack(cutIdx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();  </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cutIdx; i &lt; n; i++) {</span><br><span class="line">                <span class="type">BigInteger</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(num.substring(cutIdx, i + <span class="number">1</span>));</span><br><span class="line">                path.addLast(current);</span><br><span class="line">                <span class="keyword">if</span> (path.size() &gt;= <span class="number">3</span> &amp;&amp; !check(path.get(path.size() - <span class="number">3</span>), path.get(path.size() - <span class="number">2</span>), current)) {</span><br><span class="line">                    path.removeLast();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (backtrack(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(BigInteger a, BigInteger b, BigInteger c)</span> {</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        <span class="keyword">return</span> sum.equals(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://leetcode.cn/problems/additive-number/solutions/1201929/gong-shui-san-xie-hui-su-gao-jing-du-jia-6o6b/">三叶的解法</a>是枚举结束点</p><p>并且这里教了如何使用高精度加法：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    String num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAdditiveNumber</span><span class="params">(String _num)</span> {</span><br><span class="line">        num = _num;</span><br><span class="line">        n = num.length();</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">return</span> m &gt;= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num.charAt(u) == <span class="string">'0'</span> ? u + <span class="number">1</span> : n;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> u; i &lt; max; i++) {</span><br><span class="line">            cur.add(<span class="number">0</span>, num.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">2</span> || check(list.get(m - <span class="number">2</span>), list.get(m - <span class="number">1</span>), cur)) {</span><br><span class="line">                list.add(cur);</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(List&lt;Integer&gt; a, List&lt;Integer&gt; b, List&lt;Integer&gt; c)</span> {</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size() || i &lt; b.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.size()) t += a.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; b.size()) t += b.get(i);</span><br><span class="line">            ans.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) ans.add(t);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> c.size() == ans.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.size() &amp;&amp; ok; i++) {</span><br><span class="line">            <span class="keyword">if</span> (c.get(i) != ans.get(i)) ok = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">作者：宫水三叶</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/additive-number/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><h1 id="2698-求一个整数的惩罚数"><a href="#2698-求一个整数的惩罚数" class="headerlink" title="2698. 求一个整数的惩罚数"></a><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">2698. 求一个整数的惩罚数</a></h1><p>这道题非常有意思，可以用两个指针来做到选或不选的思路：</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E9%80%89%E6%88%96%E4%B8%8D%E9%80%89.jpeg" alt="2698_选或不选"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 选或不选</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, <span class="number">0</span>, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (end == square.length) {</span><br><span class="line">            <span class="keyword">return</span> i == sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; square.length - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (backtrack(square, start, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sum += sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(square, end + <span class="number">1</span>, end + <span class="number">1</span>, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        sum -= sumUp(square, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sumUp</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> end)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++){</span><br><span class="line">            x = x * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从答案的视角枚举</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/2698_%E6%9E%9A%E4%B8%BE.jpeg" alt="2698_枚举"></p><p>其实就是枚举逗号位置</p><p>在start = 0 时候 i尝试 0, 1, 2, 3 也就是[0,0],[0, 1], [0,2],[0,3] 即temp = 1, 12, 129, 1296 sum = <code>此时的 temp</code></p><p>在start = 1 时候 i尝试 1, 2, 3 也就是[1, 1], [1,2],[1,3] 即temp = 2, 29, 296; sum = <code>start = 0 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 2 时候 i尝试 2, 3 也就是[2,2],[2,3] 即temp = 9, 96; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code> + <code>此时的 temp</code></p><p>在start = 3 时候 i尝试 3 也就是[3,3] 即temp = 6; sum = <code>start = 0 时候的temp</code>+ <code>start = 1 时候的temp</code>  + <code>start = 2 时候的temp</code>+ <code>此时的 temp</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] square = Integer.toString(i * i).toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, <span class="number">0</span>, i)) {</span><br><span class="line">                res += i * i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">char</span>[] square, <span class="type">int</span> start, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (start == square.length) <span class="keyword">return</span> target == sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 开始枚举</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; square.length; i++) {</span><br><span class="line">            temp = temp * <span class="number">10</span> + square[i] - <span class="string">'0'</span>;</span><br><span class="line">            sum = sum + temp;</span><br><span class="line">            <span class="keyword">if</span> (backtrackEnumeration(square, i + <span class="number">1</span>, target)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            sum = sum - temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="子集型总结"><a href="#子集型总结" class="headerlink" title="子集型总结"></a>子集型总结</h1><p>一般可以从选和不选以及枚举选哪个来做；</p><p>碰到需要选择切点的，类似于306, 以及2698题，我们可以先通过把一个数变成一个string或者char[]来进行枚举。</p><p>另外枚举状态下的回溯就是无非是当前层然后深入下一层然后碰到递归终点返回之后会继续尝试</p><p>其达成的效果就是当前层穷举，下一层穷举…</p><p>所以这就是所谓的递归不要管他是如何深入的。只要知道做了什么事，怎么出去，完成当前scope下的任务即可</p><h1 id="组合型-2"><a href="#组合型-2" class="headerlink" title="组合型"></a>组合型</h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><p>无优化剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从大到小枚举剪枝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(n);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - path.size()) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i - <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从小到大枚举</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k - path.size() &gt; n - cur + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= n; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrack(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackEnumeration</span><span class="params">(<span class="type">int</span> start)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            backtrackEnumeration(i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">9</span>) {</span><br><span class="line">            <span class="keyword">if</span> (path.size() != k) <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size(); i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == n) paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选</span></span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选</span></span><br><span class="line">        path.addLast(cur);</span><br><span class="line">        backtrackSelectOrNot(cur + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h1><p>依旧是使用了选和不选的操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Character&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        m = <span class="number">2</span> * n;</span><br><span class="line">        backtrackSelectOrNot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrackSelectOrNot</span><span class="params">(<span class="type">int</span> parenthesisSum, <span class="type">int</span> leftParenthesisCount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum == m) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : path) {</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            paths.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 选左括号</span></span><br><span class="line">        <span class="keyword">if</span> (leftParenthesisCount &lt; n) {</span><br><span class="line">            path.addLast(<span class="string">'('</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不选左括号（选右括号）</span></span><br><span class="line">        <span class="keyword">if</span> (parenthesisSum - leftParenthesisCount &lt; leftParenthesisCount) {</span><br><span class="line">            path.addLast(<span class="string">')'</span>);</span><br><span class="line">            backtrackSelectOrNot(parenthesisSum + <span class="number">1</span>, leftParenthesisCount);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是这个树的构成是要计算左右可选的括号数量而不是盲目的选或者不选。</p><p>比如：我们一开始会选择左括号，当不选择左括号的时候（左括号数量满足数量），我们会去选择有括号，这时候是不选左括号的下分情况的选择右括号的情况：（右括号的数量 &lt; 左括号的数量）</p><h1 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301. 删除无效的括号"></a><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h1><p>暴力的穷举每一个括号看是选择还是不选择</p><p>答案加入到数组里后从中选择最长的就是满足要求的，将最长的加入答案</p><p>另外判断一个字符串的括号是否合法的函数也很有意思，可以多学习一下, 思路是用代表左括号的指针移动，碰到左括号右移，右括号左移，如果left == 0证明合法，否则比如左括号的idx &lt; 0则代表右括号&gt;左括号数量，不合法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        n = s.length();</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> filterResult();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">filterResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 筛选出最长的有效括号字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            maxLen = Math.max(maxLen, str.length());</span><br><span class="line">        }</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : paths) {</span><br><span class="line">            <span class="keyword">if</span> (str.length() == maxLen) {</span><br><span class="line">                set.add(str);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb.toString())) {</span><br><span class="line">                paths.add(sb.toString());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>) {</span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 选择当前的括号</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不选择当前的括号</span></span><br><span class="line">            backtrack(idx + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String sb)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sb.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 右括号比左括号多，肯定无效</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果左括号的数量等于右括号的数量，才是一个有效的括号字符串</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排列型-2"><a href="#排列型-2" class="headerlink" title="排列型"></a>排列型</h1><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">boolean</span>[] numAppeared;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        numAppeared = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> idx)</span> {</span><br><span class="line">        System.out.println(idx + <span class="string">" "</span> + path);</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            paths.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!numAppeared[i]) {</span><br><span class="line">                numAppeared[i] = <span class="literal">true</span>;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                backtrack(idx + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                numAppeared[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意的有两个点：</p><ol><li>backtrack中的for loop 是 <code>i: [0, n)</code> 因为我们每一次都要看从 0 开始的然后通过boolean[] 来判断是否加入答案</li><li>注意递归时候是 <code>(idx + 1)</code> 而不是 <code>(i + 1)</code> <ol><li><code>idx</code>应该表示的是当前的排列中已经放置了多少数字，或者说正在为哪个位置选择数字。然后选择的是 <code>[0, n]</code></li></ol></li></ol><h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>这道题有两种思维方式，首先是 <a href="https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-c26da/">labuladong</a>的比较好理解的，其次是<a href="https://www.bilibili.com/video/BV1mY411D7f6/?spm_id_from=333.788&amp;vd_source=54f34024c3784d45de85a3f70808ab70">灵神</a>的通过抽屉原理证明的全排列</p><p>其方法核心大差不差，主要是在构造上</p><p>核心：枚举每一行上的皇后的全排列，在不冲突的前提下进行构造</p><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><p>labuladong版本：</p><p>整体比较长，每一次都需要判断左上和右上角是否冲突</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chessRow : chessBoard) {</span><br><span class="line">            Arrays.fill(chessRow, <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backtracking(chessBoard, curRow, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curRow == n) {</span><br><span class="line">            <span class="comment">// 到叶子结点，将此时的棋盘加入答案</span></span><br><span class="line">            res.add(array2List(chessBoard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">curCol</span> <span class="operator">=</span> <span class="number">0</span>; curCol &lt; n; curCol++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(chessBoard, curRow, curCol)) {</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'Q'</span>;</span><br><span class="line">                backtracking(chessBoard, curRow + <span class="number">1</span>, n);</span><br><span class="line">                chessBoard[curRow][curCol] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> curRow, <span class="type">int</span> curCol)</span> {</span><br><span class="line">        <span class="comment">// 检查同一列是不是已经有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; curRow; r++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][curCol] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 \ 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol - <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; r--, c--) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 / 是否有Queen</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> curRow - <span class="number">1</span>, c = curCol + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; chessBoard[<span class="number">0</span>].length; r--, c++) {</span><br><span class="line">            <span class="keyword">if</span> (chessBoard[r][c] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span> {</span><br><span class="line">        List&lt;String&gt; transformedArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> chessBoard.length, c = chessBoard[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessBoard) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">                sb.append(chars[j]);</span><br><span class="line">            }</span><br><span class="line">            transformedArray.add(sb.toString());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transformedArray;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>灵神的第一个版本也需要判断：</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A7%A3%E6%B3%951.png" alt="N皇后_灵神_解法1"></p><p>但是加入了一点数学证明：即右上方的 r + c == 当前的 r + c 左上方的 r - c == 当前的 r - c:</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/N%E7%9A%87%E5%90%8E_%E7%81%B5%E7%A5%9E_%E8%A1%8C%E5%88%97.png" alt="N皇后_灵神_行列"></p><p>从而发现我们可以通过开辟两个<code>boolean[]</code>来看r + c是否之前出现过如果出现过就说明当前位置无法放置皇后因为会冲突</p><p>修改过后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            List&lt;String&gt; board = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c : col) {</span><br><span class="line">                <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">                Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">                row[c] = <span class="string">'Q'</span>;</span><br><span class="line">                board.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">            }</span><br><span class="line">            paths.add(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="52-N-皇后-II"><a href="#52-N-皇后-II" class="headerlink" title="52. N 皇后 II"></a><a href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h2><p>只需要稍微更改下逻辑即可：这里我们返回计数而不是构造了一个答案</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span>[] col;</span><br><span class="line">    <span class="type">boolean</span>[] onPath, diagRPlusC, diagRMinusC;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRMinusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        diagRPlusC = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (r == n) {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n; c++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> r - c + n - <span class="number">1</span>; <span class="comment">// 防止负的index</span></span><br><span class="line">            <span class="keyword">if</span> (!onPath[c] &amp;&amp; !diagRPlusC[r + c] &amp;&amp; !diagRMinusC[rc]) {</span><br><span class="line">                col[r] = c;</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(r + <span class="number">1</span>);</span><br><span class="line">                onPath[c] = diagRPlusC[r + c] = diagRMinusC[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="DP例题"><a href="#DP例题" class="headerlink" title="DP例题"></a>DP例题</h1><h1 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h1><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">198. 打家劫舍 https://leetcode.cn/problems/house-robber/solutions/2102725/ru-he-xiang-chu-zhuang-tai-ding-yi-he-zh-1wt1/</span><br><span class="line">70. 爬楼梯 https://leetcode.cn/problems/climbing-stairs/</span><br><span class="line">746. 使用最小花费爬楼梯 https://leetcode.cn/problems/min-cost-climbing-stairs/</span><br><span class="line">2466. 统计构造好字符串的方案数 https://leetcode.cn/problems/count-ways-to-build-good-strings/</span><br><span class="line">213. 打家劫舍 II https://leetcode.cn/problems/house-robber-ii/</span><br><span class="line">213. 打家劫舍 II 题解 https://leetcode.cn/problems/house-robber-ii/solution/jian-ji-xie-fa-zhi-jie-diao-yong-198-ti-qhvri/</span><br></pre></td></tr></tbody></table></figure><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><p>按照思路一步步来：</p><ol><li>回溯怎么写：<ol><li>当前操作：选或者不选当前这家偷</li><li>子问题和下一个子问题：<ol><li>如果之前偷了，那就是从 n - 2开始</li><li>如果之前不偷，那就是从 n - 1开始</li></ol></li></ol></li></ol><p>回溯代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里的回溯定义，返回了从 n - 1开始之前的打家劫舍的最大值</p><p>加入记忆化搜索：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] cache;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtrack(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cache[i] != -<span class="number">1</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(backtrack(i - <span class="number">1</span>), backtrack(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        cache[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改造为递推 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        dp[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i + <span class="number">2</span>] = Math.max(dp[i + <span class="number">1</span>], dp[i] + nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空间优化（由于 i + 2 只和i + 1 以及 i 有关）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>由于现在是环形那么我们就是在原版的198中增加了一些条件限制：</p><ul><li>如果选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>2</code>开始；因为是环形，偷了第<code>i = 0</code>个意味着不能偷<code>i = n - 1</code>，也就是 偷<code>n - 2</code><ul><li>因此问题变成从<code>nums[2]</code> 到 <code>nums[n−2]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li><li>如果<code>不</code>选<code>nums[0]</code>进行偷窃，我们下一个偷的就从<code>1</code>开始；因为是环形，偷了第 <code>i = 1</code>个意味着不能偷<code>i = n - 2</code>，也就是 偷<code>n - 1</code><ul><li>因此问题变成从<code>nums[1]</code> 到 <code>nums[n−1]</code> 的非环形版本，调用 198 题的代码解决</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robFromLC198(nums, <span class="number">2</span>, n - <span class="number">2</span>) + nums[<span class="number">0</span>], robFromLC198(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robFromLC198</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            f = Math.max(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1; <span class="comment">// f1 是当前的上一个，对于下一个属于上上一个</span></span><br><span class="line">            f1 = f; <span class="comment">// f 是当前的，对于下一次属于上一个</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h1><p>这是一道树形DP：</p><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%A0%91%E5%BD%A2DP_%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93.png" alt="树形DP_思路总结"></p><blockquote><p>这个考点叫树上最大独立集</p><p>最大独立集：从图中选出尽量多的点，是的这些点互不相邻；它的变形是最大化点权之和</p></blockquote><p><img src="/2023/08/20/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%9B%9E%E6%BA%AF%E5%88%B0DP/%E6%A0%91%E5%BD%A2DP_%E4%B8%80%E8%88%AC%E6%A0%91_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3.png" alt="树形DP_一般树_打家劫舍3"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 应该就是将遍历方式转变为了tree的traversal</span></span><br><span class="line">    <span class="comment">// 就是 treeDFS + DP</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="type">int</span>[] res = dfs2(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(node)) {</span><br><span class="line">            <span class="keyword">return</span> memo.get(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 偷：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rob_result</span> <span class="operator">=</span> node.val </span><br><span class="line">        + (node.left == <span class="literal">null</span> ? <span class="number">0</span> : rob(node.left.left) + rob(node.left.right))</span><br><span class="line">        + (node.right == <span class="literal">null</span> ? <span class="number">0</span> : rob(node.right.left) + rob(node.right.right));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不偷，那就是由孩子们决定：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">not_rob_result</span> <span class="operator">=</span> rob(node.left) + rob(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.max(rob_result, not_rob_result);</span><br><span class="line">        memo.put(node, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点进行决策偷和不偷能获得的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dfs2(TreeNode node) {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] leftResult = dfs2(node.left);</span><br><span class="line">        <span class="type">int</span>[] rightResult = dfs2(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷：</span></span><br><span class="line">        <span class="comment">// 就不能偷下家</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resRob</span> <span class="operator">=</span> leftResult[<span class="number">0</span>] + rightResult[<span class="number">0</span>] + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不偷</span></span><br><span class="line">        <span class="comment">// 可以选择偷不偷下家其结果是由左子树的最大值（偷或不偷能获得的最大金额）和右子树的最大值决定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resNotRob</span> <span class="operator">=</span> Math.max(leftResult[<span class="number">0</span>], leftResult[<span class="number">1</span>]) + Math.max(rightResult[<span class="number">0</span>], rightResult[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {resNotRob, resRob};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p><ul><li>爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶</li><li>爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</li></ul><p>所以我们得到公式 dp[n]=dp[n−1]+dp[n−2]<br>同时需要初始化 dp[0]=1 和 dp[1]=1<br>时间复杂度：O(n)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// dp[i] 来表示到第i层的最低开销 dp[cost.length] 就是 到最顶</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        Arrays.stream(dp).forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后是基于dp数组的空间优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> <span class="number">0</span>, dpi2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length + <span class="number">1</span>; i++) {</span><br><span class="line">            minCost = Math.min(dpi1 + cost[i - <span class="number">1</span>], dpi2 + cost[i - <span class="number">2</span>]);</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = minCost;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Arrays.stream(dp).forEach(e -&gt; System.out.println(e));</span></span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后是这次写出来的版本：根本区别是我定义是到达这个位置的最小成本（初始化f0 = cost[0] f1 = cost[1]）而之前的是初始化为0</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">f0</span> <span class="operator">=</span> cost[<span class="number">0</span>], f1 = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">newF</span> <span class="operator">=</span> Math.min(f0, f1) + cost[i];</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = newF;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.min(f0, f1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2466-统计构造好字符串的方案数"><a href="#2466-统计构造好字符串的方案数" class="headerlink" title="2466. 统计构造好字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h1><ol><li>题目中：请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。<ol><li>范围比较大，就是大概率dp问题</li></ol></li><li>这道题和 70 题类似思路是：<ol><li>dp定义：dp[i] 是当前长度为i的字符串数目<ol><li>所以答案是 dp[row] + … + dp[high]</li></ol></li><li>状态转移：和 70 题类似：<ol><li>70 是要么一次爬一级楼梯要么爬两级所以转移从 i - 1 以及 i - 2 得到</li><li>这道题是 转移从 zero 或者 one 得到 <ol><li>i - zero 为末尾加了 zero 个 零</li><li>i - one 为 末尾 加了 one 个 一</li></ol></li></ol></li><li>初始化 技巧：涉及到方案数我们可以列举Corner Case e.g.: 如果是空串，那么就是 <code>f[0] = 1</code>空串的字符串个数为1</li><li>取MOD</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= high; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) dp[i] = (dp[i] + dp[i - zero]) % MOD ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) dp[i] = (dp[i] + dp[i - one]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) {</span><br><span class="line">            ans = (ans + dp[i]) % MOD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">输出：8</span><br></pre></td></tr></tbody></table></figure><p>我们有dp数组：1 2 4 8</p><ul><li><code>dp[1]</code> = 2 (可以由1个1组成 或者 由1个0)</li><li><code>dp[2]</code> = 4 (<code>1</code>0， <code>1</code>1，<code>0</code>1，<code>0</code>0）</li><li><code>dp[3]</code> = 8 (<code>10</code>0，<code>10</code>1，<code>11</code>0，<code>11</code>1，<code>01</code>0，<code>01</code>1，<code>00</code>0，<code>00</code>1)</li></ul><p>所以就是每一次都将<code>添加1或0后的形成的方案数</code>+ <code>之前的结果转移</code>得到</p><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包-和-完全背包"><a href="#0-1背包-和-完全背包" class="headerlink" title="0-1背包 和 完全背包"></a>0-1背包 和 完全背包</h2><h2 id="494-目标和-01背包"><a href="#494-目标和-01背包" class="headerlink" title="494. 目标和 - 01背包"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a> - 01背包</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = <span class="built_in">this</span>.nums.length;</span><br><span class="line">        <span class="comment">// p &lt;- + 所能够组成的和</span></span><br><span class="line">        <span class="comment">// s &lt;- sum of the nums</span></span><br><span class="line">        <span class="comment">// s - p &lt;- - 所能组成的集合 </span></span><br><span class="line">        <span class="comment">// p - (s - p) = t</span></span><br><span class="line">        <span class="comment">// p - s + p = t</span></span><br><span class="line">        <span class="comment">// t = 2p - s</span></span><br><span class="line">        <span class="comment">// p = (t + s) // 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> target + s;</span><br><span class="line">        <span class="keyword">if</span> (p % <span class="number">2</span> != <span class="number">0</span> || s &lt; target || p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 递推</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[n + 1][p + 1];</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= p; j++) {</span></span><br><span class="line">        <span class="comment">//         if (j &lt; nums[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][j] = dp[i][j];</span></span><br><span class="line">        <span class="comment">//         } else {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][j] = dp[i][j] + dp[i][j - nums[i]];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n][p];</span></span><br><span class="line">        <span class="comment">// 递推优化I:</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[2][p + 1];</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= p; j++) {</span></span><br><span class="line">        <span class="comment">//         if (j &lt; nums[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[(i + 1) % 2][j] = dp[i % 2][j];</span></span><br><span class="line">        <span class="comment">//         } else {</span></span><br><span class="line">        <span class="comment">//             dp[(i + 1) % 2][j] = dp[i % 2][j] + dp[i % 2][j - nums[i]];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n % 2][p];</span></span><br><span class="line">        <span class="comment">// 递推优化II：</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[p + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> p; j &gt;= num; j--) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - num];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[p];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> target == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][target] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][target];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[idx]) {</span><br><span class="line">            <span class="comment">// 容量不够了 </span></span><br><span class="line">            memo[idx][target] = dp(idx - <span class="number">1</span>, target); </span><br><span class="line">            <span class="keyword">return</span> memo[idx][target];</span><br><span class="line">        } </span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> dp(idx - <span class="number">1</span>, target) + dp(idx - <span class="number">1</span>, target - nums[idx]);</span><br><span class="line">        memo[idx][target] = tot;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="322-零钱兑换-完全背包"><a href="#322-零钱兑换-完全背包" class="headerlink" title="322. 零钱兑换 - 完全背包"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a> - 完全背包</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] coins;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = coins.length;</span><br><span class="line">        <span class="built_in">this</span>.coins = coins;</span><br><span class="line">        <span class="comment">// this.memo = new int[n + 1][amount + 1];</span></span><br><span class="line">        <span class="comment">// for (int[] m : memo) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(m, -1);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// int result = dp(0, amount);</span></span><br><span class="line">        <span class="comment">// return result &gt;= Integer.MAX_VALUE / 2 ? -1 : result;</span></span><br><span class="line">        <span class="comment">// 递推I - 无优化</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[n + 1][amount + 1];</span></span><br><span class="line">        <span class="comment">// for (int[] d : dp) {</span></span><br><span class="line">        <span class="comment">//     Arrays.fill(d, Integer.MAX_VALUE / 2);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int capacity = 0; capacity &lt;= amount; capacity++) {</span></span><br><span class="line">        <span class="comment">//         if (capacity &lt; coins[i]) {</span></span><br><span class="line">        <span class="comment">//             dp[i + 1][capacity] = dp[i][capacity];</span></span><br><span class="line">        <span class="comment">//             continue;</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">      <span class="comment">// 这里指的是如果不选那么直接从上一个转移过来，如果选当前 i + 1 那么就从去掉当前 coint的地方转移而来</span></span><br><span class="line">        <span class="comment">//         dp[i + 1][capacity] = Math.min(dp[i][capacity], dp[i + 1][capacity - coins[i]] + 1);</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// return dp[n][amount] &lt; Integer.MAX_VALUE / 2 ? dp[n][amount] : -1;</span></span><br><span class="line">        <span class="comment">// 递推II - 一维数组</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> coin; capacity &lt;= amount; capacity++) {</span><br><span class="line">                dp[capacity] = Math.min(dp[capacity], dp[capacity - coin] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dp[amount];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE / <span class="number">2</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="keyword">if</span> (idx == n) {</span><br><span class="line">            <span class="keyword">return</span> amount == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE / <span class="number">2</span>; <span class="comment">// 由于是取min, 所以这里返回0指有合法方案；</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (memo[idx][amount] != -<span class="number">1</span>) <span class="keyword">return</span> memo[idx][amount];</span><br><span class="line">        <span class="keyword">if</span> (coins[idx] &gt; amount) {</span><br><span class="line">            memo[idx][amount] = dp(idx + <span class="number">1</span>, amount);</span><br><span class="line">            <span class="keyword">return</span> memo[idx][amount];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(dp(idx + <span class="number">1</span>, amount), dp(idx, amount - coins[idx]) + <span class="number">1</span>); <span class="comment">// 对于选择了硬币之后产生的方案数，我们对硬币数目+1</span></span><br><span class="line">        memo[idx][amount] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">记录下二叉树到DP的练习过程以及思路总结</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="二叉树" scheme="http://ruobingw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="回溯" scheme="http://ruobingw.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="backtrack" scheme="http://ruobingw.com/tags/backtrack/"/>
    
  </entry>
  
  <entry>
    <title>周赛记录</title>
    <link href="http://ruobingw.com/2023/08/20/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://ruobingw.com/2023/08/20/%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2023-08-20T18:34:53.000Z</published>
    <updated>2023-08-20T06:39:36.538Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>🐛🦆！（飘了）</p></div><h1 id="第-359-场周赛"><a href="#第-359-场周赛" class="headerlink" title="第 359 场周赛"></a>第 359 场周赛</h1>]]></content>
    
    
    <summary type="html">记录下周赛</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="周赛" scheme="http://ruobingw.com/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>面试经验集合</title>
    <link href="http://ruobingw.com/2023/08/16/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/"/>
    <id>http://ruobingw.com/2023/08/16/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%9B%86%E5%90%88/</id>
    <published>2023-08-16T15:06:02.000Z</published>
    <updated>2023-10-03T21:28:20.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>集合类</p><ol><li>collection list set queue<br>LinkedList arraylist 区别<br>LinkedBlockingQueue</li><li>Map hashmap linkedhashmap sortMap<br>cuccrenthashmap</li></ol><p>多线程</p><ol><li>用到那些多线程框架<br>newCachedThreadPool newFixedThreadPool newSingleThreadExecutor newScheduleThreadPool</li></ol><p>锁</p><ol><li>synchronized ReentrantLock 区别<br>lock</li><li>公平锁/非公平锁</li><li>可重入锁 synchronized</li><li>独享锁/共享锁</li><li>互斥锁/读写锁 ReentrantLock</li><li>乐观锁/悲观锁 区别？ CAS算法</li><li>分段锁 ConcurrentHashMap</li></ol><p>tpc三次握手和四次挥手</p><p>epoll和select区别</p><p>设计模式<br>主要用到那些<br>Singleton 工厂 代理模式</p><p>spring 中用到的动态代理<br>动态代理实现和种类，区别</p><p>jvm回收，java的类加载机制</p><p>微服务，服务注册发现</p><p>docker k8s</p><p>数据库<br>介绍下sql优化经验<br>数据库有哪些常用的引擎，主要区别，索引的实现原理<br>b数，b+数的区别</p><p>动态内容<br>HA+Nginx<br>mybatis 动态分页组件<br>zookeeper 应用场景，一致性hash运用<br>对java 高并发的rpc框架<br>本地缓存+分布式缓存</p><p>1、关于spring的aop的实现方法<br>2、关于分布式消息队列，分布式缓存<br>3、关于rpc方面<br>4、关于hashmap源码实现<br>5、关于Java异常的续承层次结构，讲述异常的续承关系<br>6、关于https握手过程<br>7、关于java数据库问题定位和性能调优<br>8、关于设计模式，uml，jvm 内存回收机制问题<br>9、java中重载和重写有什么区别？分别用什么关键字？<br>10、java线程如何启动？<br>11、java中加锁的方式有哪些，怎么个写法？<br>12、乐观锁和悲观锁解释一下<br>13、ORACLE中的SQL如何进行优化，都有哪些方式？<br>14、java中类的加载机制<br>15、介绍一下自己最近做的一个典型的项目<br>16、在项目中遇到了哪些问题，自己是如何解决的<br>17、说一下有哪些常用的设计模式<br>18、事务有哪些特性，在ORACLE中隔离有哪些级别<br>19、使用memcached是一个什么样的原理<br>20、如何存放数据到memcached集群中，介绍一下这个过程。跟进的问题，讲一下一致性哈希算法的实现原理。<br>21、JVM中堆是如何管理的，JVM的内存回收机制，介绍一下<br>22、数据库慢查询优化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//笔试题目: 无</span></span><br><span class="line"><span class="comment">// 一、基础</span></span><br><span class="line"><span class="comment">//1.面向对象的特征</span></span><br><span class="line"><span class="comment">//2.重载和重写的区别</span></span><br><span class="line"><span class="comment">//3.抽象类和接口的区别</span></span><br><span class="line"><span class="comment">//4.List和Set区别（Arraylist、LinkedList）</span></span><br><span class="line"><span class="comment">//5.HashMap（原理及实现）</span></span><br><span class="line"><span class="comment">//6.线程池的原理及实现（ThreadLocal）</span></span><br><span class="line"><span class="comment">//7.JVM运行时内存区域(内存溢出OOM问题)</span></span><br><span class="line"><span class="comment">//8.常见的设计模式？简单介绍1~2个</span></span><br><span class="line"><span class="comment">//9.MySQL个人简单总结（索引优化）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 二、代码</span></span><br><span class="line"><span class="comment">//1.饿汉式、懒汉式的单例模式Java代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Databricks-数据🧱"><a href="#Databricks-数据🧱" class="headerlink" title="Databricks 数据🧱"></a>Databricks 数据🧱</h1><a href="/2023/09/19/DataBricks-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="DataBricks">DataBricks</a>]]></content>
    
    
    <summary type="html">记录下面试</summary>
    
    
    
    <category term="面经" scheme="http://ruobingw.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://ruobingw.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://ruobingw.com/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://ruobingw.com/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-12T01:58:16.000Z</published>
    <updated>2023-07-22T16:59:47.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>背包问题包含以下这些：<br><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E8%83%8C%E5%8C%85%E6%A6%82%E8%BF%B0.png" alt="背包概述"></p><p>主要需要掌握的是01背包以及完全背包</p><p>完全背包是01背包的演化，完全背包的物品数量无限</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>定义：</p><p>有 <code>n</code> 件物品和一个最多能背重量为<code>w</code>的背包。</p><p>第 <code>i</code>件物品的重量是<code>weight[i]</code>，可以得到的价值是<code>value[i]</code>。每件物品只能用一次</p><p>将哪些物品放入背包里物品价值总和最大。</p><p>暴力解法：对于每一个物品我们有两个选择，选或者不选，所以可以采用回溯法来搜索所有的情况时间复杂度为 O(2^n) n是物品数量</p><p>所以需要优化 穷举 + 求最值 -&gt; 动态规划</p><h3 id="题目假设"><a href="#题目假设" class="headerlink" title="题目假设"></a>题目假设</h3><p>背包最大重量为4，有如下的物品：</p><table><thead><tr><th>重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>目前最大价值为 4 * 15 = 60</p><h4 id="二维dp来解决01背包问题"><a href="#二维dp来解决01背包问题" class="headerlink" title="二维dp来解决01背包问题"></a>二维dp来解决01背包问题</h4><ol><li><p>分析dp数组含义</p><p><code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p></li><li><p>递推公式</p><p><code>dp[i][j]</code>能被转移过来的情况分成两种</p><p>如果不放物品，就是从<code>dp[i - 1][j]</code>转移而来，由于不放入新的重量所以其实重量就还是<code>dp[i - 1][j]</code> 可能的场景是：当物品i的重量超过了背包能够承载的容积，新的物品i无法放入其中</p><p>如果放物品，考虑<code>dp[i - 1][j - weight[i]]</code>含义为背包容量为 <code>j - weight[i]</code>时候的不放入i所能获得的最大价值，贪心一点，我们必须要腾出这部分的空间才行因为我们要保证背包是一直饱和的状态是当时的最优解。</p><p>在0-1背包问题中，<code>dp[i][j]</code>通常表示前i个物品填满背包容量为j的最大价值。<code>dp[i - 1][j - weight[i]]</code>表示的是在背包容量为<code>j-weight[i]</code>的时候，前<code>i-1</code>个物品的最大价值。之所以使用这个状态转移方程，是因为我们在考虑是否将第i个物品放入背包时，需要先确定在还没有放入第i个物品，并且背包容量为<code>j-weight[i]</code>时的最大价值。</p><p>这里的“j - weight[i]”是为了腾出第i个物品所需的空间，以便我们能够将其放入背包。之后，我们将该物品的价值<code>value[i]</code>加上<code>dp[i - 1][j - weight[i]]</code>，这样就能得到在将第i个物品放入背包的情况下，能够得到的最大价值。</p><p>简单来说，<code>dp[i - 1][j - weight[i]] + value[i]</code>就表示：在考虑放入第i个物品（即在已经腾出了第i个物品所需的空间后），我们能够得到的最大价值。如果不把这个空间腾出来，那我们就没有地方放这个物品。</p></li><li><p>初始化</p><p>我们首先要对一个二维的数组来进行初始化因此需要搞清楚 [i] 和 [j] 的含义</p><p>回想定义：<code>dp[i][j]</code>用来表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为j的背包，价值总和最大为多少</p><p>那么 <code>dp[i][0]</code>指的是如果背包容量j为0，表示从下标<code>[0,i]</code>的物品随便取一个，放进容量为0的背包，价值总和最大为多少，那么明显是0</p><p>其次由于我们需要使用 <code>dp[i - 1][j]</code> 来作为其中一项来推导<code>dp[i][j]</code>因此我们需要初始化<code>dp[0][j]</code>即，存放编号0的各种容量的背包中能获得的最大价值那么会有两种情况：</p><p>当 <code>j &lt; weight[0]</code>的时候，<code>dp[0][j]</code> 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code> 应该是value[0]，因为背包容量放足够放编号0物品。</p></li></ol><p>​综上，对于上面的例子我们有：</p><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E5%88%9D%E5%A7%8B%E5%8C%961.png" alt="01背包初始化1"></p><p>对于其他的，由于都会被转化并且被覆盖新值，因此无论初始化成什么都可以</p><ol start="4"><li><p>确定遍历顺序</p><p>我们需要遍历是应该从物品[i]还是背包容积[j]开始</p><p>由于<code>dp[i][j]</code>所需要的数据就是左上角</p></li></ol><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F.png" alt="01背包遍历顺序"></p><p>所以无论从哪里开始都可以得到结果</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="/2023/07/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85%E7%BB%93%E6%9E%9C.jpeg" alt="01背包结果"></p><h4 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h4><p>由于<code>dp[i][j]</code>仅依赖于前一个物品的值（<code>dp[i - 1][j]</code> 和 <code>dp[i - 1][j - weight[i]]</code>），所以实际上我们并不需要维护一个二维数组，只需要一个一维数组就足够了。这个问题的特殊之处在于，<code>dp[i][j]</code>的值只依赖于<code>dp[i-1][*]</code>，即只依赖于前一个物品的状态。这给我们提供了一个优化空间，那就是我们其实不需要存储所有的i，也就是不需要存储所有物品的状态，只需要存储前一个物品的状态就足够了。这就是为什么我们可以省去一个维度的原因。我们使用一维数组dp[j]来替代二维数组<code>dp[i][j]</code>。在每一次的迭代中，dp[j]表示的都是在考虑当前物品，并且在背包容量为j的情况下，我们能获得的最大价值。换句话说，我们的一维数组dp[j]在每次迭代过程中，都相当于原来二维数组的<code>dp[i][j]</code>。</p><ol><li>dp数组含义：</li></ol><p>此时的含义就变为:</p><p>我们有容量为j的背包从前i个物品取能取到的最大价值</p><ol start="2"><li>转移方程递推公式：</li></ol><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>即：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>初始化：</li></ol><p>最初dp[0]容量为0的背包，那么最大价值一定为0</p><ol start="4"><li>遍历顺序</li></ol><p><strong>重点</strong>：在这个优化策略中，我们必须从大到小遍历j，这是因为dp[j - weight[i]]必须在dp[j]之前更新。原因是我们在每次迭代中都在复用上一轮迭代中的结果。为了确保这次迭代的结果不会影响到下一次迭代，我们需要从大到小遍历j。</p><p>具体地说，如果我们从小到大遍历j，考虑在计算dp[j]时，由于dp[j - weight[i]]可能在这个迭代过程中已经被更新过（因为j - weight[i] &lt; j），我们就会使用到这个物品i在多次的情况，这明显违反了我们的原始假设（每个物品只能用一次）。为了避免这个问题，我们选择从大到小遍历j，在计算dp[j]时，dp[j - weight[i]]对应的就是上一轮迭代的结果，也就是没有使用过物品i的情况。</p><p>例如，假设我们有物品的重量和价值分别为2和3，背包的容量为4，初始化dp数组为0。如果从小到大遍历j，计算过程如下：</p><ul><li>当j=2时，dp[2] = max(dp[2], dp[2-2] + 3) = 3</li><li>当j=3时，dp[3] = max(dp[3], dp[3-2] + 3) = 3</li><li>当j=4时，dp[4] = max(dp[4], dp[4-2] + 3) = 6</li></ul><p>在这个例子中，dp[4]的值为6，明显不对，因为我们的物品只有一个，但我们却计算得到了两个物品的价值，这就是因为在计算dp[4]时，dp[2]已经使用过当前物品，被更新为3了。</p><p>结论：从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></h1><p>第一个难点是如何转化为01背包问题：</p><p>这道题首先我们要等和，所以一个背包的容积就是 sum / 2</p><p>那么我们就是看是不是<strong>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p><blockquote><p>注意不能直接看除2是否能除尽，因为除2不代表有对应的子集比如[1,2,5]</p></blockquote><p><code>dp</code> 数组的定义：<code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</p><p>根据 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case:</span></span><br><span class="line">        <span class="comment">// 意思是当没有物品时背包永远不可能被装满</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= col; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 意思是当背包容量为0时，直接就是满的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= row; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= col; j++) {</span><br><span class="line">                <span class="comment">// 背包容量不够的情形：</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 没有办法再放入当前的物品, 结果就是如果之前的能刚好放进去，那么现在不放也可以刚好放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果我 i 刚好能放进去，那么我放入nums[i]也刚好能放进去</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt;= row; i++) {</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= col; j++) {</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " ");</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化：</p><p>相当于i直接就是每一层搞一次，但我们不用存储 i - 1的结果了，直接覆盖就可以了</p><p>Eg: [1,2,5]</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>t</td><td>f</td><td>f</td><td>f</td><td>f</td></tr><tr><td>1</td><td>t</td><td>t</td><td>f</td><td>f</td><td>f</td></tr><tr><td>2</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr><tr><td>3</td><td>t</td><td>t</td><td>t</td><td>t</td><td>f</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[col + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col; j &gt;= <span class="number">1</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];  </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// StringBuilder result = new StringBuilder();</span></span><br><span class="line">            <span class="comment">// for (boolean element : dp) {</span></span><br><span class="line">            <span class="comment">//     result.append(element).append(" ");</span></span><br><span class="line">            <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// // Remove the trailing space before printing</span></span><br><span class="line">            <span class="comment">// System.out.println(result.toString().trim());</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[col];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049.最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量 II</a></h1><p>和416类似，重点是要知道如何转换为01背包问题</p><p>对于石头问题，我们想要的是尽量让两边相等然后看差值。</p><p>那么就是有个容量为 sum/2的背包，里面能够装的最大的重量，就是尽可能让两边相等的解法。</p><p>所以就是：</p><p>对于容积为sum/2的背包，我们有 stones[i] 价值的，重量为stones[i]的石头，怎么放，价值最大：</p><p>常规的二维dp：</p><blockquote><p>注意labuladong和代码随想录不一样，labuladong的i从1开始然后 i - 1是对应的价值。而代码随想录从0开始，i就是对应的价值了</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[stones.length + <span class="number">1</span>][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sum / <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &gt; j) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 打印dp数组 </span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; stones.length; i++) { </span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= sum / 2; j++) { </span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + " "); </span></span><br><span class="line">        <span class="comment">//     } </span></span><br><span class="line">        <span class="comment">//     System.out.println(); </span></span><br><span class="line">        <span class="comment">// } </span></span><br><span class="line">        <span class="keyword">return</span> sum - dp[stones.length][sum / <span class="number">2</span>] - dp[stones.length][sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>滚动数组优化，注意遍历顺序，（虽然道理已经明白了，可是还是不太懂这个到底是怎么优化的。。。）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum / <span class="number">2</span>; j &gt;= stones[i - <span class="number">1</span>]; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] - dp[sum / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h1><p>本题的关键难点在于如何做好问题转化，即怎么把这个问题转换为01背包问题：</p><p>这是一个经典的子集和问题（subset sum problem）转化。原始问题是从数组 <code>nums</code> 中选取若干数，可以加上+或-号，使得它们的总和为 <code>target</code>。问题被转化为找出 <code>nums</code> 中有多少个子集 <code>A</code> 使得这个子集的和等于 <code>(target + sum(nums)) / 2</code>。</p><p>为什么要这样转化呢？我们来详细理解下。</p><p>原始方程是：<br>[ sum(A) - sum(B) = target ]</p><p>其中，<code>A</code> 是被加上 <code>+</code> 号的子集，<code>B</code> 是被加上 <code>-</code> 号的子集。</p><p>再加上以下方程：<br>[ sum(A) + sum(B) = sum(nums) ]</p><p>两边都加上 <code>sum(A)</code>：<br>[ 2 \times sum(A) = target + sum(nums) ]</p><p>从这个方程，我们得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]</p><p>这就将原始问题转化为一个子集和问题，即从 <code>nums</code> 中找到所有子集 <code>A</code>，其和为 <code>(target + sum(nums)) / 2</code>。这是一个经典的动态规划问题，通常使用一个二维数组 <code>dp</code> 来解决。<code>dp[i][j]</code> 表示使用前 <code>i</code> 个数字，能否组成和为 <code>j</code> 的子集。</p><p>那么为什么是<code>(target + sum(nums)) / 2</code> 而不是 target呢？</p><p>假设<code>nums: [1,2,3,4]</code> 和 <code>target:4</code> 。</p><p>首先，我们看转化的方法：</p><ol><li><p>从 <code>nums</code> 中选择数字，有的加上 <code>+</code> 号，有的加上 <code>-</code> 号，使其总和为 <code>target</code>。</p></li><li><p>使用转化方法，我们得到以下方程：<br>[ sum(A) - sum(B) = target ]<br>[ sum(A) + sum(B) = sum(nums) ]<br>代入第一个方程得到：<br>[ sum(A) = (target + sum(nums)) / 2 ]<br>[ sum(A) = (4 + 10) / 2 = 7 ]</p></li></ol><p>所以，我们需要找到 <code>nums</code> 中子集和为7的所有情况。</p><p>以下是子集和为7的组合：</p><ol><li>[1,2,4]</li><li>[3,4]</li></ol><p>这些组合可以得到如下的表示达到 target 4：</p><ol><li>+1+2+4-3</li><li>+3+4-1-2</li></ol><p>现在，如果我们直接找出 <code>nums</code> 中的子集和为 <code>target=4</code> 的组合，我们得到：</p><ol><li>[1,3]</li><li>[4]</li></ol><p>这些组合表示了如何通过简单组合 <code>nums</code> 中的数字得到4，但没有表示如何通过加法和减法操作得到4。这就是为什么直接使用 <code>target</code> 作为背包容量是不准确的，因为你只能得到部分答案，而不能表示如何通过整个 <code>nums</code> 数组的加减操作得到目标值 <code>target</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>][subSetTotal + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 注意一下这里的初始化，dp[i][0]因为现在有可能性什么都不装即有一种装法，即从dp[0][0]转移而来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length + <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subSetTotal + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>二维变一维：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subSetTotal</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 背包大小 subsettotal:</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[subSetTotal + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> subSetTotal; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subSetTotal];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">记录背包问题的相关习题</summary>
    
    
    
    <category term="Algorithms" scheme="http://ruobingw.com/categories/Algorithms/"/>
    
    
    <category term="动态规划" scheme="http://ruobingw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="dp" scheme="http://ruobingw.com/tags/dp/"/>
    
    <category term="背包" scheme="http://ruobingw.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
</feed>
